<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <title>Infinity Platformer - Fixed & Improved</title>
    <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no"/>
    <style>
        :root{
            --primary:#6e8efb; --secondary:#a777e3; --darker:#16213e;
            --text:#fff; --coin:#F1C40F; --danger:#E74C3C;
        }
        *{box-sizing:border-box;margin:0;padding:0}
        html,body{height:100%}
        body{
            background:linear-gradient(180deg,#0f0c29,#16213e);
            color:var(--text);
            font-family:Inter,Arial,Helvetica,sans-serif;
            overflow:hidden;
            -webkit-font-smoothing:antialiased;
            -moz-osx-font-smoothing:grayscale;
        }
        .parallax-bg{position:fixed;inset:0;z-index:0;pointer-events:none}
        .parallax-bg:before{
            content:"";position:absolute;inset:0;background:
              radial-gradient(circle at 10% 20%, rgba(255,255,255,0.03), transparent 5%),
              radial-gradient(circle at 80% 80%, rgba(255,255,255,0.02), transparent 5%);}
        canvas{position:fixed;inset:0;z-index:2;display:block}
        #ui{position:fixed;left:20px;top:20px;z-index:10;background:rgba(0,0,0,0.35);padding:10px 14px;border-radius:12px;backdrop-filter:blur(6px);display:flex;gap:14px;align-items:center}
        .stat{display:flex;align-items:center;gap:8px;font-weight:600}
        #level-display{position:fixed;right:20px;top:20px;z-index:10;background:rgba(0,0,0,0.35);padding:10px 14px;border-radius:12px}
        #damage-effect{position:fixed;inset:0;z-index:5;pointer-events:none;background:rgba(231,76,60,0);transition:background-color .2s}
        #startScreen,#gameOverScreen,#victoryScreen{
            position:fixed;inset:0;display:flex;align-items:center;justify-content:center;flex-direction:column;z-index:40;
            background:linear-gradient(180deg,rgba(0,0,0,0.7),rgba(0,0,0,0.85));backdrop-filter:blur(6px)
        }
        .game-button{padding:12px 20px;border-radius:999px;border:none;background:linear-gradient(90deg,var(--primary),var(--secondary));color:white;font-weight:700;cursor:pointer}
        .controls{position:fixed;bottom:22px;left:50%;transform:translateX(-50%);z-index:30;display:flex;gap:8px}
        .control-btn{width:64px;height:64px;border-radius:50%;background:rgba(255,255,255,0.06);display:flex;align-items:center;justify-content:center;color:white;font-weight:700}
        .loading{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:60;font-size:1.25rem}
        .combo-display{position:fixed;left:50%;transform:translateX(-50%);top:100px;font-weight:900;color:var(--coin);text-shadow:0 0 10px rgba(241,196,15,0.15);z-index:12;opacity:0;transition:opacity .2s}
        .power-up-indicator{position:fixed;left:20px;top:90px;z-index:12;background:rgba(0,0,0,0.35);padding:8px 10px;border-radius:10px;backdrop-filter:blur(6px);display:flex;gap:8px;align-items:center;opacity:0}
        @media (max-width:700px){
            #ui{left:12px;top:12px;padding:8px}
            .control-btn{width:54px;height:54px}
        }
    </style>
</head>
<body>
    <div class="parallax-bg"></div>
    <canvas id="gameCanvas"></canvas>

    <div id="ui">
        <div class="stat"><span>‚ù§</span><span id="health">150</span><div style="width:120px;height:12px;background:rgba(255,255,255,0.08);border-radius:10px;overflow:hidden">
            <div id="health-fill" style="width:100%;height:100%;background:linear-gradient(90deg,var(--danger),#f39c12)"></div></div></div>
        <div class="stat">‚≠ê <span id="score">0</span></div>
        <div class="stat">‚ö° <span id="combo-counter">0</span></div>
    </div>

    <div id="level-display">Level: <span id="level">1</span></div>
    <div id="damage-effect"></div>

    <div id="startScreen">
        <h1 style="font-size:48px;margin-bottom:12px">Infinity Platformer</h1>
        <p style="max-width:640px;text-align:center;color:rgba(255,255,255,0.85);margin-bottom:20px">A short polished platformer demonstration ‚Äî arrows to move, ‚Üë to jump, F to shove, Shift to dash. Mobile controls available.</p>
        <div style="display:flex;gap:12px">
            <button class="game-button" id="startBtn">Start</button>
            <button class="game-button" id="demoBtn">Demo Level</button>
        </div>
    </div>

    <div id="gameOverScreen" style="display:none;flex-direction:column;align-items:center;justify-content:center;color:white">
        <h1 style="font-size:56px;margin-bottom:8px">GAME OVER</h1>
        <p>Final Score: <span id="finalScore">0</span></p>
        <button class="game-button" id="tryAgainBtn" style="margin-top:14px">Try Again</button>
    </div>

    <div id="victoryScreen" style="display:none;flex-direction:column;align-items:center;justify-content:center;color:white">
        <h1 style="font-size:56px;margin-bottom:8px">VICTORY!</h1>
        <p>Final Score: <span id="finalScoreVictory">0</span></p>
        <button class="game-button" id="playAgainBtn" style="margin-top:14px">Play Again</button>
    </div>

    <div class="combo-display" id="comboDisplay">2x COMBO!</div>
    <div class="power-up-indicator" id="powerUpIndicator">üî∞ <span id="powerUpText">Power</span></div>

    <div class="controls" id="mobileControls" style="display:none">
        <div class="control-btn" id="leftBtn">‚óÄ</div>
        <div class="control-btn" id="jumpBtn">‚ñ≤</div>
        <div class="control-btn" id="rightBtn">‚ñ∂</div>
        <div class="control-btn" id="shoveBtn">F</div>
    </div>

<script>
/* Polyfill for roundRect if not available */
if (!CanvasRenderingContext2D.prototype.roundRect) {
    CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, r) {
        if (typeof r === 'number') r = [r, r, r, r];
        this.beginPath();
        this.moveTo(x + r[0], y);
        this.arcTo(x + w, y, x + w, y + h, r[1]);
        this.arcTo(x + w, y + h, x, y + h, r[2]);
        this.arcTo(x, y + h, x, y, r[3]);
        this.arcTo(x, y, x + w, y, r[0]);
        this.closePath();
    };
}

const game = {
    // constants
    GRAVITY: 0.6,
    MAX_FALL_SPEED: 20,
    JUMP_FORCE: -12,
    // state
    canvas: null, ctx: null,
    width: 0, height: 0,
    lastTime: 0,
    camera: {x:0,y:0,tx:0,ty:0},
    // player
    player: null,
    // collections
    platforms: [], collectibles: [], enemies: [], portals: [], checkpoints: [], powerUps: [], projectiles: [], particles: [],
    // gameplay
    score: 0, health: 150, maxHealth:150, combo:0, comboTimeout:null, powerUp:null, powerUpTimer:0,
    currentLevel:1, gameOver:false, isGameComplete:false, gameStarted:false,
    // inputs
    keys:{left:false,right:false,up:false,dash:false,shove:false},
    touch:{left:false,right:false},
    // DOM
    el:{health:null,score:null,level:null,gameOverScreen:null,victoryScreen:null,finalScore:null,finalScoreVictory:null,damageEffect:null,healthFill:null,comboDisplay:null,powerUpIndicator:null,powerUpText:null,startScreen:null},
    init(){
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.width = innerWidth; this.height = innerHeight;
        this.resizeCanvas();
        window.addEventListener('resize',()=>this.resizeCanvas());
        // DOM hooks
        this.el.health = document.getElementById('health');
        this.el.score = document.getElementById('score');
        this.el.level = document.getElementById('level');
        this.el.gameOverScreen = document.getElementById('gameOverScreen');
        this.el.victoryScreen = document.getElementById('victoryScreen');
        this.el.finalScore = document.getElementById('finalScore');
        this.el.finalScoreVictory = document.getElementById('finalScoreVictory');
        this.el.damageEffect = document.getElementById('damage-effect');
        this.el.healthFill = document.getElementById('health-fill');
        this.el.comboDisplay = document.getElementById('comboDisplay');
        this.el.powerUpIndicator = document.getElementById('powerUpIndicator');
        this.el.powerUpText = document.getElementById('powerUpText');
        this.el.startScreen = document.getElementById('startScreen');

        // initial player
        this.player = {
            x:50, y:100, w:34, h:48, speed:5, velY:0, jumping:true, color:'#FF6B6B',
            invincible:false, invTimer:0, facing:1, shoveCooldown:0, dashCooldown:0, dashDuration:0,
            hasDoubleJump:false, canDoubleJump:false, wallSliding:false
        };

        // inputs
        this.setupInput();

        // mobile controls
        this.setupMobileControls();

        // start buttons
        document.getElementById('startBtn').addEventListener('click',()=>this.startGame());
        document.getElementById('demoBtn').addEventListener('click',()=>{ this.startGame(); this.loadLevel(2); });
        document.getElementById('tryAgainBtn').addEventListener('click',()=>this.resetGame());
        document.getElementById('playAgainBtn').addEventListener('click',()=>this.resetGame());

        // build first level
        this.resetGame();

        // start loop
        requestAnimationFrame((t)=>{ this.lastTime=t; this.loop(t); });
    },

    setupInput(){
        window.addEventListener('keydown',(e)=>{
            if (e.key === 'ArrowLeft' || e.key === 'a') this.keys.left = true;
            if (e.key === 'ArrowRight' || e.key === 'd') this.keys.right = true;
            if (e.key === 'ArrowUp' || e.key === 'w' || e.key === ' ') { if (!this.keys.up) this.handleJumpPress(); this.keys.up = true; }
            if (e.key.toLowerCase() === 'f') this.handleShove();
            if (e.key === 'Shift') this.handleDash();
            if (e.key.toLowerCase() === 'r' && (this.gameOver || this.isGameComplete)) this.resetGame();
        });
        window.addEventListener('keyup',(e)=>{
            if (e.key === 'ArrowLeft' || e.key === 'a') this.keys.left = false;
            if (e.key === 'ArrowRight' || e.key === 'd') this.keys.right = false;
            if (e.key === 'ArrowUp' || e.key === 'w' || e.key === ' ') this.keys.up = false;
        });

        // simple mouse/touch to start on canvas (useful on mobile)
        this.canvas.addEventListener('touchstart', (e)=>{ if (!this.gameStarted) this.startGame(); }, {passive:true});
    },

    setupMobileControls(){
        const mobile = document.getElementById('mobileControls');
        if ( /Android|iPhone|iPad|iPod/i.test(navigator.userAgent) ) {
            mobile.style.display = 'flex';
        }
        const leftBtn = document.getElementById('leftBtn');
        const rightBtn = document.getElementById('rightBtn');
        const jumpBtn = document.getElementById('jumpBtn');
        const shoveBtn = document.getElementById('shoveBtn');

        leftBtn.addEventListener('touchstart', (e)=>{ this.touch.left = true; e.preventDefault(); }, {passive:false});
        leftBtn.addEventListener('touchend', (e)=>{ this.touch.left = false; e.preventDefault(); }, {passive:false});
        rightBtn.addEventListener('touchstart', (e)=>{ this.touch.right = true; e.preventDefault(); }, {passive:false});
        rightBtn.addEventListener('touchend', (e)=>{ this.touch.right = false; e.preventDefault(); }, {passive:false});
        jumpBtn.addEventListener('touchstart', (e)=>{ this.handleJumpPress(); e.preventDefault(); }, {passive:false});
        shoveBtn.addEventListener('touchstart', (e)=>{ this.handleShove(); e.preventDefault(); }, {passive:false});
    },

    resizeCanvas(){
        const dpr = window.devicePixelRatio || 1;
        this.width = innerWidth;
        this.height = innerHeight;
        this.canvas.width = Math.round(this.width * dpr);
        this.canvas.height = Math.round(this.height * dpr);
        this.canvas.style.width = this.width + 'px';
        this.canvas.style.height = this.height + 'px';
        this.ctx.setTransform(dpr,0,0,dpr,0,0);
    },

    loop(ts){
        const dt = Math.min(40, ts - this.lastTime); // clamp to avoid huge steps
        this.lastTime = ts;
        if (!this.gameOver && !this.isGameComplete && this.gameStarted){
            this.update(dt);
            this.render();
        }
        requestAnimationFrame(t=>this.loop(t));
    },

    startGame(){
        this.gameStarted = true;
        this.el.startScreen.style.display = 'none';
    },

    resetGame(){
        this.score = 0; this.health = this.maxHealth; this.combo = 0; this.isGameComplete=false; this.gameOver=false;
        this.el.gameOverScreen.style.display = 'none'; this.el.victoryScreen.style.display='none';
        this.player.x = 50; this.player.y = 100; this.player.velY = 0; this.player.jumping=true;
        this.loadLevel(1);
        this.updateUI();
    },

    // UI
    updateUI(){
        this.el.health.textContent = Math.max(0, Math.round(this.health));
        this.el.score.textContent = this.score;
        this.el.level.textContent = this.currentLevel;
        const pct = Math.max(0, Math.min(1, this.health/this.maxHealth))*100;
        this.el.healthFill.style.width = pct + '%';
        this.el.comboDisplay.textContent = this.combo>1? `${this.combo}x COMBO!` : '';
        this.el.comboDisplay.style.opacity = this.combo>1 ? '1' : '0';
        if (this.powerUp) {
            this.el.powerUpIndicator.style.opacity = 1;
            this.el.powerUpText.textContent = this.powerUp.type;
        } else {
            this.el.powerUpIndicator.style.opacity = 0;
        }
    },

    // LEVEL

    loadLevel(levelNum){
        this.currentLevel = levelNum;
        this.el.level.textContent = levelNum;
        // reset arrays
        this.platforms = []; this.collectibles = []; this.enemies = []; this.portals = []; this.checkpoints = []; this.powerUps = []; this.projectiles = []; this.particles = [];

        // universal ground
        this.platforms.push({x:0,y:this.height-60,w:this.width*3,h:60,color:'#4ECDC4',type:'normal'});

        // make a few hand-authored levels
        if (levelNum === 1){
            this.platforms.push({x:160,y:this.height-120,w:120,h:18,color:'#45B7AF',type:'normal'});
            this.platforms.push({x:360,y:this.height-180,w:120,h:18,color:'#3DA199',type:'normal'});
            this.platforms.push({x:560,y:this.height-240,w:120,h:18,color:'#4ECDC4',type:'bouncy'});
            this.collectibles.push({x:190,y:this.height-150,w:18,h:18,type:'coin',col:false,rot:0});
            this.collectibles.push({x:390,y:this.height-210,w:18,h:18,type:'coin',col:false,rot:0});
            this.collectibles.push({x:610,y:this.height-270,w:18,h:18,type:'health',col:false,rot:0});
            this.powerUps.push({x:300,y:this.height-210,w:22,h:22,type:'doubleJump',rot:0,y0:this.height-210});
            this.enemies.push({x:420,y:this.height-220,w:30,h:36,type:'patrol',speed:1.2,dir:1,x0:380,x1:460,health:100});
            this.portals.push({x:720,y:this.height-320,w:44,h:64,target:2,final:false});
            this.checkpoints.push({x:700,y:this.height-120,w:28,h:48,activated:false});
            this.player.x=60; this.player.y=this.height-200;
        } else if (levelNum === 2){
            this.platforms.push({x:220,y:this.height-140,w:90,h:16,color:'#45B7AF',type:'moving',dir:1,spd:1.5,x0:220,x1:420});
            this.platforms.push({x:380,y:this.height-200,w:90,h:16,color:'#3DA199',type:'bouncy'});
            this.platforms.push({x:560,y:this.height-260,w:90,h:16,color:'#4ECDC4',type:'moving',dir:-1,spd:1.2,x0:460,x1:660});
            this.collectibles.push({x:240,y:this.height-170,w:18,h:18,type:'coin',col:false,rot:0});
            this.collectibles.push({x:400,y:this.height-230,w:18,h:18,type:'health',col:false,rot:0});
            this.powerUps.push({x:520,y:this.height-280,w:22,h:22,type:'speed',rot:0,y0:this.height-280});
            this.enemies.push({x:420,y:this.height-230,w:30,h:36,type:'jumper',jumpF:-14,delay:1500,last:0,velY:0,health:100});
            this.enemies.push({x:660,y:this.height-300,w:30,h:36,type:'patrol',speed:1.6,dir:-1,x0:620,x1:760,health:100});
            this.portals.push({x:780,y:this.height-320,w:44,h:64,target:3,final:false});
            this.player.x=60; this.player.y=this.height-200;
        } else {
            // final
            this.platforms.push({x:160,y:this.height-160,w:80,h:14,color:'#3DA199',type:'bouncy'});
            this.platforms.push({x:320,y:this.height-220,w:80,h:14,color:'#45B7AF',type:'normal'});
            this.platforms.push({x:480,y:this.height-280,w:80,h:14,color:'#4ECDC4',type:'moving',dir:1,spd:1.8,x0:430,x1:530});
            this.collectibles.push({x:200,y:this.height-190,w:18,h:18,type:'coin',col:false,rot:0});
            this.powerUps.push({x:350,y:this.height-430,w:22,h:22,type:'invincibility',rot:0,y0:this.height-430});
            this.enemies.push({x:360,y:this.height-250,w:30,h:36,type:'shooter',fireRate:1600,lastShot:0,health:100});
            this.enemies.push({x:520,y:this.height-420,w:30,h:30,type:'flyer',speed:1.6,dir:1,x0:460,x1:620,y0:this.height-420,health:100});
            this.portals.push({x:720,y:this.height-380,w:44,h:64,target:1,final:true});
            this.player.x = 60; this.player.y = this.height-200;
        }

        // reset some player state
        this.player.velY = 0; this.player.jumping = true; this.player.invincible=false; this.player.hasDoubleJump=false; this.player.canDoubleJump=false;
        this.camera.x = 0; this.camera.y = 0;
    },

    // helper collision AABB
    coll(a,b){
        return a.x < b.x + (b.w||b.width) && a.x + a.w > b.x && a.y < b.y + (b.h||b.height) && a.y + a.h > b.y;
    },

    update(dt){
        // dt in ms
        // convert to seconds-ish
        // update timers
        if (this.player.invincible){
            this.player.invTimer -= dt;
            if (this.player.invTimer <= 0) this.player.invincible=false;
        }
        if (this.player.shoveCooldown>0) this.player.shoveCooldown = Math.max(0, this.player.shoveCooldown - dt);
        if (this.player.dashCooldown>0) this.player.dashCooldown = Math.max(0, this.player.dashCooldown - dt);
        if (this.player.dashDuration>0) this.player.dashDuration = Math.max(0, this.player.dashDuration - dt);

        // powerUp timer
        if (this.powerUp){
            this.powerUpTimer -= dt;
            if (this.powerUpTimer <= 0) this.deactivatePowerUp();
        }

        // input horizontal
        let move = 0;
        if (this.keys.left || this.touch.left) move -= 1;
        if (this.keys.right || this.touch.right) move += 1;

        // dash increases speed while active
        let speed = this.player.speed;
        if (this.player.dashDuration>0) speed += 6;

        this.player.x += move * speed;

        if (move !== 0) this.player.facing = move>0?1:-1;

        // horizontal collisions with platforms: naive simple approach
        for (let p of this.platforms){
            // if overlapping vertically, prevent horizontal overlap
            if (this.player.y + this.player.h > p.y && this.player.y < p.y + (p.h||p.height)){
                if (this.player.x < p.x + p.w && this.player.x + this.player.w > p.x){
                    // push player out (simple)
                    if (move>0) this.player.x = p.x - this.player.w;
                    if (move<0) this.player.x = p.x + p.w;
                }
            }
        }

        // gravity & vertical movement
        this.player.velY = Math.min(this.player.velY + this.GRAVITY, this.MAX_FALL_SPEED);
        this.player.y += this.player.velY;

        // vertical collisions: standing on platform
        let onGround = false;
        for (let p of this.platforms){
            // moving platforms update
            if (p.type === 'moving'){
                p.x += p.dir * p.spd;
                if (p.x < p.x0){ p.x = p.x0; p.dir = 1; }
                if (p.x > p.x1){ p.x = p.x1; p.dir = -1; }
            }
            // floating slight bob
            if (p.type === 'floating'){
                p.y = p.y0 + Math.sin(Date.now()/600 + p.x)*6;
            }

            // collision
            const platformRect = {x:p.x,y:p.y,w:p.w,h:p.h||p.height};
            if (this.player.velY >= 0 && 
                this.player.x + this.player.w > p.x && this.player.x < p.x + p.w &&
                this.player.y + this.player.h > p.y && this.player.y + this.player.h < p.y + p.h + 16){

                // land on platform
                this.player.y = p.y - this.player.h;
                this.player.velY = 0;
                this.player.jumping = false;
                onGround = true;
                this.player.canDoubleJump = this.player.hasDoubleJump ? true : false;

                // bounce pads
                if (p.type === 'bouncy'){
                    this.player.velY = -18;
                    this.spawnParticles(this.player.x + this.player.w/2, this.player.y + this.player.h, '#a777e3', 12);
                }
            }
        }

        if (!onGround) this.player.jumping = true;

        // collect collectibles
        for (let i=this.collectibles.length-1;i>=0;i--){
            const c = this.collectibles[i];
            if (this.coll(this.player, {x:c.x,y:c.y,w:c.w||c.width,h:c.h||c.height})){
                // apply effect
                if (c.type === 'coin'){ this.score += 100; this.combo++; this.spawnParticles(c.x + (c.w||18)/2, c.y + (c.h||18)/2, '--', 10); }
                else if (c.type === 'health'){ this.health = Math.min(this.maxHealth, this.health + 40); this.spawnParticles(c.x + (c.w||18)/2, c.y + (c.h||18)/2, '#2ECC71', 10); }
                this.collectibles.splice(i,1);
                // combo show
                if (this.combo > 1){
                    clearTimeout(this.comboTimeout);
                    this.el.comboDisplay.style.opacity = 1;
                    this.el.comboDisplay.textContent = `${this.combo}x COMBO!`;
                    this.comboTimeout = setTimeout(()=>{ this.combo = 0; this.el.comboDisplay.style.opacity = 0; }, 1800);
                }
            } else {
                c.rot = (c.rot||0) + 0.06;
            }
        }

        // powerup pickup
        for (let i=this.powerUps.length-1;i>=0;i--){
            const p = this.powerUps[i];
            if (this.coll(this.player, {x:p.x,y:p.y,w:p.w,h:p.h})){
                this.activatePowerUp(p.type);
                this.powerUps.splice(i,1);
                this.spawnParticles(p.x+p.w/2,p.y+p.h/2,'#9B59B6',16);
            } else { p.rot += 0.04; p.y = p.y0 + Math.sin(Date.now()/700 + p.x)*6; }
        }

        // enemy behavior & collisions
        for (let i=this.enemies.length-1;i>=0;i--){
            const e = this.enemies[i];
            if (e.type === 'patrol'){
                e.x += e.dir * e.speed;
                if (e.x < e.x0) e.dir = 1;
                if (e.x > e.x1) e.dir = -1;
            } else if (e.type === 'jumper'){
                e.velY = (e.velY||0) + this.GRAVITY;
                e.y += e.velY;
                if (Date.now() - (e.last || 0) > e.delay){
                    e.velY = e.jumpF; e.last = Date.now();
                }
                // land on ground
                if (e.y + e.h > this.height - 60){
                    e.y = this.height - 60 - e.h; e.velY = 0;
                }
            } else if (e.type === 'shooter'){
                if (!e.lastShot) e.lastShot = 0;
                if (Date.now() - e.lastShot > e.fireRate){
                    e.lastShot = Date.now();
                    // spawn projectile toward player
                    const angle = Math.atan2((this.player.y + this.player.h/2) - (e.y + e.h/2), (this.player.x + this.player.w/2) - (e.x + e.w/2));
                    this.projectiles.push({x:e.x + e.w/2, y:e.y + e.h/2, vx:Math.cos(angle)*5, vy:Math.sin(angle)*5, w:8, h:8, color:'#E74C3C'});
                }
            } else if (e.type === 'flyer'){
                e.x += e.dir * e.speed;
                if (e.x < e.x0) e.dir = 1;
                if (e.x > e.x1) e.dir = -1;
                // slight bob
                e.y = (e.y0 || e.y) + Math.sin(Date.now()/400 + e.x)*6;
            }

            // collisions with player
            if (this.coll(this.player, {x:e.x,y:e.y,w:e.w,h:e.h}) && !this.player.invincible){
                // stomp?
                if (this.player.velY > 0 && this.player.y + this.player.h - 6 < e.y + e.h/2){
                    // stomp
                    this.score += 200; this.combo += 1;
                    e.health -= 60;
                    this.player.velY = -8;
                    this.spawnParticles(e.x+e.w/2,e.y+e.h/2,'#FFD700',12);
                    if (e.health <= 0) this.enemies.splice(i,1);
                } else {
                    // take damage
                    this.takeDamage(12);
                    // knockback
                    this.player.x += (this.player.x < e.x) ? -30 : 30;
                }
            }
        }

        // projectiles update
        for (let i=this.projectiles.length-1;i>=0;i--){
            const p = this.projectiles[i];
            p.x += p.vx; p.y += p.vy;
            // remove if off screen
            if (p.x < -50 || p.y < -50 || p.x > this.width + 200 || p.y > this.height + 200) this.projectiles.splice(i,1);
            else if (!this.player.invincible && this.coll(this.player,{x:p.x,y:p.y,w:p.w,h:p.h})){
                this.takeDamage(6); this.projectiles.splice(i,1); this.spawnParticles(p.x,p.y,'#E74C3C',8);
            }
        }

        // particles update
        for (let i=this.particles.length-1;i>=0;i--){
            const p = this.particles[i];
            p.x += p.vx; p.y += p.vy; p.vy += 0.12; p.life -= dt*0.06;
            if (p.life <= 0) this.particles.splice(i,1);
        }

        // portals and checkpoints
        for (let p of this.portals){
            if (this.coll(this.player, {x:p.x,y:p.y,w:p.w,h:p.h})){
                if (p.final){ this.isGameComplete = true; this.el.finalScoreVictory.textContent = this.score; this.el.victoryScreen.style.display = 'flex'; }
                else this.loadLevel(p.target);
            }
        }
        for (let cp of this.checkpoints){
            if (!cp.activated && this.coll(this.player,{x:cp.x,y:cp.y,w:cp.w,h:cp.h})){
                cp.activated = true; this.spawnParticles(cp.x + cp.w/2, cp.y + 8, '#27AE60', 18);
            }
        }

        // death by fall
        if (this.player.y > this.height + 300){
            this.takeDamage(20);
            if (this.health > 0){
                const spawn = this.checkpoints.find(c=>c.activated);
                if (spawn){ this.player.x = spawn.x; this.player.y = spawn.y - this.player.h - 2; }
                else { this.player.x = 60; this.player.y = this.height - 260; }
                this.player.velY = 0;
            }
        }

        // bound x
        if (this.player.x < 0) this.player.x = 0;
        // allow camera to smoothly follow
        this.updateCamera();
        this.updateUI();
    },

    updateCamera(){
        const tx = Math.max(0, this.player.x - this.width/3);
        const ty = Math.max(0, this.player.y - this.height/2);
        this.camera.x += (tx - this.camera.x) * 0.12;
        this.camera.y += (ty - this.camera.y) * 0.12;
    },

    render(){
        const ctx = this.ctx;
        ctx.clearRect(0,0,this.width,this.height);

        // subtle parallax sky
        ctx.fillStyle = 'rgba(255,255,255,0.02)';
        for (let i=0;i<40;i++){
            const sx = (i*53 + (this.camera.x*0.02)) % (this.width + 200) - 100;
            const sy = 30 + (i*27) % this.height;
            ctx.beginPath(); ctx.arc(sx, sy, (i%5)+0.6, 0, Math.PI*2); ctx.fill();
        }

        // draw platforms
        for (let p of this.platforms){
            const x = p.x - this.camera.x, y = p.y - this.camera.y;
            ctx.save();
            ctx.translate(x,y);
            ctx.fillStyle = p.color || '#4ECDC4';
            ctx.roundRect(0,0,p.w,p.h||p.height,6);
            ctx.fill();
            // decoration
            if (p.type === 'bouncy'){
                ctx.fillStyle = '#fff'; for (let i=0;i<p.w;i+=20){ ctx.beginPath(); ctx.arc(10+i,6,4,0,Math.PI*2); ctx.fill(); }
            }
            if (p.type === 'moving'){
                ctx.fillStyle = 'rgba(255,255,255,0.08)'; ctx.fillRect(0,0,p.w,2);
            }
            // shadow below
            ctx.fillStyle = 'rgba(0,0,0,0.12)'; ctx.beginPath(); ctx.ellipse(p.w/2, p.h+6, p.w/2, 6,0,0,Math.PI*2); ctx.fill();
            ctx.restore();
        }

        // draw collectibles
        for (let c of this.collectibles){
            const cx = c.x - this.camera.x, cy = c.y - this.camera.y;
            ctx.save();
            ctx.translate(cx + (c.w||18)/2, cy + (c.h||18)/2);
            ctx.rotate(c.rot||0);
            if (c.type === 'coin'){
                const r = (c.w||18)/2;
                const g = ctx.createRadialGradient(-r*0.3,-r*0.3,0,0,0,r);
                g.addColorStop(0,'#F1C40F'); g.addColorStop(1,'#D4AF37');
                ctx.fillStyle = g; ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.fill();
                ctx.strokeStyle = '#D4AF37'; ctx.lineWidth = 1; ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.stroke();
            } else {
                ctx.fillStyle = '#2ECC71';
                ctx.roundRect(-9,-9,18,18,4); ctx.fill();
                ctx.fillStyle = '#fff'; ctx.fillRect(-2,-9+4,4,10); ctx.fillRect(-9+4,-2,10,4);
            }
            ctx.restore();
        }

        // draw powerups
        for (let p of this.powerUps){
            const px = p.x - this.camera.x, py = p.y - this.camera.y;
            ctx.save(); ctx.translate(px + p.w/2, py + p.h/2); ctx.rotate(p.rot||0);
            const rad = ctx.createRadialGradient(0,0,0,0,0, p.w);
            rad.addColorStop(0,p.type==='speed'?'#3498DB':'#9B59B6'); rad.addColorStop(1,'rgba(155,89,182,0)');
            ctx.fillStyle = rad; ctx.beginPath(); ctx.arc(0,0,p.w,0,Math.PI*2); ctx.fill();
            ctx.fillStyle = '#fff'; ctx.font='12px Arial'; ctx.textAlign='center'; ctx.textBaseline='middle';
            ctx.fillText(p.type==='speed'?'‚ö°': p.type==='doubleJump'?'‚áß':'üî∞', 0,0);
            ctx.restore();
        }

        // draw enemies
        for (let e of this.enemies){
            const ex = e.x - this.camera.x, ey = e.y - this.camera.y;
            ctx.save(); ctx.translate(ex,ey);
            ctx.fillStyle = e.color || '#FF9F1C';
            ctx.roundRect(0,0,e.w,e.h,[8,8,4,4]); ctx.fill();
            ctx.fillStyle = '#fff';
            if (e.type === 'patrol'){
                ctx.beginPath(); ctx.arc(e.w/2 + (e.dir*4), e.h/3, 4,0,Math.PI*2); ctx.fill();
            } else if (e.type === 'jumper'){
                ctx.beginPath(); ctx.arc(e.w/3,e.h/3,3,0,Math.PI*2); ctx.arc(e.w*2/3,e.h/3,3,0,Math.PI*2); ctx.fill();
            } else if (e.type === 'shooter'){
                ctx.beginPath(); ctx.arc(e.w/2,e.h/3,6,0,Math.PI*2); ctx.fill();
            } else if (e.type === 'flyer'){
                ctx.fillStyle = 'rgba(255,255,255,0.9)'; ctx.beginPath(); ctx.ellipse(-5,e.h/2,10,5,0,0,Math.PI*2); ctx.ellipse(e.w+5,e.h/2,10,5,0,0,Math.PI*2); ctx.fill();
                ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(e.w/3,e.h/3,3,0,Math.PI*2); ctx.arc(e.w*2/3,e.h/3,3,0,Math.PI*2); ctx.fill();
            }
            // simple health bar
            ctx.fillStyle = 'rgba(0,0,0,0.25)'; ctx.fillRect(0,-6, e.w,4);
            const hpPct = Math.max(0,(e.health||100)/100);
            ctx.fillStyle = 'rgba(46,204,113,0.9)'; ctx.fillRect(0,-6, e.w*hpPct,4);
            ctx.restore();
        }

        // projectiles
        for (let p of this.projectiles){
            const px = p.x - this.camera.x, py = p.y - this.camera.y;
            ctx.save(); ctx.translate(px,py);
            const g = ctx.createRadialGradient(0,0,0,0,0,8); g.addColorStop(0,p.color); g.addColorStop(1,'rgba(231,76,60,0)');
            ctx.fillStyle = g; ctx.beginPath(); ctx.arc(0,0, p.w/2, 0, Math.PI*2); ctx.fill();
            ctx.restore();
        }

        // player
        const px = this.player.x - this.camera.x, py = this.player.y - this.camera.y;
        ctx.save(); ctx.translate(px,py);
        // invincibility flash
        if (this.player.invincible && Math.floor(Date.now()/80)%2===0) ctx.fillStyle = '#FF9999'; else ctx.fillStyle = this.player.color;
        ctx.roundRect(0,0,this.player.w,this.player.h,[8,8,6,6]); ctx.fill();
        // eyes & mouth
        ctx.fillStyle = '#fff';
        const eyeX = this.player.facing>0? this.player.w/3 : this.player.w*2/3;
        ctx.beginPath(); ctx.arc(eyeX, this.player.h/3, 4,0,Math.PI*2); ctx.fill();
        ctx.beginPath();
        if (this.keys.left || this.keys.right) ctx.arc(eyeX, this.player.h*2/3, 6, 0, Math.PI);
        else ctx.arc(eyeX, this.player.h*2/3, 6, 0, Math.PI, true);
        ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.stroke();
        // dash frame
        if (this.player.dashDuration>0){ ctx.strokeStyle = 'rgba(110,142,251,0.85)'; ctx.lineWidth=3; ctx.strokeRect(-2,-2,this.player.w+4,this.player.h+4); }
        // shadow
        ctx.fillStyle = 'rgba(0,0,0,0.18)'; ctx.beginPath(); ctx.ellipse(this.player.w/2,this.player.h+6,this.player.w/2,6,0,0,Math.PI*2); ctx.fill();
        ctx.restore();

        // checkpoints & portals
        for (let cp of this.checkpoints){
            const cx = cp.x - this.camera.x, cy = cp.y - this.camera.y;
            ctx.save(); ctx.translate(cx,cy);
            ctx.fillStyle = '#7F8C8D'; ctx.fillRect(cp.w/2 - 2,0,4,cp.h);
            ctx.fillStyle = cp.activated ? '#27AE60' : '#95A5A6';
            ctx.beginPath(); ctx.moveTo(cp.w/2,0); ctx.lineTo(cp.w/2, cp.h/3); ctx.lineTo(cp.w, cp.h/4); ctx.closePath(); ctx.fill();
            ctx.restore();
        }
        for (let port of this.portals){
            const ox = port.x - this.camera.x, oy = port.y - this.camera.y;
            ctx.save(); ctx.translate(ox + port.w/2, oy + port.h/2);
            const grad = ctx.createRadialGradient(0,0,0,0,0,port.w/1.2);
            grad.addColorStop(0, port.color || '#9B59B6'); grad.addColorStop(1, 'rgba(155,89,182,0)');
            ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(0,0,port.w/2,0,Math.PI*2); ctx.fill();
            ctx.restore();
        }

        // particles
        for (let p of this.particles){
            ctx.globalAlpha = Math.max(0, p.life/40);
            ctx.fillStyle = p.color === '--' ? '#F1C40F' : p.color;
            ctx.beginPath(); ctx.arc(p.x - this.camera.x, p.y - this.camera.y, p.size,0,Math.PI*2); ctx.fill();
            ctx.globalAlpha = 1;
        }
    },

    // actions
    handleJumpPress(){
        if (!this.gameStarted) { this.startGame(); return; }
        if (!this.player.jumping){
            this.player.velY = this.JUMP_FORCE;
            this.player.jumping = true;
            this.player.canDoubleJump = this.player.hasDoubleJump;
        } else if (this.player.canDoubleJump){
            this.player.velY = -10;
            this.player.canDoubleJump = false;
            this.player.hasDoubleJump = false; // consume
        }
    },

    handleShove(){
        if (this.player.shoveCooldown > 0) return;
        this.player.shoveCooldown = 400;
        // shove enemies within radius in front
        const r = 70;
        const dir = this.player.facing;
        for (let e of this.enemies){
            const dx = (e.x + e.w/2) - (this.player.x + this.player.w/2);
            const dy = (e.y + e.h/2) - (this.player.y + this.player.h/2);
            if (Math.abs(dy) < 60 && (dir>0 ? dx>0 && dx<r : dx<0 && Math.abs(dx)<r)){
                e.x += dir*40;
                e.health -= 30;
                if (e.health <= 0) this.enemies.splice(this.enemies.indexOf(e),1);
                this.spawnParticles(e.x + e.w/2, e.y + e.h/2, '#FF0000', 12);
            }
        }
        this.spawnParticles(this.player.x + this.player.w/2 + dir*20, this.player.y + this.player.h/2, '#FF5555', 10);
    },

    handleDash(){
        if (this.player.dashCooldown > 0) return;
        this.player.dashDuration = 300;
        this.player.dashCooldown = 1200;
    },

    activatePowerUp(type){
        this.powerUp = {type};
        switch(type){
            case 'doubleJump': this.player.hasDoubleJump = true; this.powerUpTimer = 10000; break;
            case 'speed': this.player.speed = 8; this.powerUpTimer = 8000; break;
            case 'invincibility': this.player.invincible = true; this.player.invTimer = 7000; this.powerUpTimer = 7000; break;
        }
    },

    deactivatePowerUp(){
        if (!this.powerUp) return;
        if (this.powerUp.type === 'speed') this.player.speed = 5;
        if (this.powerUp.type === 'invincibility') this.player.invincible = false;
        if (this.powerUp.type === 'doubleJump'){ /* double jump persists if collected permanently? we revert for demo */ this.player.hasDoubleJump = false; }
        this.powerUp = null; this.powerUpTimer = 0;
    },

    takeDamage(amount){
        if (this.powerUp && this.powerUp.type === 'invincibility'){
            amount = Math.floor(amount/2);
        }
        this.health -= amount;
        this.el.damageEffect.style.backgroundColor = 'rgba(231,76,60,0.25)';
        setTimeout(()=> this.el.damageEffect.style.backgroundColor='rgba(231,76,60,0)', 240);
        this.player.invincible = true; this.player.invTimer = 1000;
        this.combo = 0; this.el.comboDisplay.style.opacity = 0;
        if (this.health <= 0){
            this.health = 0; this.gameOver = true; this.el.finalScore.textContent = this.score; this.el.gameOverScreen.style.display = 'flex';
        }
        this.updateUI();
    },

    spawnParticles(x,y,color,n=8){
        for (let i=0;i<n;i++){
            this.particles.push({
                x:x, y:y, vx:(Math.random()-0.5)*4, vy:(Math.random()-1.5)*4, size:2+Math.random()*3, life:18+Math.random()*18, color: color === '--' ? '#F1C40F' : color
            });
        }
    }
};

window.addEventListener('load', ()=> game.init());
</script>
</body>
</html>
