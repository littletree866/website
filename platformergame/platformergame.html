<!DOCTYPE html>
<html>
<head>
<title>Platformer</title>
<style>
    body { 
        margin: 0; 
        overflow: hidden; 
        background: #222; 
        font-family: "Ink Free", cursive;
    }
    canvas { 
        background: #87CEEB; /* sky base for parallax */
        display: block; 
        margin: 0 auto; 
    }

    #ui {
        position: absolute;
        top: 15px;
        left: 15px;
        color: white;
        font-size: 24px;
        text-shadow: 2px 2px 5px rgba(0,0,0,0.8);
        font-family: "Ink Free", cursive;
    }

    #levelText { font-size: 28px; margin-bottom: 5px; }

    #healthBar {
        width: 220px;
        height: 22px;
        background: linear-gradient(90deg,#440000,#330000);
        border-radius: 12px;
        margin-top: 5px;
        box-shadow: inset 0 0 6px rgba(0,0,0,0.6);
    }

    #healthFill {
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg,#ff6b6b,#ff2f2f);
        border-radius: 12px;
        transition: width 0.2s linear;
    }

    #pauseBtn {
        position: absolute;
        top: 15px;
        right: 15px;
        background: #555;
        color: white;
        padding: 10px 15px;
        font-size: 22px;
        border: none;
        border-radius: 10px;
        cursor: pointer;
        font-family: "Ink Free", cursive;
        box-shadow: 0 4px 8px rgba(0,0,0,0.4);
    }

    .screen {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0,0,0,0.85);
        color: white;
        padding: 40px 70px;
        font-size: 40px;
        border-radius: 20px;
        text-align: center;
        display: none;
        font-family: "Ink Free", cursive;
    }

    .screen button {
        margin-top: 25px;
        padding: 10px 25px;
        font-size: 28px;
        border: none;
        border-radius: 10px;
        cursor: pointer;
        font-family: "Ink Free", cursive;
    }
</style>
</head>
<body>

<div id="ui">
    <div id="levelText">Level: 1</div>
    Score: <span id="scoreText">0</span>
    <div id="healthBar"><div id="healthFill"></div></div>
</div>

<button id="pauseBtn">Pause</button>

<div id="gameOverScreen" class="screen">
    Game Over<br><br>
    <button onclick="resetGame()">Try Again</button>
</div>

<div id="winScreen" class="screen">
    You Win!<br><br>
    <button onclick="resetGame()">Play Again</button>
</div>

<canvas id="game" width="900" height="500"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

const keys = { left: false, right: false, up: false };
let paused = false;
let score = 0;
let health = 100;
let level = 1;

const scoreText = document.getElementById("scoreText");
const healthFill = document.getElementById("healthFill");
const gameOverScreen = document.getElementById("gameOverScreen");
const winScreen = document.getElementById("winScreen");
const levelText = document.getElementById("levelText");

const world = { width: 2400, height: canvas.height };
let camera = { x: 0, width: canvas.width, smooth: 0.08 };

let player = { x:50, y:50, w:36, h:44, vx:0, vy:0, speed:4.2, jumping:false, onGround:false, coyote:0, canDoubleJump:false };
const gravity = 0.7;
const jumpForce = -13;
const COYOTE_TIME = 0.12;
let lastTime = performance.now();

let platforms = [];
let enemies = [];
let coins = [];
let powerUps = [];
let goal = null;

/* ---------------- LEVEL DATA ---------------- */
function loadLevel(n) {
    level = n;
    levelText.textContent = "Level: " + level;
    enemies = []; platforms = []; coins = []; powerUps = []; goal = null;

    function staticPlat(x,y,w,h){ return {x,y,w,h,type:'static'}; }
    function movingPlat(x,y,w,h,minX,maxX,speed){ return {x,y,w,h,type:'moving',vx:speed,minX,maxX}; }
    function fallPlat(x,y,w,h,delay){ return {x,y,w,h,type:'fall',fallDelay:delay,falling:false}; }
    function spike(x,y,w,h){ return {x,y,w,h,type:'spike'}; }
    function lava(x,y,w,h){ return {x,y,w,h,type:'lava'}; }
    
    function makeEnemy(x, y, minX, maxX, speed=1.2){ return {x,y,w:36,h:36,vx:speed,minX,maxX}; }
    function makeCoin(x,y){ return {x,y,w:16,h:16,collected:false}; }
    function makePowerUp(x,y){ return {x,y,w:20,h:20,type:'doubleJump',collected:false}; }

    if(level===1){
        world.width=1600;
        platforms = [
            staticPlat(0,460,world.width,40),
            staticPlat(180,380,160,20),
            movingPlat(420,330,140,20,380,580,1.2),
            fallPlat(700,300,120,20,600),
            staticPlat(920,260,180,20),
            staticPlat(1250,340,200,20),
            spike(560,456,80,8)
        ];
        enemies.push(makeEnemy(220,348,180,320,1.2));
        enemies.push(makeEnemy(980,238,920,1100,1));
        goal = {x:1450,y:300,w:44,h:64,anim:0};
        coins.push(makeCoin(300,340), makeCoin(700,260));
        powerUps.push(makePowerUp(1250,300));
    }

    if(level===2){
        world.width=2000;
        platforms = [
            staticPlat(0,460,world.width,40),
            staticPlat(160,400,140,20),
            movingPlat(360,340,160,20,320,620,1.5),
            fallPlat(620,290,130,20,450),
            staticPlat(900,240,140,20),
            movingPlat(1140,320,160,20,1060,1320,1),
            staticPlat(1500,300,260,20),
            spike(820,456,120,8),
            lava(200,476,120,24)
        ];
        enemies.push(makeEnemy(380,318,360,520,1.3));
        enemies.push(makeEnemy(1180,298,1140,1320,0.9));
        goal = {x:1840,y:240,w:44,h:64,anim:0};
        coins.push(makeCoin(400,300), makeCoin(1100,280));
        powerUps.push(makePowerUp(1500,270));
    }

    if(level===3){
        world.width=2400;
        platforms = [
            staticPlat(0,460,world.width,40),
            staticPlat(240,400,160,20),
            movingPlat(480,340,160,20,420,700,1.6),
            fallPlat(760,300,140,20,400),
            movingPlat(980,260,120,20,940,1150,1.8),
            staticPlat(1260,200,160,20),
            movingPlat(1500,320,180,20,1420,1680,1.2),
            staticPlat(1820,280,200,20),
            staticPlat(2080,220,220,20),
            spike(1380,456,100,8),
            lava(1700,476,240,24)
        ];
        enemies.push(makeEnemy(520,318,480,700,1.4));
        enemies.push(makeEnemy(1000,238,980,1150,1.1));
        enemies.push(makeEnemy(1580,298,1500,1680,1.3));
        goal = {x:2260,y:160,w:44,h:64,anim:0};
        coins.push(makeCoin(500,260), makeCoin(1580,280), makeCoin(2080,180));
        powerUps.push(makePowerUp(1820,250));
    }

    resetPlayer();
}

document.addEventListener("keydown", e => {
    if(e.key==="ArrowLeft"||e.key==="a") keys.left=true;
    if(e.key==="ArrowRight"||e.key==="d") keys.right=true;
    if(e.key==="ArrowUp"||e.key==="w"||e.key===" ") keys.up=true;
});
document.addEventListener("keyup", e => {
    if(e.key==="ArrowLeft"||e.key==="a") keys.left=false;
    if(e.key==="ArrowRight"||e.key==="d") keys.right=false;
    if(e.key==="ArrowUp"||e.key==="w"||e.key===" ") keys.up=false;
});

document.getElementById("pauseBtn").onclick = ()=>{
    paused = !paused;
    document.getElementById("pauseBtn").textContent = paused?"Resume":"Pause";
};

function rectCollision(a,b){
    return a.x<b.x+b.w && a.x+a.w>b.x && a.y<b.y+b.h && a.y+a.h>b.y;
}

function damage(amount){
    health-=amount;
    if(health<0) health=0;
    healthFill.style.width = Math.max(0,health)+"%";
    if(health<=0){
        gameOverScreen.style.display="block";
        paused=true;
    }
}

function resetPlayer(){
    player.x=50; player.y=50; player.vx=0; player.vy=0;
    player.jumping=false; player.onGround=false; player.coyote=0; player.canDoubleJump=false;
    camera.x=0;
}

function resetGame(){
    paused=false;
    gameOverScreen.style.display="none";
    winScreen.style.display="none";
    score=0; health=100; healthFill.style.width="100%";
    loadLevel(1);
}

/* ---------------- UPDATE ---------------- */
function update(dt){
    if(paused) return;
    scoreText.textContent=score;
    
    player.vx=0;
    if(keys.left) player.vx=-player.speed;
    if(keys.right) player.vx=player.speed;

    if(player.onGround) player.coyote=COYOTE_TIME;
    else player.coyote-=dt;

    if(keys.up && (player.onGround || player.coyote>0 || (player.canDoubleJump && !player.jumping))){
        player.vy=jumpForce;
        if(!player.onGround) player.canDoubleJump=false;
        player.jumping=true;
        player.onGround=false;
        player.coyote=0;
    }

    player.vy+=gravity;
    player.x+=player.vx;
    player.y+=player.vy;

    if(player.x<0) player.x=0;
    if(player.x+player.w>world.width) player.x=world.width-player.w;

    let onGround=false;
    for(let p of platforms){
        if(p.type==='fall' && p.falling) continue;
        if(p.type==='spike'||p.type==='lava') continue;

        if(rectCollision(player,p)){
            if(player.vy>0 && (player.y+player.h)-player.vy <= p.y+6){
                player.y=p.y-player.h;
                player.vy=0; player.jumping=false;
                onGround=true;
                if(p.type==='fall' && !p.falling){ setTimeout(()=>{p.falling=true;}, p.fallDelay||500); }
            } else {
                if(player.x+player.w>p.x && player.x<p.x) player.x=p.x-player.w;
                else if(player.x<p.x+p.w && player.x+player.w>p.x+p.w) player.x=p.x+p.w;
            }
        }
    }
    player.onGround=onGround;

    for(let e of enemies){
        e.x+=e.vx;
        if(e.x<e.minX) e.vx=Math.abs(e.vx);
        if(e.x>e.maxX) e.vx=-Math.abs(e.vx);

        if(rectCollision(player,e)){
            if(player.vy>0 && player.y+player.h<e.y+20){
                enemies.splice(enemies.indexOf(e),1);
                score+=200;
                player.vy=-9;
                continue;
            }
            damage(20);
            player.vx=e.vx>0?-4:4;
        }
    }

    for(let h of platforms){
        if(h.type==='spike'||h.type==='lava'){
            if(rectCollision(player,h)){
                if(h.type==='spike') damage(40);
                if(h.type==='lava') damage(999);
            }
        }
        if(h.type==='moving') { h.x+=h.vx; if(h.x<h.minX) h.vx=Math.abs(h.vx); if(h.x+h.w>h.maxX) h.vx=-Math.abs(h.vx); }
        if(h.type==='fall' && h.falling){ h.vy+=gravity; h.y+=h.vy; }
    }

    // collect coins & power-ups
    for(let c of coins) if(!c.collected && rectCollision(player,c)) { c.collected=true; score+=50; }
    for(let p of powerUps) if(!p.collected && rectCollision(player,p)) { p.collected=true; if(p.type==='doubleJump') player.canDoubleJump=true; }

    if(goal && rectCollision(player,goal)){
        if(level<3) loadLevel(level+1);
        else { winScreen.style.display="block"; paused=true; }
    }

    if(player.y>canvas.height+600) damage(200);

    let targetX = player.x+player.w/2-canvas.width/2;
    camera.x += (targetX - camera.x)*camera.smooth;
    camera.x=Math.max(0,Math.min(camera.x, world.width-canvas.width));
}

/* ---------------- DRAW ---------------- */
function drawParallax(){
    ctx.fillStyle="#3C6E71"; let mx=camera.x*0.2;
    ctx.beginPath(); ctx.moveTo(-100-mx,380);
    for(let i=-100;i<canvas.width+200;i+=220){ let peak=320+40*Math.sin((i+mx)*0.008); ctx.lineTo(i+60-mx*0.05,peak); ctx.lineTo(i+140-mx*0.02,380); }
    ctx.lineTo(canvas.width,500); ctx.lineTo(0,500); ctx.fill();

    ctx.fillStyle="#67B26F"; let hx=camera.x*0.45; ctx.beginPath(); ctx.moveTo(0,430);
    for(let i=-200;i<canvas.width+200;i+=150){ let peak=380+26*Math.sin((i+hx)*0.012); ctx.quadraticCurveTo(i-hx*0.04+70,peak,i+140-hx*0.02,430); }
    ctx.fill();

    ctx.fillStyle="#2E8B57"; ctx.fillRect(0,460,canvas.width,40);
}

function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawParallax();

    for(let p of platforms){
        let sx=p.x-camera.x;
        if(p.type==='spike'){
            ctx.fillStyle="#222"; ctx.fillRect(sx,p.y,p.w,p.h); ctx.fillStyle="#ffdd55";
            for(let s=0;s<p.w;s+=12){ ctx.beginPath(); ctx.moveTo(sx+s,p.y+p.h); ctx.lineTo(sx+s+6,p.y); ctx.lineTo(sx+s+12,p.y+p.h); ctx.fill(); }
            continue;
        }
        if(p.type==='lava'){
            ctx.fillStyle="#b22222"; ctx.fillRect(sx,p.y,p.w,p.h); ctx.fillStyle="#ff6a00";
            for(let f=0;f<p.w;f+=14){ let h=6+6*Math.sin((f+performance.now()*0.01)/40); ctx.beginPath(); ctx.ellipse(sx+f+6,p.y+6,8,h,0,0,Math.PI*2); ctx.fill(); }
            continue;
        }
        if(p.type==='moving') ctx.fillStyle="#7FB069";
        else if(p.type==='fall') ctx.fillStyle=p.falling?"#A0522D":"#9DC183";
        else ctx.fillStyle="#4ECC88";
        ctx.fillRect(sx,p.y,p.w,p.h);
    }

    for(let e of enemies){
        ctx.fillStyle="#d9534f"; ctx.fillRect(e.x-camera.x,e.y,e.w,e.h);
        ctx.fillStyle="#fff"; ctx.fillRect(e.x+6-camera.x,e.y+8,6,6); ctx.fillRect(e.x+20-camera.x,e.y+8,6,6);
    }

    // draw coins
    for(let c of coins) if(!c.collected){ ctx.fillStyle="#ffdd00"; ctx.beginPath(); ctx.arc(c.x+8-camera.x,c.y+8,8,0,Math.PI*2); ctx.fill(); }

    // draw power-ups
    for(let p of powerUps) if(!p.collected){ ctx.fillStyle="#00ffff"; ctx.fillRect(p.x-camera.x,p.y,p.w,p.h); ctx.strokeStyle="#000"; ctx.strokeRect(p.x-camera.x,p.y,p.w,p.h); }

    // draw goal
    if(goal){
        let gx=goal.x-camera.x, gy=goal.y;
        ctx.fillStyle="#6a4c32"; ctx.fillRect(gx+10,gy,6,goal.h);
        goal.anim=(goal.anim||0)+0.08; let sway=Math.sin(goal.anim)*8;
        ctx.fillStyle="#FFD700"; ctx.beginPath(); ctx.moveTo(gx+16,gy+8); ctx.quadraticCurveTo(gx+40+sway,gy+14,gx+16,gy+28); ctx.closePath(); ctx.fill();
        ctx.fillStyle="#333"; ctx.fillRect(gx,gy+goal.h,60,8);
    }

    // draw player
    let vy=player.vy, scaleY=player.onGround?1.08:Math.max(0.85,1-vy*0.015);
    let drawW=player.w, drawH=player.h*scaleY, drawX=player.x-camera.x, drawY=player.y+(player.h-drawH);
    ctx.fillStyle="#fff"; ctx.fillRect(drawX,drawY,drawW,drawH); ctx.strokeStyle="#111"; ctx.lineWidth=2; ctx.strokeRect(drawX,drawY,drawW,drawH);
}

/* ---------------- GAME LOOP ---------------- */
function loop(now){
    let dt=(now-lastTime)/1000; lastTime=now;
    update(dt); draw();
    requestAnimationFrame(loop);
}

loadLevel(1);
loop(performance.now());
</script>
</body>
</html>
