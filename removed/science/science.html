<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Neon Particle Storm</title>
<link rel="icon" href="../../icon.jpg" type="image/x-icon">
<link href="https://fonts.googleapis.com/css2?family=Jura:wght@500&display=swap" rel="stylesheet">
<style>
  body {
    margin: 0;
    overflow: hidden;
    background: radial-gradient(circle at 50% 50%, #0a0a0f, #1f1c34, #2c2a5e);
    font-family: 'Jura', sans-serif;
    color: white;
  }
  canvas {
    display: block;
  }
  #ui {
    position: absolute;
    top: 10px;
    left: 10px;
    font-size: 18px;
    text-shadow: 0 0 8px #0ff;
    pointer-events: none;
  }
  #waveInfo {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 48px;
    color: #FF6;
    text-shadow: 0 0 20px #FF6, 0 0 30px #FF6;
    white-space: pre;
    opacity: 0;
    transition: opacity 0.3s;
    pointer-events: none;
    z-index: 100;
  }
  #gameOver {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 48px;
    color: #FF3366;
    text-shadow: 0 0 20px #FF3366;
    text-align: center;
    opacity: 0;
    pointer-events: none;
  }
  #restartBtn {
    position: absolute;
    top: 60%;
    left: 50%;
    transform: translateX(-50%);
    padding: 12px 24px;
    font-family: 'Jura', sans-serif;
    font-size: 20px;
    background: linear-gradient(45deg, #FF3366, #FF6);
    border: none;
    color: white;
    cursor: pointer;
    border-radius: 8px;
    display: none;
  }
  #waveProgress {
    position: absolute;
    top: 60px;
    left: 10px;
    width: 200px;
    height: 10px;
    background: rgba(255,255,255,0.1);
    border-radius: 5px;
    overflow: hidden;
  }
  #waveProgressFill {
    width: 0%;
    height: 100%;
    background: linear-gradient(90deg, #00FFFF, #FF3366);
    transition: width 0.3s;
  }
</style>
</head>
<body>
<div id="ui">
  <div>Score: <span id="score">0</span></div>
  <div>Wave: <span id="wave">1</span></div>
  <div>Multiplier: <span id="multiplier">1x</span></div>
  <div>Lives: <span id="lives">3</span> ❤️</div>
  <div>High Score: <span id="highScore">0</span></div>
</div>
<div id="waveProgress">
  <div id="waveProgressFill"></div>
</div>
<div id="waveInfo"></div>
<div id="gameOver">GAME OVER</div>
<button id="restartBtn">PLAY AGAIN</button>
<canvas id="gameCanvas"></canvas>
<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// Game state
let score = 0;
let highScore = localStorage.getItem('neonParticleHighScore') || 0;
let wave = 1;
let multiplier = 1;
let lives = 5; // More lives for more action
let gameOver = false;
let shake = 0;
let streak = 0;
let lastCollectTime = 0;
let enemySpawnTimer = 0;

// Wave system - MUCH FASTER and MORE ENEMIES
let waveActive = true;
let enemiesDefeated = 0;
let enemiesRequired = 0;
let waveStartTime = 0;
let spawnRate = 100; // Lower = faster spawns

// Particle system for effects
let particles = [];

// Player
const player = {
  x: canvas.width / 2,
  y: canvas.height - 100,
  radius: 18,
  color: '#39FF14',
  dx: 0,
  speed: 12, // Faster movement
  trail: [],
  maxTrail: 15,
  invincible: false,
  lastDash: 0,
  dashCooldown: 1000
};

// Enemy types with more variety
const enemyTypes = {
  normal: { color: '#FF3366', speed: 4, health: 1, score: 10, radius: 20 },
  fast: { color: '#FF9900', speed: 8, health: 1, score: 15, radius: 15 },
  tank: { color: '#6600FF', speed: 2, health: 3, score: 25, radius: 30 },
  splitter: { color: '#00FFFF', speed: 3, health: 1, score: 20, radius: 18 },
  homing: { color: '#FF00FF', speed: 3, health: 2, score: 30, radius: 16 },
  kamikaze: { color: '#FF0000', speed: 6, health: 1, score: 40, radius: 14 }
};

let enemies = [];

// Spawn enemies based on wave
function spawnEnemy() {
  const waveModifier = Math.min(1 + (wave - 1) * 0.3, 5); // Scales up to 5x
  
  // Determine which enemy types can spawn based on wave
  let availableTypes = ['normal'];
  if (wave >= 2) availableTypes.push('fast');
  if (wave >= 3) availableTypes.push('tank');
  if (wave >= 4) availableTypes.push('splitter');
  if (wave >= 5) availableTypes.push('homing');
  if (wave >= 6) availableTypes.push('kamikaze');
  
  const type = availableTypes[Math.floor(Math.random() * availableTypes.length)];
  const base = enemyTypes[type];
  
  // Randomize spawn position
  const side = Math.random();
  let x, y;
  
  if (side < 0.25) { // Top
    x = Math.random() * canvas.width;
    y = -base.radius;
  } else if (side < 0.5) { // Right
    x = canvas.width + base.radius;
    y = Math.random() * canvas.height * 0.8;
  } else if (side < 0.75) { // Left
    x = -base.radius;
    y = Math.random() * canvas.height * 0.8;
  } else { // Top with offset
    x = Math.random() * canvas.width;
    y = -base.radius - 100;
  }
  
  const enemy = {
    x, y,
    radius: base.radius,
    color: base.color,
    speed: base.speed * waveModifier * (Math.random() * 0.3 + 0.85),
    health: base.health,
    maxHealth: base.health,
    type: type,
    angle: type === 'splitter' ? Math.random() * Math.PI * 2 : 0,
    targetX: player.x,
    targetY: player.y,
    scoreValue: Math.floor(base.score * waveModifier),
    spawnTime: Date.now()
  };
  
  enemies.push(enemy);
}

// Power-ups
let powerUps = [];
const powerUpTypes = {
  shield: { color: '#00FFFF', duration: 8000 },
  scoreBoost: { color: '#FFD700', duration: 15000 },
  slowTime: { color: '#9D00FF', duration: 5000 },
  extraLife: { color: '#00FF00', duration: 0 },
  rapidFire: { color: '#FF3366', duration: 10000 }
};

function spawnPowerUp(x, y) {
  const types = Object.keys(powerUpTypes);
  const type = types[Math.floor(Math.random() * types.length)];
  const size = 16;
  
  powerUps.push({
    x: x || Math.random() * (canvas.width - size * 2) + size,
    y: y || -size,
    radius: size,
    color: powerUpTypes[type].color,
    speed: 4,
    type: type,
    rotation: 0
  });
}

// Input
const keys = {};
document.addEventListener('keydown', e => {
  keys[e.key] = true;
  
  // Dash with spacebar
  if(e.key === ' ' && Date.now() - player.lastDash > player.dashCooldown) {
    player.dx *= 3;
    player.lastDash = Date.now();
    createExplosion(player.x, player.y, '#FFFFFF', 30);
    setTimeout(() => {
      if (player.dx > 0) player.dx = player.speed;
      else if (player.dx < 0) player.dx = -player.speed;
    }, 150);
  }
});
document.addEventListener('keyup', e => keys[e.key] = false);

// Touch controls
let touchX = null;
canvas.addEventListener('touchstart', e => {
  touchX = e.touches[0].clientX;
  e.preventDefault();
});
canvas.addEventListener('touchmove', e => {
  if(touchX !== null) {
    const delta = e.touches[0].clientX - touchX;
    player.dx = Math.sign(delta) * player.speed * Math.min(Math.abs(delta) / 50, 1);
    touchX = e.touches[0].clientX;
  }
  e.preventDefault();
});
canvas.addEventListener('touchend', () => {
  touchX = null;
  player.dx = 0;
});

// Initialize first wave
function initWave() {
  waveActive = true;
  enemiesDefeated = 0;
  
  // MUCH MORE ENEMIES per wave
  enemiesRequired = Math.floor(10 + wave * 8); // Wave 1: 18 enemies, Wave 5: 50 enemies
  spawnRate = Math.max(200 - wave * 15, 30); // Faster spawns as waves progress
  
  document.getElementById('wave').textContent = wave;
  document.getElementById('waveProgressFill').style.width = '0%';
  
  // Show wave info
  showWaveInfo(`WAVE ${wave}`);
  
  // Spawn initial burst of enemies
  const initialSpawn = Math.min(5 + wave, 15);
  for (let i = 0; i < initialSpawn; i++) {
    setTimeout(() => spawnEnemy(), i * 100);
  }
}

// Wave progress
function updateWaveProgress() {
  const progress = (enemiesDefeated / enemiesRequired) * 100;
  document.getElementById('waveProgressFill').style.width = progress + '%';
}

// Effects
function createExplosion(x, y, color, count = 30) {
  for(let i = 0; i < count; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = Math.random() * 8 + 2;
    particles.push({
      x, y,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      radius: Math.random() * 5 + 3,
      color: color,
      life: 1
    });
  }
}

function updateParticles() {
  for(let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.life -= 0.02;
    p.radius *= 0.98;
    
    if(p.life <= 0) {
      particles.splice(i, 1);
    } else {
      ctx.globalAlpha = p.life;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
      ctx.fillStyle = p.color;
      ctx.fill();
      ctx.globalAlpha = 1;
    }
  }
}

// UI
document.getElementById('highScore').textContent = highScore;

function updateUI() {
  document.getElementById('score').textContent = Math.floor(score);
  document.getElementById('multiplier').textContent = multiplier.toFixed(1) + 'x';
  document.getElementById('lives').textContent = lives;
}

// Wave info display
function showWaveInfo(text) {
  const waveDiv = document.getElementById('waveInfo');
  waveDiv.textContent = text;
  waveDiv.style.opacity = 1;
  
  setTimeout(() => {
    waveDiv.style.opacity = 0;
  }, 800);
}

// Power-up activation
let activePowerUps = {};
function activatePowerUp(type) {
  activePowerUps[type] = Date.now();
  
  switch(type) {
    case 'shield':
      player.invincible = true;
      player.color = '#00FFFF';
      break;
    case 'scoreBoost':
      multiplier *= 2;
      break;
    case 'slowTime':
      enemies.forEach(e => e.speed *= 0.3);
      break;
    case 'extraLife':
      lives = Math.min(lives + 1, 10);
      break;
    case 'rapidFire':
      // Visual effect only - makes player glow
      player.color = '#FF3366';
      break;
  }
  
  createExplosion(player.x, player.y, powerUpTypes[type].color, 40);
}

// Check power-up expiration
function updatePowerUps() {
  const now = Date.now();
  for(const type in activePowerUps) {
    const duration = powerUpTypes[type].duration;
    if(duration > 0 && now - activePowerUps[type] > duration) {
      delete activePowerUps[type];
      
      switch(type) {
        case 'shield':
          player.invincible = false;
          player.color = '#39FF14';
          break;
        case 'scoreBoost':
          multiplier /= 2;
          break;
        case 'slowTime':
          enemies.forEach(e => e.speed /= 0.3);
          break;
        case 'rapidFire':
          player.color = '#39FF14';
          break;
      }
    }
  }
}

// Collision
function checkCollision(a, b) {
  const dx = a.x - b.x;
  const dy = a.y - b.y;
  return Math.sqrt(dx*dx + dy*dy) < a.radius + b.radius;
}

// Game over
function endGame() {
  gameOver = true;
  shake = 25;
  
  if(score > highScore) {
    highScore = Math.floor(score);
    localStorage.setItem('neonParticleHighScore', highScore);
  }
  
  const gameOverDiv = document.getElementById('gameOver');
  const restartBtn = document.getElementById('restartBtn');
  
  setTimeout(() => {
    gameOverDiv.style.opacity = 1;
    restartBtn.style.display = 'block';
  }, 500);
  
  for(let i = 0; i < 300; i++) {
    createExplosion(player.x, player.y, '#FF3366');
  }
}

// Restart
document.getElementById('restartBtn').addEventListener('click', () => {
  score = 0;
  wave = 1;
  lives = 5;
  multiplier = 1;
  gameOver = false;
  shake = 0;
  streak = 0;
  
  enemies = [];
  powerUps = [];
  particles = [];
  activePowerUps = {};
  
  player.x = canvas.width / 2;
  player.y = canvas.height - 100;
  player.color = '#39FF14';
  player.invincible = false;
  
  document.getElementById('gameOver').style.opacity = 0;
  document.getElementById('restartBtn').style.display = 'none';
  
  updateUI();
  initWave();
  update();
});

// Main game loop
function update(timestamp) {
  if(gameOver) return;
  
  // Clear with fade effect
  ctx.fillStyle = 'rgba(10,10,15,0.08)';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // Animated background
  const time = timestamp * 0.001;
  for(let i = 0; i < 150; i++) {
    const x = (Math.sin(time * 0.5 + i * 0.1) * 100 + i * 20) % canvas.width;
    const y = (Math.cos(time * 0.3 + i * 0.05) * 50 + i * 15) % canvas.height;
    const size = 1 + Math.sin(time + i) * 0.5;
    ctx.fillStyle = `rgba(100, 150, 255, ${0.3 + Math.sin(time + i) * 0.2})`;
    ctx.fillRect(x, y, size, size);
  }
  
  // Spawn enemies continuously
  enemySpawnTimer++;
  if(waveActive && enemies.length < 50 && enemySpawnTimer > spawnRate) {
    spawnEnemy();
    enemySpawnTimer = 0;
  }
  
  // Update player
  if(keys['ArrowLeft'] || keys['a']) player.dx = -player.speed;
  else if(keys['ArrowRight'] || keys['d']) player.dx = player.speed;
  else if(!touchX) player.dx = 0;
  
  player.x += player.dx;
  player.x = Math.max(player.radius, Math.min(canvas.width - player.radius, player.x));
  
  // Player trail
  player.trail.unshift({x: player.x, y: player.y});
  if(player.trail.length > player.maxTrail) player.trail.pop();
  
  // Draw player with shake
  const shakeX = shake ? (Math.random()*shake - shake/2) : 0;
  const shakeY = shake ? (Math.random()*shake - shake/2) : 0;
  ctx.save();
  ctx.translate(shakeX, shakeY);
  
  // Draw trail
  player.trail.forEach((pos, i) => {
    const alpha = (player.trail.length - i) / player.trail.length * 0.4;
    ctx.globalAlpha = alpha;
    ctx.beginPath();
    ctx.arc(pos.x, pos.y, player.radius * 0.7, 0, Math.PI*2);
    ctx.fillStyle = player.color;
    ctx.fill();
  });
  
  // Draw player
  ctx.globalAlpha = 1;
  ctx.shadowBlur = 40;
  ctx.shadowColor = player.color;
  ctx.beginPath();
  ctx.arc(player.x, player.y, player.radius, 0, Math.PI*2);
  ctx.fillStyle = player.color;
  ctx.fill();
  
  // Dash cooldown indicator
  if(Date.now() - player.lastDash < player.dashCooldown) {
    const dashProgress = (Date.now() - player.lastDash) / player.dashCooldown;
    ctx.beginPath();
    ctx.arc(player.x, player.y, player.radius + 5, -Math.PI/2, -Math.PI/2 + dashProgress * Math.PI * 2);
    ctx.strokeStyle = '#FFFFFF';
    ctx.lineWidth = 3;
    ctx.stroke();
  }
  ctx.restore();
  
  // Update enemies
  for(let i = enemies.length - 1; i >= 0; i--) {
    const e = enemies[i];
    
    // Enemy behavior
    switch(e.type) {
      case 'homing':
        const dx = player.x - e.x;
        const dy = player.y - e.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if(dist > 0) {
          e.x += (dx/dist) * e.speed;
          e.y += (dy/dist) * e.speed;
        }
        break;
      case 'splitter':
        e.x += Math.cos(e.angle) * e.speed;
        e.y += Math.sin(e.angle) * e.speed;
        break;
      case 'kamikaze':
        const kdx = player.x - e.x;
        const kdy = player.y - e.y;
        const kdist = Math.sqrt(kdx*kdx + kdy*kdy);
        if(kdist > 0) {
          e.x += (kdx/kdist) * e.speed * 1.5;
          e.y += (kdy/kdist) * e.speed * 1.5;
        }
        break;
      default:
        e.y += e.speed;
    }
    
    // Wrap around screen
    if(e.x < -e.radius) e.x = canvas.width + e.radius;
    if(e.x > canvas.width + e.radius) e.x = -e.radius;
    
    // Draw enemy
    ctx.save();
    ctx.shadowBlur = 25;
    ctx.shadowColor = e.color;
    ctx.fillStyle = e.color;
    
    // Different shapes
    if(e.type === 'tank') {
      // Tank has armor plates
      ctx.beginPath();
      ctx.arc(e.x, e.y, e.radius, 0, Math.PI*2);
      ctx.fill();
      
      // Health bar
      const healthPercent = e.health / e.maxHealth;
      ctx.fillStyle = '#00FF00';
      ctx.fillRect(e.x - e.radius, e.y - e.radius - 8, e.radius * 2 * healthPercent, 4);
    } else {
      ctx.beginPath();
      ctx.arc(e.x, e.y, e.radius, 0, Math.PI*2);
      ctx.fill();
    }
    
    // Homing indicator
    if(e.type === 'homing' || e.type === 'kamikaze') {
      ctx.strokeStyle = e.color;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(e.x, e.y);
      ctx.lineTo(player.x, player.y);
      ctx.stroke();
    }
    ctx.restore();
    
    // Collision with player
    if(checkCollision(player, e)) {
      if(!player.invincible) {
        e.health--;
        
        if(e.health <= 0) {
          createExplosion(e.x, e.y, e.color, 40);
          
          // Splitter splits
          if(e.type === 'splitter') {
            for(let j = 0; j < 3; j++) {
              setTimeout(() => {
                const smallEnemy = {...e};
                smallEnemy.radius = e.radius * 0.6;
                smallEnemy.speed = e.speed * 1.5;
                smallEnemy.angle = Math.random() * Math.PI * 2;
                smallEnemy.scoreValue = Math.floor(e.scoreValue * 0.5);
                enemies.push(smallEnemy);
              }, j * 100);
            }
          }
          
          enemies.splice(i, 1);
          enemiesDefeated++;
          score += Math.floor(e.scoreValue * multiplier);
          streak++;
          
          // Chance to drop power-up (20%)
          if(Math.random() < 0.2) {
            spawnPowerUp(e.x, e.y);
          }
        } else {
          // Hit but not destroyed
          shake = 8;
        }
        
        if(!player.invincible) {
          lives--;
          shake = 20;
          streak = 0;
          
          if(lives <= 0) {
            endGame();
          }
        }
      }
    }
    
    // Remove if off screen bottom
    if(e.y - e.radius > canvas.height + 100) {
      enemies.splice(i, 1);
      streak = 0; // Reset streak if missed
    }
  }
  
  // Update power-ups
  for(let i = powerUps.length - 1; i >= 0; i--) {
    const p = powerUps[i];
    p.y += p.speed;
    p.rotation += 0.08;
    
    // Draw power-up
    ctx.save();
    ctx.translate(p.x, p.y);
    ctx.rotate(p.rotation);
    ctx.shadowBlur = 30;
    ctx.shadowColor = p.color;
    ctx.fillStyle = p.color;
    
    // Draw shape based on type
    ctx.beginPath();
    if(p.type === 'shield') {
      // Hexagon
      for(let j = 0; j < 6; j++) {
        const angle = (Math.PI/3) * j;
        const x = Math.cos(angle) * p.radius;
        const y = Math.sin(angle) * p.radius;
        if(j === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
    } else if(p.type === 'scoreBoost') {
      // Star
      for(let j = 0; j < 5; j++) {
        const angle = (Math.PI*2/5) * j - Math.PI/2;
        const x = Math.cos(angle) * p.radius;
        const y = Math.sin(angle) * p.radius;
        if(j === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
        const innerAngle = angle + Math.PI/5;
        const innerX = Math.cos(innerAngle) * p.radius * 0.5;
        const innerY = Math.sin(innerAngle) * p.radius * 0.5;
        ctx.lineTo(innerX, innerY);
      }
    } else {
      // Circle
      ctx.arc(0, 0, p.radius, 0, Math.PI*2);
    }
    ctx.closePath();
    ctx.fill();
    ctx.restore();
    
    // Collision with player
    if(checkCollision(player, p)) {
      activatePowerUp(p.type);
      powerUps.splice(i, 1);
      score += Math.floor(50 * multiplier);
      shake = 10;
      setTimeout(() => shake = Math.max(shake - 5, 0), 100);
    }
    
    // Remove if off screen
    if(p.y - p.radius > canvas.height) {
      powerUps.splice(i, 1);
    }
  }
  
  // Update particles
  updateParticles();
  updatePowerUps();
  updateWaveProgress();
  
  // Reduce shake
  if(shake > 0) shake *= 0.88;
  
  // Reset streak if too slow
  if(Date.now() - lastCollectTime > 1500) {
    streak = 0;
  }
  
  // Streak bonus
  if(streak >= 15) {
    multiplier = Math.min(multiplier + 0.1, 5);
    createExplosion(player.x, player.y - 50, '#FFFFFF', 20);
    streak = 0;
  }
  
  // Next wave
  if(waveActive && enemiesDefeated >= enemiesRequired) {
    waveActive = false;
<<<<<<< HEAD
    wave++; 
=======
    wave++;
>>>>>>> ef2b66adec447d5c0c04f1770677c19698a1950d
    
    // Bonus for clearing wave
    const waveBonus = Math.floor(1000 * wave * multiplier);
    score += waveBonus;
    
    // Show bonus message
    showWaveInfo(`+${waveBonus} BONUS!`);
    
    // Next wave after delay
    setTimeout(() => {
      initWave();
    }, 1500);
  }
  
  updateUI();
  requestAnimationFrame(update);
}

// Initialize
initWave();
update();

// Handle window resize
window.addEventListener('resize', () => {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  player.x = Math.min(player.x, canvas.width - player.radius);
});
</script>
</body>
</html>