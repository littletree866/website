<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>January Challenge</title>
  <link rel="icon" href="../../icon.jpg" type="image/x-icon">
  <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;700&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'DM Sans', sans-serif;
      margin: 0;
      background: linear-gradient(135deg, #070b1e 0%, #0f152e 100%);
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      overflow: hidden;
      color: white;
    }

    #wrap {
      position: relative;
      box-shadow: 0 0 40px rgba(0, 150, 255, 0.3);
      border-radius: 10px;
      overflow: hidden;
    }

    canvas {
      background: #0b102a;
      display: block;
      border-radius: 10px;
    }

    #ui,
    #death-count {
      position: absolute;
      transform: translateY(var(--cameraY, 0px));
    }

    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      font-weight: bold;
      background: rgba(10, 15, 40, 0.7);
      padding: 8px 15px;
      border-radius: 5px;
      font-size: 16px;
      z-index: 10;
    }

    #win {
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0.85);
      display: none;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      font-size: 42px;
      text-align: center;
      z-index: 20;
      border-radius: 10px;
    }

    #win h1 {
      margin: 0;
      background: linear-gradient(90deg, #ffd700, #ffed4e);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      text-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
      margin-bottom: 20px;
    }

    #win p {
      font-size: 24px;
      margin: 10px 0 30px 0;
      color: #a0e0ff;
    }

    button {
      padding: 12px 25px;
      font-size: 18px;
      cursor: pointer;
      background: linear-gradient(to bottom, #2a7fff, #0050d5);
      color: white;
      border: none;
      border-radius: 50px;
      font-weight: bold;
      box-shadow: 0 5px 15px rgba(0, 80, 213, 0.4);
      transition: all 0.2s;
      margin: 10px;
    }

    button:hover {
      transform: translateY(-3px);
      box-shadow: 0 8px 20px rgba(0, 80, 213, 0.6);
      background: linear-gradient(to bottom, #3a8fff, #0060e5);
    }

    #controls {
      position: absolute;
      bottom: 15px;
      left: 0;
      right: 0;
      text-align: center;
      color: rgba(255, 255, 255, 0.7);
      font-size: 14px;
      z-index: 10;
    }

    #death-count {
      position: absolute;
      top: 50px;
      left: 10px;
      background: rgba(10, 15, 40, 0.7);
      padding: 8px 15px;
      border-radius: 5px;
      font-size: 14px;
      z-index: 10;
      color: #ff6b6b;
    }

    .particle {
      position: absolute;
      pointer-events: none;
      z-index: 5;
    }

    @keyframes bounce {

      0%,
      100% {
        transform: translateY(0);
      }

      50% {
        transform: translateY(-8px);
      }
    }

    @keyframes pulse {
      0% {
        transform: scale(1);
        opacity: 1;
      }

      50% {
        transform: scale(1.05);
        opacity: 0.9;
      }

      100% {
        transform: scale(1);
        opacity: 1;
      }
    }

    @keyframes rotate {
      from {
        transform: rotate(0deg);
      }

      to {
        transform: rotate(360deg);
      }
    }

    button,
    #ui {
      font-family: inherit;
    }
  </style>
</head>

<body>

  <div id="wrap">
    <canvas id="game" width="800" height="500"></canvas>
    <div id="ui"></div>
    <div id="win">
      <h1> VICTORY! </h1>
      <p>You completed all levels!</p>
      <p id="finalScore">Final Score: 0</p>
      <div>
        <button onclick="restart()">Play Again</button>
      </div>
    </div>
    <div id="controls">
      Use <b>Arrow Keys</b> to move | <b>UP</b> to jump | <b>ESC</b> to pause
    </div>
  </div>

  <script>
    const c = document.getElementById("game");
    const x = c.getContext("2d");
    const ui = document.getElementById("ui");
    const win = document.getElementById("win");
    const finalScoreElement = document.getElementById("finalScore");
    const deathCountElement = document.getElementById("death-count");
    // World / camera
    let cameraX = 0,
      cameraY = 0;
    let gameCompleted = false;

    const GRAVITY = 0.6;
    const JUMP_FORCE = -13;
    const DOUBLE_JUMP_FORCE = -11;
    const MOVE_SPEED = 5;

    let level = 0;
    let score = 0;
    let deaths = 0;
    let particles = [];
    let gameTime = 0;
    let isPaused = false;

    const keys = {};
    onkeydown = e => {
      if (e.code === "Escape") {
        isPaused = !isPaused;
        return;
      }

      // SECRET BETA KEY: Press the uncommon "Shift" key to auto-beat the current level
    /*  if (e.code === "ShiftLeft" || e.code === "ShiftRight") {
        if (!gameCompleted) {
          const L = levels[level];
          // collect remaining coins and award their score
          L.coins.forEach(c => {
            if (!c.collected) {
              c.collected = true;
              score += 10;
              createParticles(c.x, c.y, "#ff0", 20);
            }
          });


          // simulate reaching the goal
          createParticles(L.goal.x + L.goal.w / 2, L.goal.y + L.goal.h / 2, "#0f0", 30);
          const allCoinsCollected = L.coins.every(c => c.collected);
          if (allCoinsCollected) {
            score += 50;
            createParticles(L.goal.x + L.goal.w / 2, L.goal.y + L.goal.h / 2, "#ff0", 40);
          }

          level++;
          if (level >= levels.length) {
            finalScoreElement.textContent = `Final Score: ${score}`;
            win.style.display = "flex";
            level = levels.length - 1;
            gameCompleted = true;
          } else {
            reset();
          }
          updateUI();
        }
        return;
      }*/

      keys[e.code] = true;
    };
    onkeyup = e => keys[e.code] = false;

    const player = {
      x: 50,
      y: 300,
      w: 30,
      h: 45,
      dx: 0,
      dy: 0,
      onGround: false,
      canDoubleJump: true,
      color: "red",
      facing: 1
    };

    // Levels with per-level worldWidth (ground widths and goal.x computed per level)
    const levels = [
      // Level 1
      {
        worldWidth: 2100,
        name: "Level 1",
        plats: [
          { x: 0, y: 430, w: 2100, h: 20, color: "#666" },
          { x: 130, y: 360, w: 160, h: 15, color: "#8a6" },
          { x: 360, y: 320, w: 140, h: 15, color: "#8a6" },
          { x: 620, y: 280, w: 160, h: 15, color: "#8a6" },
          { x: 900, y: 240, w: 140, h: 15, color: "#8a6" },
          { x: 1180, y: 200, w: 130, h: 15, color: "#8a6" },
          { x: 1400, y: 160, w: 160, h: 15, color: "#8a6" },
          { x: 1700, y: 130, w: 30, h: 15, color: "#8a6" },
          { x: 1870, y: 100, w: 40, h: 15, color: "#8a6" },
          { x: 2050, y: 200, w: 30, h: 15, color: "#8a6" },
          { x: 1950, y: 0, w: 100, h: 15, color: "#8a6", move: -3, min: 200, max: 1980 }


        ],
        spikes: [
          { x: 280, y: 420, w: 80, h: 10, color: "#f44" },
          { x: 760, y: 420, w: 80, h: 10, color: "#f44" },
          { x: 1120, y: 420, w: 80, h: 10, color: "#f44" },
          { x: 1620, y: 420, w: 80, h: 10, color: "#f44" }
        ],
        coins: [
          { x: 180, y: 330, collected: false },
          { x: 420, y: 0, collected: false },
          { x: 700, y: 250, collected: false },
          { x: 980, y: 210, collected: false },
          { x: 1150, y: 170, collected: false }
        ],
        checkpoints: [
          { x: 50, y: 400, w: 20, h: 36, color: "#0ff", activated: false },    // beginning checkpoint
          { x: 1450, y: 125, w: 20, h: 36, color: "#0ff", activated: false }
        ],
        goal: { x: 100 - 50, y: -10, w: 40, h: 60, color: "#0f0" }
      },
      // Level 2
      {
        worldWidth: 2100,
        name: "Level 2",
        plats: [
          { x: 0, y: 430, w: 2100, h: 20, color: "#666" },
          { x: 180, y: 370, w: 140, h: 15, color: "#68a" },
          { x: 380, y: 330, w: 120, h: 15, color: "#68a", move: 1.5, min: 320, max: 780 },
          { x: 840, y: 250, w: 120, h: 15, color: "#68a", move: -1.8, min: 720, max: 1080 },
          { x: 1080, y: 210, w: 120, h: 15, color: "#68a" },
          { x: 1360, y: 180, w: 140, h: 15, color: "#68a" },
          { x: 1600, y: 150, w: 20, h: 15, color: "#68a" },
          { x: 1700, y: 120, w: 40, h: 15, color: "#68a", move: 1.4, min: 1700, max: 1900 },
          { x: 1920, y: 90, w: 20, h: 15, color: "#68a" },
          { x: 2000, y: 160, w: 60, h: 15, color: "#68a" },

          // Optional coin route for 5th coin
          { x: 1800, y: -10, w: 100, h: 15, color: "#68a", move: -2.5, min: 1500, max: 1801 },
          { x: 1500, y: -40, w: 100, h: 15, color: "#68a" },
          { x: 1300, y: -70, w: 100, h: 15, color: "#68a", move: 2, min: 1100, max: 1301 }



        ],
        spikes: [
          { x: 420, y: 420, w: 80, h: 10, color: "#f44" },
          { x: 920, y: 420, w: 100, h: 10, color: "#f44" },
          { x: 1280, y: 420, w: 80, h: 10, color: "#f44" }
        ],
        coins: [
          { x: 240, y: 340, collected: false },
          { x: 420, y: 300, collected: false },
          { x: 700, y: 260, collected: false },
          { x: 980, y: 220, collected: false },
          { x: 1300, y: -80, collected: false }
        ],
        checkpoints: [
          { x: 50, y: 400, w: 20, h: 36, color: "#0ff", activated: false },
          { x: 1380, y: 150, w: 20, h: 36, color: "#0ff", activated: false }
        ],
        goal: { x: 2100 - 50, y: 130, w: 40, h: 60, color: "#0f0" }
      },
      // Level 3
      {
        worldWidth: 2100,
        name: "Level 3",
        plats: [
          { x: 0, y: 430, w: 2100, h: 20, color: "#666" },
          { x: 140, y: 390, w: 120, h: 15, color: "#a68", move: -1.5, min: 140, max: 400 },
          { x: 340, y: 350, w: 140, h: 15, color: "#a68", move: 2, min: 300, max: 650 },
          { x: 640, y: 310, w: 120, h: 15, color: "#a68", move: -1.8, min: 540, max: 850 },
          { x: 880, y: 270, w: 120, h: 15, color: "#a68", move: 2.2, min: 800, max: 1100 },
          { x: 1120, y: 230, w: 140, h: 15, color: "#a68", move: -2, min: 940, max: 1400 },
          { x: 1480, y: 190, w: 120, h: 15, color: "#a68", move: 1.6, min: 1400, max: 1800 },
          { x: 1720, y: 160, w: 160, h: 15, color: "#a68" },

          // SKY Climb -- Route for 3rd coin
          { x: 1800, y: 0, w: 100, h: 15, color: "#a68" },
          { x: 1600, y: 0, w: 100, h: 15, color: "#a68" },
          { x: 1400, y: 80, w: 100, h: 15, color: "#a68" },
          { x: 1200, y: 40, w: 100, h: 15, color: "#a68" },
          { x: 1000, y: 40, w: 100, h: 15, color: "#a68" },
          { x: 800, y: 20, w: 100, h: 15, color: "#a68" },
          { x: 600, y: 0, w: 100, h: 15, color: "#a68" },
          { x: 400, y: -20, w: 100, h: 15, color: "#a68", move: 1.5, min: 200, max: 401 },
          { x: 150, y: -40, w: 100, h: 15, color: "#a68" }

        ],
        spikes: [
          { x: 420, y: 420, w: 100, h: 10, color: "#f44" },
          { x: 980, y: 420, w: 120, h: 10, color: "#f44" },
          { x: 1720, y: 150, w: 20, h: 10, color: "#f44", platform: 7 }

        ],
        coins: [
          { x: 160, y: 360, collected: false },
          { x: 380, y: 320, collected: false },
          { x: 170, y: -45, collected: false },
          { x: 1060, y: 240, collected: false },
          { x: 1420, y: 200, collected: false }
        ],
        checkpoints: [
          { x: 50, y: 400, w: 20, h: 36, color: "#0ff", activated: false },
          { x: 1080, y: 2, w: 20, h: 36, color: "#0ff", activated: false }
        ],
        goal: { x: 2100 - 50, y: 80, w: 40, h: 60, color: "#0f0" }
      },
      // Level 4
      {
        worldWidth: 1950,
        name: "Level 4",
        plats: [
          { x: 0, y: 430, w: 1900, h: 20, color: "#666" },
          { x: 140, y: 400, w: 100, h: 15, color: "#6aa" },
          { x: 300, y: 360, w: 140, h: 15, color: "#6aa", move: 1.8, min: 300, max: 600 },
          { x: 580, y: 320, w: 120, h: 15, color: "#6aa", move: -2, min: 480, max: 800 },
          { x: 820, y: 280, w: 140, h: 15, color: "#6aa", move: 2.2, min: 780, max: 1200 },
          { x: 1280, y: 240, w: 120, h: 15, color: "#6aa" },
          { x: 1420, y: 200, w: 140, h: 15, color: "#6aa", move: 1.5, min: 1400, max: 1800 },


          // wall
          { x: 1840, y: -20, w: 30, h: 470, color: "#6aa" },

          { x: 1600, y: 90, w: 100, h: 15, color: "#6aa" },
          { x: 1400, y: 20, w: 100, h: 15, color: "#6aa" },
          { x: 1200, y: -10, w: 100, h: 15, color: "#6aa" },
          { x: 1000, y: -40, w: 100, h: 15, color: "#6aa" },
          { x: 800, y: -70, w: 100, h: 15, color: "#6aa" },
          { x: 600, y: -100, w: 100, h: 15, color: "#6aa" },
          { x: 400, y: -130, w: 100, h: 15, color: "#6aa" },
          { x: 200, y: -160, w: 100, h: 15, color: "#6aa" },

          // Pt 2, moving sky platforms
          { x: 300, y: -250, w: 120, h: 15, color: "#6aa", move: 2.5, min: 500, max: 800 },
          { x: 750, y: -220, w: 120, h: 15, color: "#6aa", move: -2.2, min: 600, max: 900 },
          { x: 1000, y: -190, w: 120, h: 15, color: "#6aa", move: 1.8, min: 1000, max: 1300 },
          { x: 1300, y: -160, w: 120, h: 15, color: "#6aa" },
          { x: 1600, y: -130, w: 120, h: 15, color: "#6aa", move: -1.5, min: 1400, max: 1700 }


        ],
        spikes: [

          { x: 560, y: 420, w: 80, h: 10, color: "#f44" },
          { x: 920, y: 420, w: 100, h: 10, color: "#f44" },
          { x: 1240, y: 420, w: 100, h: 10, color: "#f44" },

        ],
        coins: [
          { x: 140, y: 370, collected: false },
          { x: 380, y: 335, collected: false },
          { x: 620, y: 300, collected: false },
          { x: 920, y: 260, collected: false },
          { x: 1180, y: 220, collected: false },
        ],
        checkpoints: [
          { x: 50, y: 400, w: 20, h: 36, color: "#0ff", activated: false },
          { x: 240, y: -185, w: 20, h: 36, color: "#0ff", activated: false }
        ],
        goal: { x: 1900, y: 85, w: 40, h: 60, color: "#0f0" }
      }
    ];

    function createParticles(x, y, color, count) {
      for (let i = 0; i < count; i++) {
        particles.push({
          x: x,
          y: y,
          dx: (Math.random() - 0.5) * 4,
          dy: (Math.random() - 0.5) * 4,
          size: Math.random() * 4 + 2,
          color: color,
          life: 30
        });
      }
    }

    function updateParticles() {
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.dx;
        p.y += p.dy;
        p.dy += 0.1;
        p.life--;

        if (p.life <= 0) {
          particles.splice(i, 1);
        }
      }
    }

    function drawParticles() {
      for (const p of particles) {
        x.globalAlpha = p.life / 30;
        x.fillStyle = p.color;
        x.beginPath();
        x.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        x.fill();
      }
      x.globalAlpha = 1;
    }

    function reset() {
      // respawn at current level's respawn point (set during init or when checkpoint activated)
      const L = levels[level];
      const resp = L && L.respawn ? L.respawn : { x: 50, y: 300 };
      player.x = resp.x;
      player.y = resp.y;
      player.dx = 0;
      player.dy = 0;
      player.onGround = false;
      player.canDoubleJump = true;
    }

    function restart() {
      level = 0;
      score = 0;
      deaths = 0;
      levels.forEach(L => {
        L.coins.forEach(c => c.collected = false);
        if (L.checkpoints) L.checkpoints.forEach(cp => cp.activated = false);
        // initialize respawn to first checkpoint if present, otherwise a default start
        L.respawn = (L.checkpoints && L.checkpoints[0]) ? { x: L.checkpoints[0].x, y: L.checkpoints[0].y - player.h } : { x: 50, y: 300 };
      });
      win.style.display = "none";
      gameCompleted = false;
      reset();
      updateUI();
    }

    function hit(a, b) {
      return a.x < b.x + b.w && a.x + a.w > b.x &&
        a.y < b.y + b.h && a.y + a.h > b.y;
    }

    function update() {
      if (isPaused || gameCompleted) return;

      gameTime++;

      player.dx = 0;
      if (keys.ArrowLeft) {
        player.dx = -MOVE_SPEED;
        player.facing = -1;
      }
      if (keys.ArrowRight) {
        player.dx = MOVE_SPEED;
        player.facing = 1;
      }

      if (keys.ArrowUp) {
        if (player.onGround) {
          player.dy = JUMP_FORCE;
          player.onGround = false;
          player.canDoubleJump = true;
          createParticles(player.x + player.w / 2, player.y + player.h, "#0ff", 8);
        } else if (player.canDoubleJump) {
          player.dy = DOUBLE_JUMP_FORCE;
          player.canDoubleJump = false;
          createParticles(player.x + player.w / 2, player.y + player.h, "#0af", 12);
        }
      }

      player.dy += GRAVITY;
      player.x += player.dx;
      player.y += player.dy;

      const L = levels[level];
      // World boundaries (prevent leaving horizontally and top) - use current level worldWidth
      player.x = Math.max(0, Math.min(player.x, L.worldWidth - player.w));
      // clamp player vertically to the level's vertical bounds (supports taller levels)
      player.y = Math.max(L.worldMinY, Math.min(player.y, L.worldMaxY - player.h));
      player.onGround = false;

      // move platforms (use index so we can attach spikes to specific plats)
      for (let pi = 0; pi < L.plats.length; pi++) {
        const p = L.plats[pi];
        if (p.move) {
          p.x += p.move;
          if (p.x < p.min || p.x > p.max) p.move *= -1;
        }

        // reposition any spikes attached to this platform
        for (const s of L.spikes) {
          if (s.platform === pi) {
            if (s._offsetX === undefined) { // compute offsets once
              s._offsetX = s.x - p.x;
              s._offsetY = s.y - p.y;
            }
            s.x = p.x + s._offsetX;
            s.y = p.y + s._offsetY;
          }
        }

        // platform collision with player

        // Replace the platform collision code with this:
        if (player.x < p.x + p.w && player.x + player.w > p.x &&
          player.y < p.y + p.h && player.y + player.h > p.y) {

          // Calculate overlap on each side
          const overlapTop = (player.y + player.h) - p.y;
          const overlapBottom = (p.y + p.h) - player.y;
          const overlapLeft = (player.x + player.w) - p.x;
          const overlapRight = (p.x + p.w) - player.x;

          // Find the smallest overlap
          const minOverlap = Math.min(overlapTop, overlapBottom, overlapLeft, overlapRight);

          // Resolve based on the smallest overlap (prevents sticking)
          if (minOverlap === overlapTop && player.dy >= 0) {
            // Hit from above (landing on platform)
            player.y = p.y - player.h;
            player.dy = 0;
            player.onGround = true;
            player.canDoubleJump = true;
          } else if (minOverlap === overlapBottom && player.dy <= 0) {
            // Hit from below
            player.y = p.y + p.h;
            player.dy = 0;
          } else if (minOverlap === overlapLeft) {
            // Hit from left
            player.x = p.x - player.w;
            player.dx = 0;
          } else if (minOverlap === overlapRight) {
            // Hit from right
            player.x = p.x + p.w;
            player.dx = 0;
          }
        }
      }

      // Checkpoints: activation and respawn assignment
      if (L.checkpoints) {
        for (const cp of L.checkpoints) {
          if (!cp.activated && player.x < cp.x + cp.w && player.x + player.w > cp.x &&
            player.y < cp.y + cp.h && player.y + player.h > cp.y) {
            cp.activated = true;
            // set respawn to just above the checkpoint
            L.respawn = { x: cp.x, y: cp.y - player.h };
            score += 20; // small bonus
            createParticles(cp.x + cp.w / 2, cp.y + cp.h / 2, "#0ff", 25);
            updateUI();
          }
        }
      }

      for (const s of L.spikes) {
        if (player.x < s.x + s.w && player.x + player.w > s.x &&
          player.y < s.y + s.h && player.y + player.h > s.y) {
          deaths++;
          createParticles(player.x + player.w / 2, player.y + player.h / 2, "#f44", 20);
          reset();
          updateUI();
        }
      }

      for (const coin of L.coins) {
        if (!coin.collected &&
          player.x < coin.x + 16 && player.x + player.w > coin.x - 16 &&
          player.y < coin.y + 16 && player.y + player.h > coin.y - 16) {
          coin.collected = true;
          score += 10;
          createParticles(coin.x, coin.y, "#ff0", 15);
          updateUI();
        }
      }

      const goal = L.goal;
      if (player.x < goal.x + goal.w && player.x + player.w > goal.x &&
        player.y < goal.y + goal.h && player.y + player.h > goal.y) {
        createParticles(goal.x + goal.w / 2, goal.y + goal.h / 2, "#0f0", 30);

        // Check if all coins collected for bonus
        const allCoinsCollected = L.coins.every(c => c.collected);
        if (allCoinsCollected) {
          score += 50;
          createParticles(goal.x + goal.w / 2, goal.y + goal.h / 2, "#ff0", 40);
        }

        level++;
        if (level >= levels.length) {
          finalScoreElement.textContent = `Final Score: ${score}`;
          win.style.display = "flex";
          level = levels.length - 1;
          gameCompleted = true; // freeze movement and scoring after win
        } else {
          reset();
        }
        updateUI();
      }

      if (player.y > 600) {
        deaths++;
        reset();
        updateUI();
      }

      // Camera follow (center player horizontally and vertically, clamp to world)
      cameraX = Math.round(player.x + player.w / 2 - c.width / 2);
      cameraX = Math.max(0, Math.min(cameraX, L.worldWidth - c.width));
      cameraY = Math.round(player.y + player.h / 2 - c.height / 2);
      cameraY = Math.max(L.worldMinY, Math.min(cameraY, L.worldMaxY - c.height));

      document.getElementById("wrap").style.setProperty('--cameraY', `${cameraY}px`);

      updateParticles();
    }

    function draw() {
      // Cameraed world rendering
      const gradient = x.createLinearGradient(0, 0, 0, c.height);
      gradient.addColorStop(0, "#0b102a");
      gradient.addColorStop(1, "#050915");

      x.save();
      x.translate(-cameraX, -cameraY);

      // Background for viewport (respect cameraY for vertical scrolling)
      x.fillStyle = gradient;
      x.fillRect(cameraX, cameraY, c.width, c.height);

      const L = levels[level];

      // Checkpoints rendering
      if (L.checkpoints) {
        for (const cp of L.checkpoints) {
          x.save();

          // glow when active
          if (cp.activated) {
            x.fillStyle = "rgba(0,255,0,0.25)";
            x.beginPath();
            x.arc(cp.x, cp.y, 30, 0, Math.PI * 2);
            x.fill();
          }

          // thin metal pole
          x.fillStyle = "#9a9a9a";
          x.fillRect(cp.x - 1, cp.y - 26, 2, cp.h + 26);

          // flag
          x.fillStyle = cp.activated ? "#22ff22" : "#ff2222";
          x.beginPath();
          x.moveTo(cp.x, cp.y - 28);        // higher
          x.lineTo(cp.x + 22, cp.y - 16);   // wider
          x.lineTo(cp.x, cp.y - 4);         // taller
          x.closePath();
          x.fill();

          x.restore();
        }
      }



      // Platforms
      for (const p of L.plats) {
        x.fillStyle = "rgba(0, 0, 0, 0.3)";
        x.fillRect(p.x + 3, p.y + 3, p.w, p.h);
        x.fillStyle = p.color;
        x.fillRect(p.x, p.y, p.w, p.h);
        x.fillStyle = "rgba(255,255,255,0.2)";
        x.fillRect(p.x, p.y, p.w, 3);
      }

      // Spikes
      for (const s of L.spikes) {
        x.fillStyle = "rgba(200,0,0,0.5)";
        x.fillRect(s.x + 2, s.y + 2, s.w, s.h);
        x.fillStyle = s.color;
        x.fillRect(s.x, s.y, s.w, s.h);
        x.fillStyle = "#f88";
        const teethCount = Math.floor(s.w / 10);
        for (let i = 0; i < teethCount; i++) {
          x.beginPath();
          x.moveTo(s.x + i * 10, s.y);
          x.lineTo(s.x + i * 10 + 5, s.y - 8);
          x.lineTo(s.x + i * 10 + 10, s.y);
          x.closePath();
          x.fill();
        }

      }

      // Coins
      for (const coin of L.coins) {
        if (!coin.collected) {
          const bounce = Math.sin(gameTime * 0.1 + coin.x * 0.01) * 5;
          const rotation = gameTime * 0.05;
          x.save();
          x.translate(coin.x, coin.y + bounce);
          x.rotate(rotation);
          x.fillStyle = "#ffd700";
          x.beginPath();
          x.arc(0, 0, 10, 0, Math.PI * 2);
          x.fill();

          x.fillStyle = "#ffed4e";
          x.beginPath();
          x.arc(0, 0, 8, 0, Math.PI * 2);
          x.fill();

          x.fillStyle = "#ffd700";
          x.beginPath();
          x.arc(0, 0, 5, 0, Math.PI * 2);
          x.fill();
          x.restore();
        }
      }

      // Goal
      const goal = L.goal;
      const pulse = Math.sin(gameTime * 0.05) * 0.2 + 0.8;
      x.fillStyle = `rgba(0,255,0,${0.3 * pulse})`;
      x.beginPath();
      x.arc(goal.x + goal.w / 2, goal.y + goal.h / 2, 40, 0, Math.PI * 2);
      x.fill();
      x.fillStyle = goal.color;
      x.fillRect(goal.x, goal.y, goal.w, goal.h);
      x.fillStyle = "#0c0";
      x.fillRect(goal.x + 5, goal.y + 10, goal.w - 10, 8);
      x.fillRect(goal.x + 5, goal.y + 25, goal.w - 10, 8);
      x.fillRect(goal.x + 5, goal.y + 40, goal.w - 10, 8);

      // Particles (world-space)
      drawParticles();

      // Player
      x.save();
      x.translate(player.x + player.w / 2, player.y + player.h / 2);
      if (player.facing === -1) x.scale(-1, 1);
      x.fillStyle = player.color;
      x.fillRect(-player.w / 2, -player.h / 2, player.w, player.h);
      x.fillStyle = "#0af";
      x.fillRect(-player.w / 2 + 5, -player.h / 2 + 5, player.w - 10, 10);
      x.fillStyle = "white";
      x.beginPath();
      x.arc(player.w / 2 - 10, -player.h / 2 + 15, 4, 0, Math.PI * 2);
      x.fill();

      x.fillStyle = "#00f";
      x.beginPath();
      x.arc(player.w / 2 - 10, -player.h / 2 + 15, 2, 0, Math.PI * 2);
      x.fill();
      x.restore();

      // Player shadow
      x.fillStyle = "rgba(0,0,0,0.3)";
      x.fillRect(player.x + 3, player.y + 3, player.w, player.h);

      x.restore(); // restore camera transform
    }

    function updateUI() {
      const L = levels[level];
      const coinsCollected = L.coins.filter(c => c.collected).length;
      const totalCoins = L.coins.length;

      // Clear the HTML UI
      ui.innerHTML = '';

      // Draw UI on canvas (so it moves with camera)
      x.save();
      x.translate(-cameraX, -cameraY); // Match camera transform

      // Draw UI background at fixed screen position (10, 10) in world space
      const uiX = cameraX + 10;
      const uiY = cameraY + 10;

      x.fillStyle = "rgba(10, 15, 40, 0.7)";
      x.fillRect(uiX, uiY, 350, 40);
      x.fillStyle = "white";
      x.font = "bold 16px DM Sans, sans-serif";
      x.textAlign = "left";

      // Draw text with yellow highlights
      x.fillText("Level: ", uiX + 10, uiY + 25);
      x.fillStyle = "#ffd700"; // Yellow
      x.fillText(`${level + 1}`, uiX + 60, uiY + 25);

      x.fillStyle = "white";
      x.fillText("| Score: ", uiX + 75, uiY + 25);
      x.fillStyle = "#ffd700";
      x.fillText(`${score}`, uiX + 135, uiY + 25);

      x.fillStyle = "white";
      x.fillText("| Coins: ", uiX + 170, uiY + 25);
      x.fillStyle = "#ffd700";
      x.fillText(`${coinsCollected}/${totalCoins}`, uiX + 235, uiY + 25);

      x.fillStyle = "white";
      x.fillText("| Deaths: ", uiX + 270, uiY + 25);
      x.fillStyle = "#ffd700";
      x.fillText(`${deaths}`, uiX + 340, uiY + 25);


      x.restore();

      // Keep pause menu drawing as before
      if (isPaused) {
        x.fillStyle = "rgba(0, 0, 0, 0.7)";
        x.fillRect(0, 0, c.width, c.height);

        x.fillStyle = "white";
        x.font = "bold 48px DM Sans, sans-serif";
        x.textAlign = "center";
        x.fillText("PAUSED", c.width / 2, c.height / 2);

        x.font = "24px DM Sans, sans-serif";
        x.fillText("Press ESC to resume", c.width / 2, c.height / 2 + 50);
      }
    }

    function loop() {
      update();
      draw();
      updateUI();
      requestAnimationFrame(loop);
    }

    // Initialize coins and compute spike offsets for attached spikes (if any)
    // Also compute per-level vertical bounds so levels can be taller than the viewport
    levels.forEach(L => {
      L.coins.forEach(c => c.collected = false);
      if (L.checkpoints) L.checkpoints.forEach(cp => cp.activated = !!cp.activated);
      // ensure worldWidth exists (fallback)
      if (!L.worldWidth && L.plats && L.plats[0]) L.worldWidth = L.plats[0].w;

      // set initial respawn: prefer first checkpoint, otherwise default start
      L.respawn = (L.checkpoints && L.checkpoints[0]) ? { x: L.checkpoints[0].x, y: L.checkpoints[0].y - player.h } : { x: 50, y: 300 };

      // compute vertical bounds from platforms, spikes, coins, and goal
      let minY = 0;
      let maxY = c.height;
      if (L.plats) {
        for (const p of L.plats) {
          minY = Math.min(minY, p.y);
          maxY = Math.max(maxY, p.y + p.h);
        }
      }
      if (L.spikes) {
        for (const s of L.spikes) {
          minY = Math.min(minY, s.y);
          maxY = Math.max(maxY, s.y + s.h);
        }
      }
      if (L.checkpoints) {
        for (const cp of L.checkpoints) {
          minY = Math.min(minY, cp.y);
          maxY = Math.max(maxY, cp.y + cp.h);
        }
      }
      if (L.coins) {
        for (const coin of L.coins) {
          minY = Math.min(minY, coin.y - 20);
          maxY = Math.max(maxY, coin.y + 20);
        }
      }
      if (L.goal) {
        minY = Math.min(minY, L.goal.y);
        maxY = Math.max(maxY, L.goal.y + L.goal.h);
      }
      // add margins and ensure sensible defaults
      L.worldMinY = Math.min(minY - 100, 0);
      L.worldMaxY = Math.max(maxY + 100, c.height);

      // precompute offsets for spikes that reference a platform index
      L.spikes.forEach(s => {
        if (typeof s.platform === "number") {
          const p = L.plats[s.platform];
          if (p) {
            s._offsetX = s.x - p.x;
            s._offsetY = s.y - p.y;
          }
        }
      });
    });
    loop();
  </script>
</body>

</html>