<!DOCTYPE html>
<html>
<head>
    <title>Space Shooter Deluxe</title>
    <link rel="icon" href="check.png">
    <style>
        :root {
            --primary: #0af;
            --accent: #f0a;
            --warning: #f50;
            --success: #0f0;
            --background: #000;
            --text: #fff;
        }

        body {
            margin: 0;
            overflow: hidden;
            background: radial-gradient(circle at center, #001428 0%, var(--background) 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Arial', sans-serif;
            color: var(--text);
        }

        canvas {
            border: 2px solid #0af;
            box-shadow: 0 0 20px var(--primary),
                       inset 0 0 20px var(--primary);
            border-radius: 10px;
        }

        #gameOver, #startScreen {
            position: absolute;
            text-align: center;
            background: rgba(0, 0, 0, 0.9);
            padding: 2rem;
            border-radius: 15px;
            border: 2px solid var(--primary);
            box-shadow: 0 0 30px var(--primary);
        }

        #gameOver {
            display: none;
            animation: fadeIn 0.5s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.9); }
            to { opacity: 1; transform: scale(1); }
        }

        .game-title {
            font-size: 3rem;
            margin: 0 0 1rem;
            background: linear-gradient(45deg, var(--primary), var(--accent));
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 10px rgba(0, 170, 255, 0.5);
        }

        .hud-element {
            position: absolute;
            padding: 0.5rem 1rem;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid var(--primary);
            border-radius: 5px;
            font-size: 1.2rem;
            text-shadow: 0 0 5px var(--primary);
        }

        #scoreDisplay { top: 10px; left: 10px; }
        #levelDisplay { top: 10px; right: 10px; }
        #healthBar { top: 50px; left: 10px; width: 200px; }

        .health-fill {
            height: 10px;
            background: linear-gradient(to right, #f00, #0f0);
            transition: width 0.3s;
            border-radius: 5px;
        }

        .power-up {
            position: absolute;
            animation: powerUpGlow 2s infinite;
        }

        @keyframes powerUpGlow {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.5); }
        }

        .status-effect {
            position: absolute;
            top: 90px;
            left: 10px;
            display: flex;
            gap: 10px;
        }

        .effect-icon {
            width: 30px;
            height: 30px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid var(--primary);
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
        }

        button {
            background: linear-gradient(45deg, var(--primary), var(--accent));
            border: none;
            padding: 1rem 2rem;
            font-size: 1.2rem;
            color: white;
            border-radius: 5px;
            cursor: pointer;
            margin: 1rem;
            transition: all 0.3s;
            text-transform: uppercase;
            font-weight: bold;
            letter-spacing: 1px;
        }

        button:hover {
            transform: scale(1.1);
            box-shadow: 0 0 20px var(--primary);
        }

        #instructions {
            max-height: 300px;
            overflow-y: auto;
            padding: 1rem;
            margin: 1rem 0;
            border: 1px solid var(--primary);
            border-radius: 5px;
            background: rgba(0, 0, 0, 0.5);
        }

        .achievement {
            position: absolute;
            right: 20px;
            bottom: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 1rem;
            border-radius: 5px;
            border: 2px solid var(--success);
            animation: slideIn 0.5s ease-out;
        }

        @keyframes slideIn {
            from { transform: translateX(100%); }
            to { transform: translateX(0); }
        }

        .explosion {
            position: absolute;
            pointer-events: none;
        }

        #messageDisplay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2rem;
            text-align: center;
            text-shadow: 0 0 10px var(--primary);
            display: none;
        }

        .combo-counter {
            position: absolute;
            font-size: 2rem;
            color: var(--accent);
            text-shadow: 0 0 10px var(--accent);
            animation: comboScale 0.3s ease-out;
        }

        @keyframes comboScale {
            0% { transform: scale(2); }
            100% { transform: scale(1); }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="scoreDisplay" class="hud-element">Score: 0</div>
    <div id="levelDisplay" class="hud-element">Level: 1</div>
    <div id="healthBar" class="hud-element">
        <div class="health-fill"></div>
    </div>
    <div class="status-effect" id="statusEffects"></div>
    
    <div id="startScreen">
        <h1 class="game-title">SPACE SHOOTER DELUXE</h1>
        <div id="instructions">
            <h2>CONTROLS</h2>
            <p>‚Üë‚Üì‚Üê‚Üí - Move Ship</p>
            <p>SPACE - Fire</p>
            <p>ESC - Pause</p>
            
            <h2>POWER-UPS</h2>
            <p>üõ°Ô∏è Shield - Temporary invincibility</p>
            <p>‚ö° Rapid Fire - Increased fire rate</p>
            <p>‚ûó Split Shot - Multiple projectiles</p>
            
            <h2>SCORING</h2>
            <p>Small Enemy: 30pts</p>
            <p>Medium Enemy: 50pts</p>
            <p>Large Enemy: 100pts</p>
            <p>Bonus Ships: 2x-3x Score Multiplier</p>
        </div>
        <button id="startButton">START MISSION</button>
    </div>

    <div id="gameOver">
        <h2>GAME OVER</h2>
        <p>Final Score: <span id="finalScore">0</span></p>
        <button id="restartButton">Play Again</button>
    </div>

    <div id="messageDisplay"></div>
    <script>
        // Game setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const levelDisplay = document.getElementById('levelDisplay');
        const gameOverDisplay = document.getElementById('gameOver');
        const startScreen = document.getElementById('startScreen');
        const startButton = document.getElementById('startButton');
        const restartButton = document.getElementById('restartButton');
        const instructionText = document.getElementById('instructionText');
        const instructions = document.getElementById('instructions');
        const messageDisplay = document.getElementById('messageDisplay');

        // Set canvas size
        canvas.width = 800;
        canvas.height = 600;

        // Game state
        let gameRunning = false;
        let score = 0;
        let level = 1;
        let lives = 3;
        let scoreMultiplier = 1;
        let multiplierActive = false;
        let multiplierEndTime = 0;
        let multiplierAnimations = [];
        let explosions = [];
        let enemySpawnRate = 7500; // Initial spawn rate in ms
        let enemySpeedMultiplier = 1; // Initial speed multiplier

        const powerups = [];

        // Player ship
        const player = {
            x: canvas.width / 2,
            y: canvas.height - 50,
            width: 20,
            height: 20,
            speed: 5,
            color: '#0af',
            bullets: [],
            lastShot: 0,
            shootDelay: 300,
            draw: function() {
                // Draw ship body
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.moveTo(this.x, this.y - this.height/2);
                ctx.lineTo(this.x + this.width/2, this.y + this.height/2);
                ctx.lineTo(this.x - this.width/2, this.y + this.height/2);
                ctx.closePath();
                ctx.fill();
                
                // Draw cockpit
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(this.x, this.y - 5, 8, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw engine glow
                if (keys.ArrowUp || keys.ArrowDown) {
                    ctx.fillStyle = '#ff0';
                    ctx.beginPath();
                    ctx.moveTo(this.x - this.width/3, this.y + this.height/2);
                    ctx.lineTo(this.x + this.width/3, this.y + this.height/2);
                    ctx.lineTo(this.x, this.y + this.height/2 + 15);
                    ctx.closePath();
                    ctx.fill();
                }
            },
            update: function() {
                // Keep player within bounds
                if (this.x < this.width/2) this.x = this.width/2;
                if (this.x > canvas.width - this.width/2) this.x = canvas.width - this.width/2;
                if (this.y < this.height/2) this.y = this.height/2;
                if (this.y > canvas.height - this.height/2) this.y = canvas.height - this.height/2;
            },
            shoot: function() {
                const now = Date.now();
                if (now - this.lastShot > this.shootDelay) {
                    this.bullets.push({
                        x: this.x,
                        y: this.y - this.height/2,
                        width: 4,
                        height: 15,
                        speed: 10,
                        color: '#ff0'
                    });
                    this.lastShot = now;
                }
            }
        };

        // Enemies
        const enemies = [];
        const enemyColors = ['#f00', '#f80', '#8f0', '#0f8'];

        // Bonus ships
        const bonusShips = [];
        const bonusColors = ['#ff0', '#f0f', '#0ff'];

        // Planets
        const planets = [];
        const planetColors = ['#a55', '#5a5', '#55a', '#aa5', '#a5a', '#5aa'];

        // Stars
        const stars = [];
        for (let i = 0; i < 200; i++) {
            stars.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                size: Math.random() * 2 + 1,
                speed: Math.random() * 3 + 1,
                color: `rgba(255, 255, 255, ${Math.random()})`
            });
        }

        // Key states
        const keys = {
            ArrowLeft: false,
            ArrowRight: false,
            ArrowUp: false,
            ArrowDown: false,
            ' ': false
        };

        // Event listeners
        window.addEventListener('keydown', (e) => {
            if (keys.hasOwnProperty(e.key)) {
                keys[e.key] = true;
                e.preventDefault();
            }
        });

        window.addEventListener('keyup', (e) => {
            if (keys.hasOwnProperty(e.key)) {
                keys[e.key] = false;
                e.preventDefault();
            }
        });

        startButton.addEventListener('click', startGame);
        restartButton.addEventListener('click', startGame);

        
        function spawnLifePowerup(x, y) {
        const size = 20;
        powerups.push({
            x: x,
            y: y,
            width: size,
            height: size,
            speed: 1,
            color: '#0f0',
            type: 'life',
            collected: false
        });
    }

        function animateInstructions() {
            const height = instructions.clientHeight;
            const textHeight = instructionText.clientHeight;
            let pos = height;
            
            function frame() {
                if (pos < -textHeight) {
                    pos = height;
                } else {
                    pos -= 0.5;
                }
                instructionText.style.top = pos + 'px';
                requestAnimationFrame(frame);
            }
            
            frame();
        }
        
        animateInstructions();

        // Typewriter effect function
        function typeWriter(text, element, speed, callback) {
            let i = 0;
            element.innerHTML = '';
            element.style.display = 'block';
            element.classList.add('typing-text');
            
            function type() {
                if (i < text.length) {
                    element.innerHTML += text.charAt(i);
                    i++;
                    setTimeout(type, speed);
                } else {
                    element.classList.remove('typing-text');
                    if (callback) {
                        setTimeout(callback, 1000);
                    }
                }
            }
            
            type();
        }

        // Level progression
        function checkLevelProgression() {
            const levelThresholds = [0, 1000, 2500, 5000, 8000, 12000];
            
            if (level < levelThresholds.length && score >= levelThresholds[level]) {
                level++;
                levelDisplay.textContent = `Level: ${level}`;
                
                // Increase difficulty
                enemySpawnRate = Math.max(100, 500 - (level * 75));
                enemySpeedMultiplier = 1 + (level * 0.2);
                
                // Show level up message
                const messages = [
                    "LEVEL UP! ENEMIES ARE GETTING FASTER",
                    "ADVANCING TO NEXT PHASE. INCREASED THREAT DETECTED",
                    "WARNING: ENEMY FLEETS STRENGTHENING",
                    "NEXT WAVE INCOMING. PREPARE FOR HEAVY RESISTANCE",
                    "MAXIMUM ALERT: ENEMY ARMADA APPROACHING"
                ];
                
                const message = messages[Math.min(level-1, messages.length-1)];
                typeWriter(message, messageDisplay, 50, () => {
                    setTimeout(() => {
                        messageDisplay.style.display = 'none';
                    }, 2000);
                });
            }
        }

        function startGame() {
            gameRunning = true;
            score = 0;
            level = 1;
            lives = 3;
            scoreMultiplier = 1;
            multiplierActive = false;
            enemySpawnRate = 500;
            enemySpeedMultiplier = 1;
            player.x = canvas.width / 2;
            player.y = canvas.height - 50;
            player.bullets = [];
            enemies.length = 0;
            bonusShips.length = 0;
            planets.length = 0;
            explosions.length = 0;
            scoreDisplay.textContent = `Score: ${score}`;
            levelDisplay.textContent = `Level: ${level}`;
            gameOverDisplay.style.display = 'none';
            startScreen.style.display = 'none';
            messageDisplay.style.display = 'none';
            
            // Show starting message
            typeWriter("INITIATING LAUNCH SEQUENCE. GOOD LUCK, PILOT!", messageDisplay, 50, () => {
                setTimeout(() => {
                    messageDisplay.style.display = 'none';
                }, 2000);
            });
            
            // Initial planet
            spawnPlanet();
            
            // Start enemy spawning
            spawnEnemy();
            
            // Start bonus ship spawning
            spawnBonusShip();
            
            // Start game loop
            requestAnimationFrame(gameLoop);
        }

        function createExplosion(x, y, radius, damage) {
            explosions.push({
                x: x,
                y: y,
                radius: radius,
                maxRadius: radius,
                damage: damage,
                particles: [],
                startTime: Date.now(),
                duration: 500 // ms
            });
        } 

            // Create particles
            for (let i = 0; i < 50; i++) {
                // Game state
                let gameRunning = false;
                let score = 0;
                let level = 1;
                let lives = 3;
                let scoreMultiplier = 1;
                let multiplierActive = false;
                let multiplierEndTime = 0;
                let multiplierAnimations = [];
                let explosions = [];
                let enemySpawnRate = 7500; // Initial spawn rate in ms
                let enemySpeedMultiplier = 1;
                const powerups = [];
            }

        function checkForChainReaction(x, y, radius) {
            const chance = Math.random();
            if (chance <= 0.075) { // 7.5% chance
                createExplosion(x, y, radius * 1.5, 2); // Bigger explosion with more damage
                
                // Show chain reaction message
                multiplierAnimations.push({
                    x: canvas.width / 2,
                    y: canvas.height / 2,
                    text: "CHAIN REACTION!",
                    color: "#f80",
                    startTime: Date.now()
                });
            }
        }

        function checkForSelfDestruction(enemy) {
        // Check if enemy is near the middle of the screen (vertical center)
        const isNearMiddle = enemy.y > canvas.height/2 - 50 && enemy.y < canvas.height/2 + 50;
        
        if (isNearMiddle) {
            // 2-4% chance of self-destruction when in the middle
            const chance = Math.random();
            if (chance <= 0.04) { // 4% chance
                // Create explosion at enemy position
                createExplosion(enemy.x, enemy.y, enemy.width * 4, 3); // Large, powerful explosion
                
                // Remove the enemy
                const enemyIndex = enemies.indexOf(enemy);
                if (enemyIndex > -1) {
                    enemies.splice(enemyIndex, 1);
                }
                
                // Show self-destruction message
                multiplierAnimations.push({
                    x: enemy.x,
                    y: enemy.y - 30,
                    text: "SELF-DESTRUCT!",
                    color: "#f00",
                    startTime: Date.now()
                });
                
                return true;
            }
        }
        return false;
    }

        function spawnPlanet() {
            const size = Math.random() * 100 + 50;
            planets.push({
                x: Math.random() * (canvas.width - size) + size/2,
                y: -size,
                size: size,
                speed: Math.random() * 2 + 1,
                color: planetColors[Math.floor(Math.random() * planetColors.length)],
                rings: Math.random() > 0.5,
                ringColor: `hsl(${Math.random() * 360}, 70%, 50%)`
            });
            
            // Schedule next planet
            setTimeout(spawnPlanet, Math.random() * 10000 + 5000);
        }

        function spawnBonusShip() {
            if (!gameRunning) return;
            
            const size = 30;
            const multiplier = Math.random() > 0.5 ? 2 : 3;
            bonusShips.push({
                x: Math.random() * (canvas.width - size) + size/2,
                y: -size,
                width: size,
                height: size,
                speed: 2,
                color: bonusColors[Math.floor(Math.random() * bonusColors.length)],
                multiplier: multiplier,
                pattern: Math.floor(Math.random() * 2),
                patternStep: 0,
                collected: false
            });
            
            // Schedule next bonus ship
            setTimeout(spawnBonusShip, Math.random() * 15000 + 10000);
        }

        function spawnEnemy() {
            if (!gameRunning) return;
            
            const sizeOptions = [
                { size: 20, points: 30, health: 1 },
                { size: 30, points: 50, health: 2 },
                { size: 40, points: 100, health: 3 }
            ];
            const type = Math.floor(Math.random() * sizeOptions.length);
            const enemyType = sizeOptions[type];
            const pattern = Math.floor(Math.random() * 3);
            
            // Adjust enemy health based on level
            const healthBonus = Math.floor((level - 1) / 2);
            
            enemies.push({
                x: Math.random() * (canvas.width - enemyType.size) + enemyType.size/2,
                y: -enemyType.size,
                width: enemyType.size,
                height: enemyType.size,
                speed: (Math.random() * 2 + 1) * enemySpeedMultiplier,
                color: enemyColors[Math.floor(Math.random() * enemyColors.length)],
                pattern: pattern,
                patternStep: 0,
                health: enemyType.health + healthBonus,
                value: enemyType.points,
                lastShot: 0,
                shootDelay: 1500 + Math.random() * 1000,
                points: enemyType.points
            });
            
            // Schedule next enemy with level-adjusted spawn rate
            setTimeout(spawnEnemy, Math.random() * enemySpawnRate + 300);
        }

        function gameLoop() {
            if (!gameRunning) return;
            
            // Check level progression
            checkLevelProgression();
            
            // Clear canvas
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw stars
            stars.forEach(star => {
                star.y += star.speed;
                if (star.y > canvas.height) {
                    star.y = 0;
                    star.x = Math.random() * canvas.width;
                }
                ctx.fillStyle = star.color;
                ctx.fillRect(star.x, star.y, star.size, star.size);
            });
            
            // Handle input
            if (keys.ArrowLeft) player.x -= player.speed;
            if (keys.ArrowRight) player.x += player.speed;
            if (keys.ArrowUp) player.y -= player.speed;
            if (keys.ArrowDown) player.y += player.speed;
            if (keys[' ']) player.shoot();
            
            // Update player
            player.update();
            
            // Check multiplier expiration
            if (multiplierActive && Date.now() > multiplierEndTime) {
                multiplierActive = false;
                scoreMultiplier = 1;
                multiplierAnimations.push({
                    x: canvas.width - 100,
                    y: 50,
                    text: "Multiplier Expired!",
                    color: "#f00",
                    startTime: Date.now()
                });
            }
            
            powerups.forEach((powerup, pIndex) => {
            // Move powerup down
            powerup.y += powerup.speed;
            
            // Draw powerup (life icon)
            ctx.fillStyle = powerup.color;
            ctx.beginPath();
            ctx.moveTo(powerup.x, powerup.y - powerup.height/2);
            ctx.lineTo(powerup.x + powerup.width/2, powerup.y + powerup.height/2);
            ctx.lineTo(powerup.x - powerup.width/2, powerup.y + powerup.height/2);
            ctx.closePath();
            ctx.fill();
            
            // Draw plus sign inside
            ctx.fillStyle = '#fff';
            ctx.fillRect(powerup.x - 2, powerup.y - 6, 4, 12);
            ctx.fillRect(powerup.x - 6, powerup.y - 2, 12, 4);
            
            // Check collision with player
            if (checkCollision(
                powerup.x - powerup.width/2, powerup.y - powerup.height/2, powerup.width, powerup.height,
                player.x - player.width/2, player.y - player.height/2, player.width, player.height
            )) {
                powerup.collected = true;
                lives++;
                
                // Show life gained message
                multiplierAnimations.push({
                    x: powerup.x,
                    y: powerup.y,
                    text: "EXTRA LIFE!",
                    color: '#0f0',
                    startTime: Date.now()
                });
            }
            
            // Remove if collected or off screen
            if (powerup.collected || powerup.y > canvas.height + powerup.height) {
                powerups.splice(pIndex, 1);
            }
        });

            // Draw and update planets
            planets.forEach((planet, pIndex) => {
                // Move planet
                planet.y += planet.speed;
                
                // Draw planet
                ctx.fillStyle = planet.color;
                ctx.beginPath();
                ctx.arc(planet.x, planet.y, planet.size, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw rings if applicable
                if (planet.rings) {
                    ctx.strokeStyle = planet.ringColor;
                    ctx.lineWidth = 5;
                    ctx.beginPath();
                    ctx.ellipse(planet.x, planet.y, planet.size * 1.5, planet.size * 0.3, 0, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                // Remove if off screen
                if (planet.y > canvas.height + planet.size) {
                    planets.splice(pIndex, 1);
                }
            });
            
            // Update and draw explosions
            explosions.forEach((explosion, exIndex) => {
                const progress = (Date.now() - explosion.startTime) / explosion.duration;
                
                if (progress >= 1) {
                    explosions.splice(exIndex, 1);
                } else {
                    // Update explosion radius
                    explosion.radius = explosion.maxRadius * (1 - progress);
                    
                    // Draw explosion
                    const gradient = ctx.createRadialGradient(
                        explosion.x, explosion.y, 0,
                        explosion.x, explosion.y, explosion.radius
                    );
                    gradient.addColorStop(0, `rgba(255, 100, 0, ${1 - progress})`);
                    gradient.addColorStop(0.7, `rgba(255, 50, 0, ${0.7 - progress * 0.7})`);
                    gradient.addColorStop(1, `rgba(255, 0, 0, 0)`);
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(explosion.x, explosion.y, explosion.radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw particles
                    explosion.particles.forEach(particle => {
                        particle.x += Math.cos(particle.angle) * particle.speed;
                        particle.y += Math.sin(particle.angle) * particle.speed;
                        
                        ctx.fillStyle = particle.color;
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, particle.size * (1 - progress), 0, Math.PI * 2);
                        ctx.fill();
                    });
                    
                    // Damage ships in radius (only in first half of explosion)
                    if (progress < 0.5) {
                        // Damage player
                        const distToPlayer = Math.sqrt(
                            Math.pow(explosion.x - player.x, 2) + 
                            Math.pow(explosion.y - player.y, 2)
                        );
                        
                        if (distToPlayer < explosion.radius) {
                            // Damage proportional to distance
                            const damage = Math.round(explosion.damage * (1 - distToPlayer / explosion.radius));
                            if (damage > 0) {
                                lives -= damage;
                                if (lives <= 0) {
                                    gameOver();
                                }
                            }
                        }
                        
                        // Damage enemies
                        enemies.forEach((enemy, eIndex) => {
                            const distToEnemy = Math.sqrt(
                                Math.pow(explosion.x - enemy.x, 2) + 
                                Math.pow(explosion.y - enemy.y, 2)
                            );

                            if (checkForSelfDestruction(enemy)) {
                                return; 
                            }
                            
                            if (distToEnemy < explosion.radius) {
                                // Damage proportional to distance
                                const damage = Math.round(explosion.damage * (1 - distToEnemy / explosion.radius));
                                if (damage > 0) {
                                    enemy.health -= damage;
                                    
                                    if (enemy.health <= 0) {
                                        const pointsEarned = enemy.value * scoreMultiplier;
                                        score += pointsEarned;
                                        scoreDisplay.textContent = `Score: ${score}`;
                                        
                                        // Add point animation
                                        multiplierAnimations.push({
                                            x: enemy.x,
                                            y: enemy.y,
                                            text: `+${pointsEarned}`,
                                            color: '#0f0',
                                            startTime: Date.now()
                                        });

                                         if (Math.random() <= 0.05) {
                                            spawnLifePowerup(enemy.x, enemy.y);
                                            
                                            // Show life dropped message
                                            multiplierAnimations.push({
                                                x: enemy.x,
                                                y: enemy.y - 20,
                                                text: "LIFE!",
                                                color: '#0f0',
                                                startTime: Date.now()
                                            });
                                        }
                                        
                                        // Add this line to check for chain reaction:
                                        checkForChainReaction(enemy.x, enemy.y, enemy.width * 2);
                                        
                                        // Create normal explosion
                                        createExplosion(enemy.x, enemy.y, enemy.width * 3, 1);
                                        enemies.splice(eIndex, 1);

                                    }
                                }
                            }
                        });
                    }
                }
            });
            
            // Update and draw bonus ships
            bonusShips.forEach((bonus, bIndex) => {
                if (bonus.collected) return;
                
                // Move based on pattern
                switch(bonus.pattern) {
                    case 0: // Straight down
                        bonus.y += bonus.speed;
                        break;
                    case 1: // Slight wave
                        bonus.y += bonus.speed;
                        bonus.x += Math.sin(bonus.patternStep) * 1.5;
                        bonus.patternStep += 0.05;
                        break;
                }
                
                // Draw bonus ship
                ctx.fillStyle = bonus.color;
                ctx.beginPath();
                ctx.moveTo(bonus.x, bonus.y - bonus.height/2);
                ctx.lineTo(bonus.x + bonus.width/2, bonus.y + bonus.height/2);
                ctx.lineTo(bonus.x - bonus.width/2, bonus.y + bonus.height/2);
                ctx.closePath();
                ctx.fill();
                
                // Draw multiplier text
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`x${bonus.multiplier}`, bonus.x, bonus.y + bonus.height/2 + 15);
                ctx.textAlign = 'left';
                
                // Check collision with player
                if (checkCollision(
                    bonus.x - bonus.width/2, bonus.y - bonus.height/2, bonus.width, bonus.height,
                    player.x - player.width/2, player.y - player.height/2, player.width, player.height
                )) {
                    bonus.collected = true;
                    scoreMultiplier = bonus.multiplier;
                    multiplierActive = true;
                    multiplierEndTime = Date.now() + 10000; // 10 seconds
                    
                    // Add multiplier animation
                    multiplierAnimations.push({
                        x: bonus.x,
                        y: bonus.y,
                        text: `x${bonus.multiplier} Multiplier!`,
                        color: bonus.color,
                        startTime: Date.now()
                    });
                }
                
                // Remove if off screen
                if (bonus.y > canvas.height + bonus.height) {
                    bonusShips.splice(bIndex, 1);
                }
            });
            
            // Update and draw enemies
            enemies.forEach((enemy, eIndex) => {
                // Move based on pattern
                switch(enemy.pattern) {
                    case 0: // Straight down
                        enemy.y += enemy.speed;
                        break;
                    case 1: // Zig-zag
                        enemy.y += enemy.speed;
                        enemy.x += Math.sin(enemy.patternStep) * 2;
                        enemy.patternStep += 0.1;
                        break;
                    case 2: // Circle
                        enemy.y += enemy.speed * 0.5;
                        enemy.x += Math.cos(enemy.patternStep) * 3;
                        enemy.patternStep += 0.05;
                        break;
                }
                
                // Enemy shooting
                const now = Date.now();
                if (now - enemy.lastShot > enemy.shootDelay) {
                    enemy.bullets = enemy.bullets || [];
                    enemy.bullets.push({
                        x: enemy.x,
                        y: enemy.y + enemy.height/2,
                        width: 4,
                        height: 10,
                        speed: 5,
                        color: '#f00'
                    });
                    enemy.lastShot = now;
                }
                
                // Update enemy bullets
                if (enemy.bullets) {
                    enemy.bullets.forEach((bullet, bIndex) => {
                        bullet.y += bullet.speed;
                        
                        // Draw bullet
                        ctx.fillStyle = bullet.color;
                        ctx.fillRect(bullet.x - bullet.width/2, bullet.y, bullet.width, bullet.height);
                        
                        // Check collision with player
                        if (checkCollision(
                            bullet.x - bullet.width/2, bullet.y, bullet.width, bullet.height,
                            player.x - player.width/2, player.y - player.height/2, player.width, player.height
                        )) {
                            enemy.bullets.splice(bIndex, 1);
                            lives--;
                            if (lives <= 0) {
                                gameOver();
                            }
                        }
                        
                        // Remove if off screen
                        if (bullet.y > canvas.height) {
                            enemy.bullets.splice(bIndex, 1);
                        }
                    });
                }
                
                // Draw enemy
                ctx.fillStyle = enemy.color;
                ctx.beginPath();
                ctx.moveTo(enemy.x, enemy.y - enemy.height/2);
                ctx.lineTo(enemy.x + enemy.width/2, enemy.y + enemy.height/2);
                ctx.lineTo(enemy.x - enemy.width/2, enemy.y + enemy.height/2);
                ctx.closePath();
                ctx.fill();
                
                // Draw enemy cockpit
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(enemy.x, enemy.y - 5, 5, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw point value
                ctx.fillStyle = '#fff';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(enemy.points, enemy.x, enemy.y + enemy.height/2 + 12);
                ctx.textAlign = 'left';
                
                // Remove if off screen
                if (enemy.y > canvas.height + enemy.height) {
                    enemies.splice(eIndex, 1);
                }
            });
            
            // Update and draw player bullets
            player.bullets.forEach((bullet, bIndex) => {
                bullet.y -= bullet.speed;
                
                // Draw bullet
                ctx.fillStyle = bullet.color;
                ctx.fillRect(bullet.x - bullet.width/2, bullet.y, bullet.width, bullet.height);
                
                // Check collision with enemies
                enemies.forEach((enemy, eIndex) => {
                    if (checkCollision(
                        bullet.x - bullet.width/2, bullet.y, bullet.width, bullet.height,
                        enemy.x - enemy.width/2, enemy.y - enemy.height/2, enemy.width, enemy.height
                    )) {
                        player.bullets.splice(bIndex, 1);
                        enemy.health--;
                        
                         if (enemy.health <= 0) {
                            const pointsEarned = enemy.value * scoreMultiplier;
                            score += pointsEarned;
                            scoreDisplay.textContent = `Score: ${score}`;
                            
                            // Add point animation
                            multiplierAnimations.push({
                                x: enemy.x,
                                y: enemy.y,
                                text: `+${pointsEarned}`,
                                color: '#0f0',
                                startTime: Date.now()
                            });
                            
                             if (Math.random() <= 0.01) {
                                spawnLifePowerup(enemy.x, enemy.y);
                                
                                // Show life dropped message
                                multiplierAnimations.push({
                                    x: enemy.x,
                                    y: enemy.y - 20,
                                    text: "LIFE!",
                                    color: '#0f0',
                                    startTime: Date.now()
                                });
                            }

                            // Add this line to check for chain reaction:
                            checkForChainReaction(enemy.x, enemy.y, enemy.width * 2);
                            
                            // Create explosion
                            createExplosion(enemy.x, enemy.y, enemy.width * 3, 1);
                            enemies.splice(eIndex, 1);
                        }
                    }
                });
                
                // Check collision with bonus ships
                bonusShips.forEach((bonus, bIndex) => {
                    if (!bonus.collected && checkCollision(
                        bullet.x - bullet.width/2, bullet.y, bullet.width, bullet.height,
                        bonus.x - bonus.width/2, bonus.y - bonus.height/2, bonus.width, bonus.height
                    )) {
                        player.bullets.splice(bIndex, 1);
                        bonus.collected = true;
                        scoreMultiplier = bonus.multiplier;
                        multiplierActive = true;
                        multiplierEndTime = Date.now() + 10000; // 10 seconds
                        
                        // Add multiplier animation
                        multiplierAnimations.push({
                            x: bonus.x,
                            y: bonus.y,
                            text: `x${bonus.multiplier} Multiplier!`,
                            color: bonus.color,
                            startTime: Date.now()
                        });
                    }
                });
                
                // Remove if off screen
                if (bullet.y < 0) {
                    player.bullets.splice(bIndex, 1);
                }
            });
            
            // Draw player
            player.draw();
            
            // Draw lives
            ctx.fillStyle = '#fff';
            ctx.font = '20px Arial';
            ctx.fillText(`Lives: ${lives}`, 20, 30);
            
            // Draw multiplier status
            if (multiplierActive) {
                const timeLeft = Math.ceil((multiplierEndTime - Date.now()) / 1000);
                ctx.fillStyle = '#ff0';
                ctx.font = '20px Arial';
                ctx.fillText(`Multiplier: x${scoreMultiplier} (${timeLeft}s)`, canvas.width - 250, 30);
            }
            
            // Draw and update multiplier animations
            multiplierAnimations.forEach((anim, index) => {
                const elapsed = Date.now() - anim.startTime;
                const progress = elapsed / 1000; // 1 second duration
                
                if (progress > 1) {
                    multiplierAnimations.splice(index, 1);
                } else {
                    ctx.fillStyle = anim.color;
                    ctx.font = '24px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(anim.text, anim.x, anim.y - progress * 50);
                    ctx.textAlign = 'left';
                }
            });
            
            // Continue game loop
            requestAnimationFrame(gameLoop);
        }

        function checkCollision(x1, y1, w1, h1, x2, y2, w2, h2) {
            return x1 < x2 + w2 &&
                   x1 + w1 > x2 &&
                   y1 < y2 + h2 &&
                   y1 + h1 > y2;
        }

        function gameOver() {
            gameRunning = false;
            gameOverDisplay.style.display = 'block';
            gameOverDisplay.querySelector('span').textContent = `Score: ${score}`;
            
            // Create big explosion at player position
            createExplosion(player.x, player.y, 100, 0);
        }
    </script>
</body>
</html>
