<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="../../icon.jpg" type="image/x-icon">
    <title>Pyramid</title>
    <link href="https://fonts.googleapis.com/css2?family=Jura:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #0c0c14;
            --container-bg: #1a1a2e;
            --border-color: #2d2d5a;
            --text-color: #e6e6ff;
            --highlight-color: #ffd700;
            --gold-glow: #ffd700;
            --button-bg: #2a2a4a;
            --button-hover: #3a3a6a;
            --inventory-bg: #25254a;
            --success-color: #00ff9d;
            --danger-color: #ff4d4d;
            --puzzle-bg: #1e1e3a;
            --timer-color: #ff6b6b;
            --level-color: #4cc9f0;
            --sand-color: #d4b483;
            --hieroglyph-color: #a5a5d9;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Jura', sans-serif;
            background: linear-gradient(135deg, #0c0c14 0%, #1a1a2e 100%);
            color: var(--text-color);
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
            background-image: 
                radial-gradient(circle at 10% 20%, #2a2a4a 0%, transparent 50%),
                radial-gradient(circle at 90% 80%, #3a3a6a 0%, transparent 50%);
            min-height: 100vh;
            position: relative;
            overflow-x: hidden;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" opacity="0.03"><text x="20" y="60" font-size="40" fill="%23ffffff">ìÄÄ</text></svg>');
            pointer-events: none;
            z-index: -1;
        }

        button {
            font-family: 'Jura', sans-serif;
            font-weight: 600;
            letter-spacing: 0.5px;
            text-transform: uppercase;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 3px solid var(--border-color);
            position: relative;
        }

        header::after {
            content: 'ìÄÄìÉíìÇÄ';
            position: absolute;
            bottom: -15px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 24px;
            color: var(--highlight-color);
            background: var(--bg-color);
            padding: 0 15px;
            letter-spacing: 10px;
        }

        h1 {
            margin: 0;
            font-size: 3rem;
            color: var(--highlight-color);
            text-shadow: 
                0 0 20px rgba(255, 215, 0, 0.5),
                2px 2px 0 #000,
                4px 4px 0 rgba(0, 0, 0, 0.3);
            font-weight: 700;
            letter-spacing: 2px;
            position: relative;
        }

        h1::before {
            content: 'ìãπ';
            position: absolute;
            left: -40px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 24px;
        }

        h1::after {
            content: 'ìÜÑ';
            position: absolute;
            right: -40px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 24px;
        }

        #game-info {
            display: flex;
            gap: 20px;
            background: linear-gradient(135deg, rgba(42, 42, 74, 0.8), rgba(58, 58, 106, 0.8));
            padding: 12px 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 2px solid var(--border-color);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        #timer, #level {
            font-weight: 700;
            font-size: 1.1rem;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #timer {
            color: var(--timer-color);
        }

        #timer span {
            font-size: 0.9rem;
            opacity: 0.8;
            margin-bottom: 5px;
        }

        #level {
            color: var(--level-color);
        }

        #level span {
            font-size: 0.9rem;
            opacity: 0.8;
            margin-bottom: 5px;
        }

        #game-container {
            background: linear-gradient(135deg, var(--container-bg), #161629);
            border: 3px solid var(--border-color);
            padding: 30px;
            border-radius: 15px;
            min-height: 500px;
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            margin-bottom: 30px;
            position: relative;
            overflow: hidden;
        }

        #game-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, 
                transparent, 
                var(--highlight-color),
                transparent);
        }

        #text-display {
            min-height: 350px;
            font-size: 1.2rem;
            overflow-y: auto;
            max-height: 60vh;
            padding: 20px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            margin-bottom: 20px;
            line-height: 1.8;
            position: relative;
        }

        #text-display::-webkit-scrollbar {
            width: 10px;
        }

        #text-display::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
        }

        #text-display::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, var(--highlight-color), var(--border-color));
            border-radius: 5px;
        }

        .message {
            margin-bottom: 20px;
            padding: 15px;
            border-radius: 8px;
            background: rgba(42, 42, 74, 0.3);
            border-left: 4px solid var(--highlight-color);
            animation: slideIn 0.3s ease-out;
            position: relative;
        }

        .message::before {
            content: '¬ª';
            position: absolute;
            left: -15px;
            color: var(--highlight-color);
            font-weight: bold;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        #options-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
            margin-top: 25px;
        }

        .option-btn {
            background: linear-gradient(135deg, var(--button-bg), #1a1a3a);
            color: var(--text-color);
            border: 2px solid var(--border-color);
            padding: 18px 25px;
            text-align: left;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border-radius: 10px;
            font-size: 1.1rem;
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(5px);
        }

        .option-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, 
                transparent, 
                rgba(255, 215, 0, 0.1), 
                transparent);
            transition: left 0.5s;
        }

        .option-btn:hover {
            background: linear-gradient(135deg, var(--button-hover), #2a2a5a);
            transform: translateY(-3px) scale(1.02);
            box-shadow: 
                0 8px 25px rgba(0, 0, 0, 0.3),
                0 0 0 1px rgba(255, 215, 0, 0.3);
        }

        .option-btn:hover::before {
            left: 100%;
        }

        .option-btn:active {
            transform: translateY(0) scale(1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .option-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .inventory {
            margin-top: 25px;
            padding: 20px;
            background: linear-gradient(135deg, var(--inventory-bg), #1e1e3a);
            border: 2px dashed var(--border-color);
            border-radius: 10px;
            position: relative;
        }

        .inventory::before {
            content: 'ìçù';
            position: absolute;
            top: -15px;
            left: 20px;
            background: var(--container-bg);
            padding: 0 10px;
            font-size: 20px;
            color: var(--highlight-color);
        }

        .hidden {
            display: none !important;
        }

        .ending {
            color: var(--highlight-color);
            font-weight: bold;
            margin-top: 30px;
            font-size: 1.5rem;
            padding: 25px;
            border-radius: 10px;
            background: linear-gradient(135deg, rgba(212, 175, 55, 0.1), rgba(106, 90, 205, 0.1));
            text-align: center;
            border: 2px solid var(--highlight-color);
            animation: pulseGlow 2s infinite;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        @keyframes pulseGlow {
            0%, 100% {
                box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
            }
            50% {
                box-shadow: 0 0 40px rgba(255, 215, 0, 0.6);
            }
        }

        .inventory-item {
            display: inline-block;
            margin: 8px;
            padding: 10px 20px;
            background: linear-gradient(135deg, var(--button-bg), #252545);
            border-radius: 25px;
            transition: all 0.3s;
            border: 1px solid var(--border-color);
            font-weight: 500;
            position: relative;
            overflow: hidden;
        }

        .inventory-item::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, 
                transparent, 
                rgba(255, 215, 0, 0.2), 
                transparent);
            transition: left 0.5s;
        }

        .inventory-item:hover {
            background: linear-gradient(135deg, var(--button-hover), #353565);
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .inventory-item:hover::after {
            left: 100%;
        }

        .inventory-item.important {
            background: linear-gradient(135deg, #4a3c00, #7d6b00);
            border-color: var(--highlight-color);
        }

        .inventory-item.danger {
            background: linear-gradient(135deg, #5a0000, #8b0000);
            border-color: var(--danger-color);
        }

        .important {
            color: var(--highlight-color);
            font-weight: 700;
            text-shadow: 0 0 5px rgba(255, 215, 0, 0.5);
        }

        .puzzle {
            border-left: 4px solid var(--highlight-color);
            padding: 15px 20px;
            margin: 20px 0;
            background: linear-gradient(90deg, rgba(212, 175, 55, 0.1), transparent);
            border-radius: 0 10px 10px 0;
            position: relative;
        }

        .puzzle::before {
            content: 'ìÜ£';
            position: absolute;
            left: -25px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 20px;
            background: var(--container-bg);
            padding: 5px;
        }

        .danger {
            color: var(--danger-color);
            animation: pulse 1.5s infinite;
            font-weight: 700;
        }

        .success {
            color: var(--success-color);
            font-weight: 700;
            text-shadow: 0 0 5px rgba(0, 255, 157, 0.5);
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.6;
            }
        }

        .puzzle-section {
            background: linear-gradient(135deg, var(--puzzle-bg), #161629);
            border: 3px solid var(--border-color);
            padding: 30px;
            border-radius: 15px;
            margin-top: 30px;
            position: relative;
            overflow: hidden;
        }

        .puzzle-section::before {
            content: 'ìÉíìÜ£ìãπ';
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 24px;
            opacity: 0.1;
            letter-spacing: 10px;
        }

        .puzzle-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin: 30px 0;
        }

        .totem-piece {
            height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #2a2a4a, #1a1a3a);
            border-radius: 12px;
            font-size: 3rem;
            cursor: pointer;
            border: 3px solid var(--border-color);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .totem-piece::before {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(45deg, 
                transparent 30%, 
                rgba(255, 215, 0, 0.1) 50%, 
                transparent 70%);
            opacity: 0;
            transition: opacity 0.3s;
        }

        .totem-piece:hover {
            background: linear-gradient(135deg, #3a3a6a, #2a2a5a);
            transform: scale(1.05) rotate(5deg);
            box-shadow: 
                0 8px 25px rgba(0, 0, 0, 0.4),
                0 0 0 2px var(--highlight-color);
        }

        .totem-piece:hover::before {
            opacity: 1;
        }

        .totem-piece.selected {
            border-color: var(--highlight-color);
            background: linear-gradient(135deg, #4a4a7a, #3a3a6a);
            box-shadow: 
                0 0 20px rgba(255, 215, 0, 0.5),
                inset 0 0 20px rgba(255, 215, 0, 0.2);
            animation: selectedPulse 1s infinite;
            transform: scale(1.1);
        }

        @keyframes selectedPulse {
            0%, 100% {
                box-shadow: 
                    0 0 20px rgba(255, 215, 0, 0.5),
                    inset 0 0 20px rgba(255, 215, 0, 0.2);
            }
            50% {
                box-shadow: 
                    0 0 30px rgba(255, 215, 0, 0.8),
                    inset 0 0 30px rgba(255, 215, 0, 0.3);
            }
        }

        .puzzle-controls {
            display: flex;
            gap: 15px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 15px 30px;
            background: linear-gradient(135deg, var(--button-bg), #1a1a3a);
            color: var(--text-color);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            cursor: pointer;
            font-weight: 700;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, 
                transparent, 
                rgba(255, 255, 255, 0.1), 
                transparent);
            transition: left 0.5s;
        }

        .btn:hover {
            background: linear-gradient(135deg, var(--button-hover), #2a2a5a);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        .btn:hover::before {
            left: 100%;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--highlight-color), #ffed4a);
            color: #000;
            border-color: #ffd700;
            font-weight: 800;
        }

        .btn-primary:hover {
            background: linear-gradient(135deg, #ffed4a, #ffd700);
            box-shadow: 0 6px 20px rgba(255, 215, 0, 0.4);
        }

        .fade-in {
            animation: fadeIn 0.8s ease-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .level-progress {
            display: flex;
            justify-content: space-between;
            margin: 25px 0;
            padding: 20px;
            background: linear-gradient(135deg, var(--inventory-bg), #1e1e3a);
            border-radius: 15px;
            border: 2px solid var(--border-color);
            position: relative;
        }

        .level-progress::before {
            content: 'Progress';
            position: absolute;
            top: -12px;
            left: 20px;
            background: var(--container-bg);
            padding: 0 15px;
            font-weight: 700;
            color: var(--highlight-color);
            letter-spacing: 1px;
        }

        .level-circle {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-weight: 800;
            border: 3px solid var(--border-color);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            background: var(--button-bg);
            position: relative;
            overflow: hidden;
        }

        .level-circle::before {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(45deg, 
                transparent 40%, 
                rgba(255, 215, 0, 0.2) 50%, 
                transparent 60%);
            opacity: 0;
            transition: opacity 0.3s;
        }

        .level-circle.current {
            border-color: var(--highlight-color);
            background: linear-gradient(135deg, var(--highlight-color), #ffed4a);
            color: #000;
            transform: scale(1.3);
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
        }

        .level-circle.current::before {
            opacity: 1;
            animation: shine 2s infinite;
        }

        @keyframes shine {
            0% {
                transform: translateX(-100%);
            }
            100% {
                transform: translateX(100%);
            }
        }

        .level-circle.completed {
            border-color: var(--success-color);
            background: linear-gradient(135deg, var(--success-color), #4df0b0);
            color: #000;
            box-shadow: 0 0 20px rgba(0, 255, 157, 0.3);
        }

        .level-circle span {
            font-size: 0.8rem;
            opacity: 0.8;
            margin-top: 2px;
        }

        .section-title {
            color: var(--highlight-color);
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid var(--border-color);
            font-size: 1.8rem;
            font-weight: 700;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            position: relative;
        }

        .section-title::after {
            content: 'ìã¥';
            position: absolute;
            right: 0;
            font-size: 24px;
            opacity: 0.5;
        }

        .health-bar {
            width: 200px;
            height: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid var(--border-color);
            margin: 10px 0;
        }

        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--success-color), #00cc7a);
            transition: width 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .health-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, 
                transparent, 
                rgba(255, 255, 255, 0.2), 
                transparent);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% {
                transform: translateX(-100%);
            }
            100% {
                transform: translateX(100%);
            }
        }

        .warning {
            animation: warningFlash 0.5s infinite;
        }

        @keyframes warningFlash {
            0%, 100% {
                background: linear-gradient(135deg, #5a0000, #8b0000);
            }
            50% {
                background: linear-gradient(135deg, #8b0000, #b30000);
            }
        }

        .hint {
            background: linear-gradient(135deg, rgba(76, 201, 240, 0.1), transparent);
            border-left: 4px solid var(--level-color);
            padding: 15px;
            margin: 15px 0;
            border-radius: 0 8px 8px 0;
            font-style: italic;
            opacity: 0.9;
        }

        .trap {
            background: linear-gradient(135deg, rgba(255, 77, 77, 0.1), transparent);
            border-left: 4px solid var(--danger-color);
            padding: 15px;
            margin: 15px 0;
            border-radius: 0 8px 8px 0;
        }

        @media (max-width: 768px) {
            #options-container {
                grid-template-columns: 1fr;
            }
            
            .puzzle-grid {
                grid-template-columns: repeat(3, 1fr);
            }
            
            .level-progress {
                flex-wrap: wrap;
                gap: 15px;
                justify-content: center;
            }
            
            .level-circle {
                width: 50px;
                height: 50px;
                font-size: 0.9rem;
            }
            
            .level-circle.current {
                transform: scale(1.2);
            }
            
            h1 {
                font-size: 2.2rem;
            }
            
            #game-info {
                flex-direction: column;
                gap: 10px;
            }
        }
    </style>
</head>

<body>
    <header>
        <h1>PYRAMID</h1>
        <div id="game-info">
            <div id="timer">
                <span>SANDS OF TIME</span>
                20:00
            </div>
            <div id="level">
                <span>CHAMBER</span>
                1/5
            </div>
        </div>
    </header>

    <div id="game-container" class="fade-in">
        <div class="level-progress" id="level-progress"></div>
        
        <div id="text-display">
            <div class="message">
                <h2>ìã¥ The Great Pyramid</h2>
                <p>You stand before the massive stone entrance of the ancient pyramid. The air is thick with the scent of centuries-old sand and mystery. Hieroglyphs cover the walls, their stories whispering in the still air...</p>
                <div class="health-bar">
                    <div id="health-fill" class="health-fill" style="width: 100%"></div>
                </div>
            </div>
        </div>
        
        <div id="options-container"></div>

        <div id="puzzle-section" class="puzzle-section hidden">
            <h3 class="section-title">ìÜ£ Ancient Totem Puzzle</h3>
            <div id="puzzle-description" class="puzzle"></div>
            <div class="puzzle-grid" id="puzzle-grid"></div>
            <div class="puzzle-controls">
                <button class="btn" id="shuffle-totems">Shuffle Symbols</button>
                <button class="btn btn-primary" id="submit-puzzle">Submit Solution</button>
                <button class="btn" id="close-puzzle">Close Puzzle</button>
            </div>
            <div id="puzzle-hint" class="hint hidden"></div>
        </div>

        <div id="inventory-display" class="inventory hidden">
            <strong>ìçù Inventory:</strong> <span id="inventory-items"></span>
        </div>
    </div>

    <script>
        const gameState = {
            currentLevel: 1,
            totalLevels: 5,
            inventory: [],
            hasTorch: false,
            hasKey: false,
            puzzleSolved: false,
            timeLeft: 900, // 15 minutes (increased difficulty)
            timerInterval: null,
            selectedTotem: null,
            currentPuzzle: null,
            health: 100,
            difficulty: 1,
            puzzlesAttempted: 0,
            hintsUsed: 0,
            trapsTriggered: 0,
            visitedRooms: new Set([1])
        };

        const levels = {
            1: {
                name: "Entrance Hall",
                description: `You stand before the massive stone entrance of the ancient pyramid. The air is thick with the scent of centuries-old sand and mystery. Hieroglyphs cover the walls, their stories whispering in the still air. A heavy stone door blocks your path forward.`,
                options: [
                    { text: "ìã¥ Examine the hieroglyphs", action: "examineWalls" },
                    { text: "ìçù Search the entrance floor", action: "searchEntrance" },
                    { text: "üî• Light a torch (if you have one)", action: "lightTorch" },
                    { text: "üö™ Try the stone door", action: "tryDoor" }
                ],
                traps: [
                    { chance: 0.2, damage: 10, message: "A hidden pressure plate triggers! Darts shoot from the walls!" },
                    { chance: 0.1, damage: 15, message: "The floor collapses slightly beneath you!" }
                ]
            },
            2: {
                name: "Antechamber of Echoes",
                description: `The corridor opens into a circular chamber with walls that seem to absorb light. Three stone statues stand in alcoves, their eyes seeming to follow your movement. Strange echoes bounce around the room.`,
                options: [
                    { text: "üóø Examine the statues", action: "examineStatues" },
                    { text: "üëÇ Listen to the echoes", action: "listenEchoes" },
                    { text: "üîç Search the corridor floor", action: "searchCorridor" },
                    { text: "üö™ Approach the puzzle door", action: "approachPuzzleDoor" }
                ],
                traps: [
                    { chance: 0.3, damage: 20, message: "One of the statues animates and attacks!" },
                    { chance: 0.2, damage: 15, message: "A gas trap releases sleeping powder!" }
                ]
            },
            3: {
                name: "Sun Chamber",
                description: `Light filters through cracks in the ceiling, illuminating complex mechanisms on the walls. This appears to be an ancient observatory. A large door with a sun symbol blocks your path.`,
                options: [
                    { text: "üßÆ Study the wall equations", action: "studyWalls" },
                    { text: "‚öôÔ∏è Investigate mechanical devices", action: "investigateDevices" },
                    { text: "üîç Search the chamber", action: "searchChamber" },
                    { text: "üß© Examine the sun puzzle", action: "examinePuzzle" }
                ],
                traps: [
                    { chance: 0.4, damage: 25, message: "A beam of concentrated sunlight scorches you!" },
                    { chance: 0.3, damage: 20, message: "The floor tilts, dropping you into a pit!" }
                ]
            },
            4: {
                name: "Pharaoh's Passage",
                description: `Golden sarcophagi line the walls of this ornate hall. The air is heavy with incense and decay. A massive door with a scarab symbol requires a specific key to open.`,
                options: [
                    { text: "‚ö∞Ô∏è Examine the sarcophagi", action: "examineSarcophagi" },
                    { text: "üîë Search for the scarab key", action: "searchForKey" },
                    { text: "üîç Study the final puzzle hints", action: "studyFinalPuzzle" },
                    { text: "üö™ Approach the sun door", action: "approachSunDoor" }
                ],
                traps: [
                    { chance: 0.5, damage: 30, message: "The sarcophagi release a swarm of scarabs!" },
                    { chance: 0.4, damage: 25, message: "A poison dart trap activates!" }
                ]
            },
            5: {
                name: "Inner Sanctum",
                description: `The treasure room glitters with unimaginable wealth, but a final puzzle protects the pharaoh's greatest treasure. An escape passage is visible behind a tapestry.`,
                options: [
                    { text: "üíé Examine the treasure", action: "examineTreasure" },
                    { text: "üß© Approach the final challenge", action: "approachFinalChallenge" },
                    { text: "üí∞ Gather some treasure", action: "gatherTreasure" },
                    { text: "üö™ Study the escape route", action: "studyEscape" }
                ],
                traps: [
                    { chance: 0.6, damage: 40, message: "The treasure is cursed! It drains your life force!" },
                    { chance: 0.5, damage: 35, message: "A guardian spirit materializes and attacks!" }
                ]
            }
        };

        const puzzles = {
            3: {
                name: "Symbol Alignment Puzzle",
                description: "Arrange the Egyptian symbols so that matching pairs are adjacent in the pattern shown on the wall. Each move swaps two adjacent symbols.",
                solution: ["üêç", "üêç", "ü¶Ö", "ü¶Ö", "‚ò•", "‚ò•", "ìÉí", "ìÉí", "ìÇÄ", "ìÇÄ", "ìäπ", "ìäπ"],
                pieces: ["üêç", "ü¶Ö", "‚ò•", "ìÉí", "ìÇÄ", "ìäπ", "üêç", "ü¶Ö", "‚ò•", "ìÉí", "ìÇÄ", "ìäπ"],
                hints: [
                    "Look for matching pairs first.",
                    "The wall shows the order: Ankh, Eye, Bird, Snake, Jackal, God",
                    "Try to complete one pair at a time."
                ],
                attempts: 0,
                maxAttempts: 10
            },
            5: {
                name: "Final Ascension Puzzle",
                description: "Arrange the symbols in the divine order of the Egyptian pantheon: Ra (sun) first, then Anubis (jackal), Horus (falcon), and finally the protective symbols.",
                solution: ["ìÇÄ", "ìÉí", "ìäπ", "üêç", "ü¶Ö", "‚ò•", "ìÇÄ", "ìÉí", "ìäπ", "üêç", "ü¶Ö", "‚ò•"],
                pieces: ["üêç", "ü¶Ö", "‚ò•", "ìÉí", "ìÇÄ", "ìäπ", "ìäπ", "ìÇÄ", "ìÉí", "‚ò•", "ü¶Ö", "üêç"],
                hints: [
                    "The divine order is: Sun, Jackal, God, Snake, Bird, Ankh",
                    "Each symbol appears exactly twice.",
                    "Work from top-left to bottom-right."
                ],
                attempts: 0,
                maxAttempts: 8
            }
        };

        function initGame() {
            updateLevelProgress();
            displayScene();
            startTimer();
            updateHealthDisplay();

            document.getElementById('shuffle-totems').addEventListener('click', shufflePuzzle);
            document.getElementById('submit-puzzle').addEventListener('click', checkPuzzleSolution);
            document.getElementById('close-puzzle').addEventListener('click', closePuzzle);
        }

        function updateLevelProgress() {
            const progress = document.getElementById('level-progress');
            progress.innerHTML = '';

            for (let i = 1; i <= gameState.totalLevels; i++) {
                const circle = document.createElement('div');
                circle.className = 'level-circle';
                if (i === gameState.currentLevel) {
                    circle.classList.add('current');
                } else if (i < gameState.currentLevel) {
                    circle.classList.add('completed');
                }
                
                const levelNum = document.createElement('div');
                levelNum.textContent = i;
                circle.appendChild(levelNum);
                
                const levelName = document.createElement('span');
                levelName.textContent = levels[i].name.substring(0, 3);
                circle.appendChild(levelName);
                
                circle.title = levels[i].name;
                progress.appendChild(circle);
            }

            document.getElementById('level').innerHTML = `<span>CHAMBER</span>${gameState.currentLevel}/5`;
        }

        function displayScene() {
            const scene = levels[gameState.currentLevel];
            const textDisplay = document.getElementById('text-display');
            
            let html = `<div class="message">
                <h2>ìã¥ ${scene.name}</h2>
                <p>${scene.description}</p>`;
            
            if (gameState.health < 50) {
                html += `<div class="danger">‚ö†Ô∏è Your health is low: ${gameState.health}%</div>`;
            }
            
            if (gameState.timeLeft < 300) {
                html += `<div class="danger">‚è≥ Time is running out!</div>`;
            }
            
            html += `</div>`;
            
            textDisplay.innerHTML += html;
            updateOptions();
            updateLevelProgress();
            textDisplay.scrollTop = textDisplay.scrollHeight;
            
            gameState.visitedRooms.add(gameState.currentLevel);
        }

        function updateOptions() {
            const container = document.getElementById('options-container');
            container.innerHTML = '';

            const scene = levels[gameState.currentLevel];
            
            scene.options.forEach(option => {
                const btn = document.createElement('button');
                btn.className = 'option-btn';
                btn.innerHTML = option.text;
                btn.addEventListener('click', () => handleAction(option.action));
                
                if (option.text.includes("Light a torch") && !gameState.hasTorch) {
                    btn.disabled = true;
                    btn.title = "You need to find a torch first";
                }
                
                if (option.text.includes("key") && gameState.hasKey) {
                    btn.disabled = true;
                    btn.title = "You already have the key";
                }
                
                container.appendChild(btn);
            });
        }

        function addMessage(message, type = 'normal') {
            const textDisplay = document.getElementById('text-display');
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message';
            
            if (type === 'danger') messageDiv.classList.add('trap');
            if (type === 'success') messageDiv.classList.add('success');
            if (type === 'hint') messageDiv.classList.add('hint');
            
            messageDiv.innerHTML = message;
            textDisplay.appendChild(messageDiv);
            textDisplay.scrollTop = textDisplay.scrollHeight;
        }

        function checkForTrap() {
            const scene = levels[gameState.currentLevel];
            if (!scene.traps) return false;
            
            for (const trap of scene.traps) {
                if (Math.random() < trap.chance * gameState.difficulty) {
                    gameState.trapsTriggered++;
                    gameState.health = Math.max(0, gameState.health - trap.damage);
                    updateHealthDisplay();
                    
                    addMessage(`<span class="danger">‚ö†Ô∏è TRAP! ${trap.message} You lose ${trap.damage}% health!</span>`, 'danger');
                    
                    if (gameState.health <= 0) {
                        setTimeout(() => endGame(false, "You succumbed to the pyramid's traps."), 1000);
                    }
                    
                    return true;
                }
            }
            return false;
        }

        function handleAction(action) {
            if (checkForTrap() && action !== 'lightTorch') return;
            
            switch (action) {
                case 'examineWalls':
                    examineWalls();
                    break;
                case 'tryDoor':
                    tryDoor();
                    break;
                case 'searchEntrance':
                    searchEntrance();
                    break;
                case 'lightTorch':
                    lightTorch();
                    break;
                case 'examineStatues':
                    examineStatues();
                    break;
                case 'listenEchoes':
                    listenEchoes();
                    break;
                case 'approachPuzzleDoor':
                    approachPuzzleDoor();
                    break;
                case 'searchCorridor':
                    searchCorridor();
                    break;
                case 'examinePuzzle':
                    examinePuzzle();
                    break;
                case 'studyWalls':
                    studyWalls();
                    break;
                case 'investigateDevices':
                    investigateDevices();
                    break;
                case 'searchChamber':
                    searchChamber();
                    break;
                case 'examineSarcophagi':
                    examineSarcophagi();
                    break;
                case 'approachSunDoor':
                    approachSunDoor();
                    break;
                case 'studyFinalPuzzle':
                    studyFinalPuzzle();
                    break;
                case 'searchForKey':
                    searchForKey();
                    break;
                case 'examineTreasure':
                    examineTreasure();
                    break;
                case 'approachFinalChallenge':
                    approachFinalChallenge();
                    break;
                case 'gatherTreasure':
                    gatherTreasure();
                    break;
                case 'studyEscape':
                    studyEscape();
                    break;
            }
        }

        function examineWalls() {
            const foundKey = Math.random() < 0.3;
            const sequence = "ìÇÄ ‚Üí ìÉí ‚Üí ìäπ ‚Üí üêç ‚Üí ü¶Ö ‚Üí ‚ò•";
            
            addMessage(`The hieroglyphs tell the story of Pharaoh Amenhotep III, who built this pyramid to protect his soul's journey to the afterlife. 
            One panel shows a sequence: <span class="important">${sequence}</span>. This might be important for later puzzles.`);
            
            if (!gameState.hasKey && foundKey) {
                gameState.hasKey = true;
                gameState.inventory.push('Ancient Bronze Key');
                addMessage(`<span class="success">ìçù You found an ancient bronze key hidden behind a loose stone!</span>`, 'success');
                updateInventory();
            }
            
            if (Math.random() < 0.4) {
                gameState.difficulty = Math.min(2, gameState.difficulty + 0.1);
                addMessage(`<div class="hint">The pyramid seems to grow more dangerous as you learn its secrets...</div>`);
            }
        }

        function tryDoor() {
            if (gameState.currentLevel === 1) {
                if (gameState.hasKey) {
                    addMessage(`The bronze key fits perfectly! The stone door slowly grinds open, revealing a dark corridor beyond.`, 'success');
                    setTimeout(() => advanceLevel(), 1500);
                } else {
                    addMessage(`<span class="danger">The door is sealed tight. You need to find a key first.</span>`);
                }
            }
        }

        function searchEntrance() {
            if (Math.random() < 0.5 && !gameState.hasTorch) {
                gameState.hasTorch = true;
                gameState.inventory.push('Oil Torch');
                addMessage(`<span class="success">üî• You find an oil torch and a small flask of oil! This will help you see in the dark.</span>`, 'success');
                updateInventory();
            } else {
                addMessage(`You search thoroughly but find nothing of value in the entrance.`);
            }
        }

        function lightTorch() {
            if (gameState.hasTorch) {
                addMessage(`You light your torch. The chamber illuminates, revealing hidden details in the hieroglyphs. The torch flickers ominously...`);
                gameState.difficulty *= 0.9; // Slight difficulty reduction with light
            } else {
                addMessage(`<span class="danger">You don't have a torch to light!</span> Search the entrance to find one.`);
            }
        }

        function examineStatues() {
            const puzzleHint = Math.random() < 0.6;
            addMessage(`The statues represent Egyptian gods: Anubis (jackal-headed), Horus (falcon-headed), and Thoth (ibis-headed). 
            Each holds a symbol matching those in the hieroglyphs.`);
            
            if (puzzleHint) {
                addMessage(`<div class="hint">ìÜ£ The statues seem to be pointing in a specific order: left to right, they show Anubis, Horus, then Thoth.</div>`, 'hint');
            }
        }

        function listenEchoes() {
            const pattern = "3 taps, pause, 1 tap, pause, 4 taps...";
            addMessage(`The echoes form a rhythmic pattern: <span class="important">${pattern}</span> 
            This might be a clue for the puzzle ahead.`);
            
            if (Math.random() < 0.3) {
                gameState.inventory.push('Echo Stone');
                addMessage(`<span class="success">You find a strangely resonant stone that amplifies the echoes!</span>`, 'success');
                updateInventory();
            }
        }

        function approachPuzzleDoor() {
            if (gameState.currentLevel === 2) {
                addMessage(`The door has a complex lock with movable symbols. It seems you need to solve a puzzle to proceed.`);
                setTimeout(() => advanceLevel(), 1000);
            }
        }

        function searchCorridor() {
            const items = ['Ancient Papyrus Scroll', 'Gold Coin', 'Ceramic Offering Bowl', 'Lapis Lazuli Bead'];
            if (Math.random() < 0.4 && gameState.inventory.length < 8) {
                const item = items[Math.floor(Math.random() * items.length)];
                gameState.inventory.push(item);
                addMessage(`<span class="success">ìçù You found ${item.toLowerCase()} on the floor!</span>`, 'success');
                updateInventory();
            } else {
                addMessage(`The corridor floor is mostly clear, covered in centuries of dust.`);
            }
        }

        function examinePuzzle() {
            if (gameState.currentLevel === 3) {
                gameState.currentPuzzle = 3;
                openPuzzle();
            }
        }

        function studyWalls() {
            const hint = Math.random() < 0.5;
            addMessage(`The walls are covered in mathematical equations and star charts. They seem to describe the movement of celestial bodies.`);
            
            if (hint) {
                addMessage(`<div class="hint">ìÜ£ The equations suggest that patterns repeat in groups of two...</div>`, 'hint');
            }
        }

        function investigateDevices() {
            addMessage(`The mechanical devices are ancient but precise. They seem to be calculating devices, possibly used for astronomical predictions.`);
            
            if (Math.random() < 0.3) {
                gameState.inventory.push('Bronze Gear');
                addMessage(`<span class="success">ìçù You find a perfectly preserved bronze gear!</span>`, 'success');
                updateInventory();
            }
        }

        function searchChamber() {
            if (Math.random() < 0.4) {
                addMessage(`You find a hidden inscription: "The truth lies in patterns. Match what belongs together. Remember: order matters."`);
            } else {
                addMessage(`The chamber is meticulously clean, with no loose items.`);
            }
        }

        function examineSarcophagi() {
            const findsKey = !gameState.hasKey && Math.random() < 0.4;
            
            addMessage(`The sarcophagi are beautifully crafted with gold inlay. One bears an inscription: 
            "He who seeks the sun's treasure must first walk in darkness and find the key of life."`);
            
            if (findsKey) {
                gameState.hasKey = true;
                gameState.inventory.push('Golden Scarab Key');
                addMessage(`<span class="success">ìçù You found a golden scarab key hidden in one of the sarcophagi!</span>`, 'success');
                updateInventory();
            }
        }

        function approachSunDoor() {
            if (gameState.currentLevel === 4) {
                if (gameState.hasKey) {
                    addMessage(`The golden scarab key fits perfectly! The sun door slowly opens, revealing the treasure vault.`, 'success');
                    setTimeout(() => advanceLevel(), 1500);
                } else {
                    addMessage(`<span class="danger">The sun door is locked! You need a golden scarab key to open it.</span>`);
                }
            }
        }

        function studyFinalPuzzle() {
            addMessage(`The final puzzle shows Egyptian gods in a specific order. The inscription reads: 
            "Ra guides, Anubis judges, Horus protects. Arrange them in their divine order. Remember the sequence from the entrance."`);
        }

        function searchForKey() {
            if (!gameState.hasKey) {
                const findsKey = Math.random() < 0.5;
                addMessage(`You search the hall carefully. The key must be here somewhere...`);
                
                if (findsKey) {
                    gameState.hasKey = true;
                    gameState.inventory.push('Golden Scarab Key');
                    addMessage(`<span class="success">ìçù You found the golden scarab key under one of the sarcophagi!</span>`, 'success');
                    updateInventory();
                }
            } else {
                addMessage(`You already have the key.`);
            }
        }

        function examineTreasure() {
            addMessage(`The Pharaoh's Treasure glitters with unimaginable wealth: gold statues, jeweled crowns, 
            and artifacts from a lost civilization. But it's protected by one final challenge.`);
            
            gameState.difficulty = 2; // Maximum difficulty for final level
        }

        function approachFinalChallenge() {
            if (gameState.currentLevel === 5) {
                gameState.currentPuzzle = 5;
                openPuzzle();
            }
        }

        function gatherTreasure() {
            if (gameState.puzzleSolved) {
                const treasures = ['Gold Coin', 'Silver Bracelet', 'Lapis Lazuli Gem', 'Ivory Statuette', 'Emerald Scarab'];
                const treasure = treasures[Math.floor(Math.random() * treasures.length)];
                gameState.inventory.push(treasure);
                addMessage(`<span class="success">ìçù You carefully add ${treasure.toLowerCase()} to your collection!</span>`, 'success');
                updateInventory();
            } else {
                addMessage(`<span class="danger">You can't take treasure until you solve the final puzzle!</span>`);
            }
        }

        function studyEscape() {
            addMessage(`You notice a hidden passage behind a tapestry. It seems to lead outside. 
            Once you solve the final puzzle, you can escape with the treasure.`);
        }

        function openPuzzle() {
            const puzzle = puzzles[gameState.currentPuzzle];
            const puzzleSection = document.getElementById('puzzle-section');
            puzzleSection.classList.remove('hidden');
            
            document.getElementById('puzzle-description').innerHTML = 
                `<strong>${puzzle.name}</strong><br>${puzzle.description}<br>
                <small>Attempts remaining: ${puzzle.maxAttempts - puzzle.attempts}</small>`;
            
            generatePuzzleGrid(gameState.currentPuzzle);
            showPuzzleHint();
        }

        function showPuzzleHint() {
            const puzzle = puzzles[gameState.currentPuzzle];
            const hintDiv = document.getElementById('puzzle-hint');
            
            if (puzzle.attempts >= 2 && gameState.hintsUsed < puzzle.hints.length) {
                hintDiv.textContent = `üí° Hint: ${puzzle.hints[gameState.hintsUsed]}`;
                hintDiv.classList.remove('hidden');
                gameState.hintsUsed++;
            } else {
                hintDiv.classList.add('hidden');
            }
        }

        function closePuzzle() {
            document.getElementById('puzzle-section').classList.add('hidden');
            gameState.selectedTotem = null;
        }

        function generatePuzzleGrid(level) {
            const grid = document.getElementById('puzzle-grid');
            grid.innerHTML = '';

            const puzzle = puzzles[level];
            if (!puzzle) return;

            const shuffled = [...puzzle.pieces].sort(() => Math.random() - 0.5);

            shuffled.forEach((piece, index) => {
                const btn = document.createElement('button');
                btn.className = 'totem-piece';
                btn.dataset.index = index;
                btn.textContent = piece;
                btn.title = `Position ${index + 1}`;
                btn.addEventListener('click', () => selectTotem(index, btn));
                grid.appendChild(btn);
            });

            gameState._puzzleLayout = shuffled.slice();
        }

        function selectTotem(index, element) {
            if (gameState.selectedTotem == null) {
                gameState.selectedTotem = index;
                element.classList.add('selected');
                return;
            }

            const prevIndex = gameState.selectedTotem;
            const grid = document.getElementById('puzzle-grid');
            const buttons = Array.from(grid.children);

            if (prevIndex === index) {
                buttons[prevIndex].classList.remove('selected');
                gameState.selectedTotem = null;
                return;
            }

            if (areAdjacent(prevIndex, index)) {
                [gameState._puzzleLayout[prevIndex], gameState._puzzleLayout[index]] =
                    [gameState._puzzleLayout[index], gameState._puzzleLayout[prevIndex]];
                
                buttons[prevIndex].textContent = gameState._puzzleLayout[prevIndex];
                buttons[index].textContent = gameState._puzzleLayout[index];
                
                buttons[prevIndex].classList.remove('selected');
                buttons[index].style.boxShadow = '0 0 15px var(--success-color)';
                setTimeout(() => buttons[index].style.boxShadow = '', 300);
            } else {
                buttons[prevIndex].style.boxShadow = '0 0 15px var(--danger-color)';
                setTimeout(() => buttons[prevIndex].style.boxShadow = '', 300);
                addMessage(`<span class="danger">You can only swap adjacent symbols!</span>`, 'danger');
            }

            if (buttons[prevIndex]) buttons[prevIndex].classList.remove('selected');
            gameState.selectedTotem = null;
        }

        function areAdjacent(i1, i2) {
            const cols = 4;
            const r1 = Math.floor(i1 / cols), c1 = i1 % cols;
            const r2 = Math.floor(i2 / cols), c2 = i2 % cols;
            const dr = Math.abs(r1 - r2), dc = Math.abs(c1 - c2);
            return (dr + dc) === 1;
        }

        function shufflePuzzle() {
            const lvl = gameState.currentPuzzle;
            if (!lvl) return;
            const puzzle = puzzles[lvl];
            gameState._puzzleLayout = [...puzzle.pieces].sort(() => Math.random() - 0.5);
            generatePuzzleGrid(lvl);
            puzzle.attempts++;
            showPuzzleHint();
        }

        function checkPuzzleSolution() {
            const lvl = gameState.currentPuzzle;
            if (!lvl) return;
            
            const puzzle = puzzles[lvl];
            const layout = gameState._puzzleLayout || [];
            
            puzzle.attempts++;
            
            if (puzzle.attempts >= puzzle.maxAttempts) {
                addMessage(`<span class="danger">You've run out of attempts! The puzzle resets...</span>`, 'danger');
                gameState.health = Math.max(0, gameState.health - 25);
                updateHealthDisplay();
                shufflePuzzle();
                return;
            }
            
            const ok = layout.length === puzzle.solution.length && 
                       layout.every((v, i) => v === puzzle.solution[i]);
            
            if (ok) {
                gameState.puzzleSolved = true;
                addMessage(`<span class="success">ìÜ£ PUZZLE SOLVED! The door unlocks!</span>`, 'success');
                
                setTimeout(() => {
                    closePuzzle();
                    if (lvl === 5) {
                        endGame(true);
                    } else {
                        advanceLevel();
                    }
                }, 2000);
            } else {
                const correct = layout.reduce((count, val, idx) => 
                    count + (val === puzzle.solution[idx] ? 1 : 0), 0);
                
                addMessage(`<span class="danger">Not solved yet. ${correct} out of ${layout.length} symbols are correct.</span>`, 'danger');
                showPuzzleHint();
            }
        }

        function advanceLevel() {
            if (gameState.currentLevel < gameState.totalLevels) {
                gameState.currentLevel++;
                gameState.difficulty += 0.2; // Increase difficulty each level
                displayScene();
            }
        }

        function updateInventory() {
            const inventoryItems = document.getElementById('inventory-items');
            const inventoryDisplay = document.getElementById('inventory-display');

            if (gameState.inventory.length === 0) {
                inventoryItems.textContent = 'Empty';
                inventoryDisplay.classList.add('hidden');
            } else {
                inventoryItems.innerHTML = '';
                gameState.inventory.forEach((item, index) => {
                    const span = document.createElement('span');
                    span.className = 'inventory-item';
                    if (item.includes('Key') || item.includes('Torch')) {
                        span.classList.add('important');
                    }
                    span.textContent = item;
                    span.title = `Item ${index + 1} of ${gameState.inventory.length}`;
                    inventoryItems.appendChild(span);
                });
                inventoryDisplay.classList.remove('hidden');
            }
        }

        function updateHealthDisplay() {
            const healthFill = document.getElementById('health-fill');
            healthFill.style.width = `${gameState.health}%`;
            
            if (gameState.health < 30) {
                healthFill.style.background = 'linear-gradient(90deg, var(--danger-color), #ff3333)';
                healthFill.parentElement.classList.add('warning');
            } else if (gameState.health < 60) {
                healthFill.style.background = 'linear-gradient(90deg, #ffa500, #ff8c00)';
            } else {
                healthFill.style.background = 'linear-gradient(90deg, var(--success-color), #00cc7a)';
                healthFill.parentElement.classList.remove('warning');
            }
        }

        function startTimer() {
            if (gameState.timerInterval) clearInterval(gameState.timerInterval);
            
            gameState.timerInterval = setInterval(() => {
                gameState.timeLeft = Math.max(0, gameState.timeLeft - 1);
                
                const mins = Math.floor(gameState.timeLeft / 60);
                const secs = gameState.timeLeft % 60;
                const pad = s => s.toString().padStart(2, '0');
                
                document.getElementById('timer').innerHTML = `
                    <span>SANDS OF TIME</span>
                    ${pad(mins)}:${pad(secs)}
                `;
                
                if (gameState.timeLeft === 0) {
                    endGame(false, "Time has run out! The pyramid's curses have claimed you.");
                }
                
                if (gameState.timeLeft < 60 && gameState.timeLeft % 10 === 0) {
                    addMessage(`<span class="danger">‚è≥ The sands of time are running low...</span>`);
                }
            }, 1000);
        }

        function endGame(success, message = "") {
            clearInterval(gameState.timerInterval);

            const textDisplay = document.getElementById('text-display');
            const optionsContainer = document.getElementById('options-container');

            if (success) {
                const treasureCount = gameState.inventory.filter(i =>
                    !['Oil Torch', 'Ancient Bronze Key', 'Golden Scarab Key', 'Echo Stone', 'Bronze Gear'].includes(i)
                ).length;

                const finalScore = Math.floor(
                    (treasureCount * 1000) +
                    (gameState.timeLeft * 10) +
                    (gameState.health * 50) -
                    (gameState.trapsTriggered * 200) -
                    (gameState.hintsUsed * 100)
                );

                textDisplay.innerHTML += `
                    <div class="ending">
                        <h2>ìÜ£ VICTORY! ìÜ£</h2>
                        <p>You have successfully navigated the pyramid and claimed the Pharaoh's Treasure!</p>
                        <div style="margin: 20px 0; padding: 20px; background: rgba(0,0,0,0.3); border-radius: 10px;">
                            <p>Treasure Collected: ${treasureCount} valuable items</p>
                            <p>Health Remaining: ${gameState.health}%</p>
                            <p>Time Remaining: ${Math.floor(gameState.timeLeft / 60)}:${(gameState.timeLeft % 60).toString().padStart(2, '0')}</p>
                            <p>Traps Survived: ${gameState.trapsTriggered}</p>
                            <p style="margin-top: 15px; font-size: 1.5rem; color: var(--highlight-color);">
                                FINAL SCORE: ${finalScore}
                            </p>
                        </div>
                        <p>You escape through the hidden passage, richer and wiser than when you entered.</p>
                    </div>
                `;
            } else {
                textDisplay.innerHTML += `
                    <div class="ending">
                        <h2>ìÉí GAME OVER ìÉí</h2>
                        <p>${message || "The pyramid's ancient traps have sealed your fate."}</p>
                        <p>You became another mystery of the pyramid, lost to time.</p>
                    </div>
                `;
            }

            optionsContainer.innerHTML = '';

            const restartBtn = document.createElement('button');
            restartBtn.className = 'option-btn btn-primary';
            restartBtn.textContent = 'Play Again';
            restartBtn.style.gridColumn = '1 / -1';
            restartBtn.style.fontSize = '1.3rem';
            restartBtn.style.padding = '20px';
            restartBtn.addEventListener('click', () => {
                location.reload();
            });
            optionsContainer.appendChild(restartBtn);
        }

        initGame();
    </script>
</body>
</html>