<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Cursed Dice</title>
<style>
body {
    background:#111;
    color:#fff;
    font-family:monospace;
    display:flex;
    justify-content:center;
    padding-top:20px;
}
#game {
    display:grid;
    grid-template-columns:repeat(15,40px);
    grid-template-rows:repeat(15,40px);
    gap:2px;
}
.tile {
    width:40px;height:40px;
    display:flex;justify-content:center;align-items:center;
    font-size:16px;
    background:#333;
}
.wall { background:#555; }
.player { background:#0f0; }
.exit { background:#0099ff; }
.spike { background:#803; }
.arrowTrap { background:#660; }
.rotWall { background:#777; }
.slide { background:#224; }
.rune { background:#334; border:2px solid #77f; }
.door { background:#112; border:2px solid #77f; }
.monster { background:#a00; }
.tower { background:#550; }
.sentinel { background:#770; }
.falling { background:#444; }
.ghost { background:#5555; }

#cursePopup {
    position:fixed;top:40%;left:50%;
    transform:translate(-50%,-50%);
    font-size:40px;padding:20px 40px;
    background:rgba(0,0,0,0.85);
    border:3px solid red;display:none;
}
</style>
</head>
<body>

<div id="game"></div>
<div id="cursePopup"></div>

<script>
// -------------------------------------------
// CONSTANTS
// -------------------------------------------
const SIZE = 15;
const TURNS_PER_MONSTER_MOVE = 2;

// -------------------------------------------
// GLOBAL STATE
// -------------------------------------------
let grid = [];
let player = {x:1, y:1};
let exit = {x:SIZE-2, y:SIZE-2};

let turnCount = 0;
let activeTowers = false;

// -------------------------------------------
// INITIALIZATION
// -------------------------------------------
const game = document.getElementById("game");
const cursePopup = document.getElementById("cursePopup");

function newRoom() {
    grid = [];
    game.innerHTML = "";
    activeTowers = false;
    turnCount = 0;

    for (let y=0; y<SIZE; y++) {
        let row = [];
        for (let x=0; x<SIZE; x++) {
            let tile = {type:"floor", meta:{}};

            // Outer walls
            if (x===0||y===0||x===SIZE-1||y===SIZE-1) tile.type="wall";

            // Random board components
            let r = Math.random();
            if (r<0.06) tile.type="wall";
            else if (r<0.08) tile.type="rotWall";
            else if (r<0.10) tile.type="slide";
            else if (r<0.12) tile.type="spike";
            else if (r<0.14) tile.type="arrowTrap";
            else if (r<0.15) tile.type="tower";
            else if (r<0.16) tile.type="sentinel";
            else if (r<0.17) tile.type="falling";
            else if (r<0.18) tile.type="rune";
            else if (r<0.19) tile.type="door";
            else if (r<0.20) tile.type="monster";

            row.push(tile);
        }
        grid.push(row);
    }

    grid[player.y][player.x].type="floor";
    grid[exit.y][exit.x].type="exit";

    render();
}

// -------------------------------------------
// RENDERING
// -------------------------------------------
function render() {
    game.innerHTML="";
    for (let y=0;y<SIZE;y++){
        for (let x=0;x<SIZE;x++){
            const tile=grid[y][x];
            let d=document.createElement("div");
            d.classList.add("tile");

            if (player.x===x && player.y===y) d.classList.add("player");
            else if (tile.type!=="floor") d.classList.add(tile.type);

            game.appendChild(d);
        }
    }
}

// -------------------------------------------
// MOVEMENT
// -------------------------------------------
document.addEventListener("keydown",e=>{
    let dx=0,dy=0;
    if (e.key==="ArrowUp") dy=-1;
    if (e.key==="ArrowDown") dy=1;
    if (e.key==="ArrowLeft") dx=-1;
    if (e.key==="ArrowRight") dx=1;
    if (dx||dy) attemptMove(dx,dy);
});

function attemptMove(dx,dy){
    const nx=player.x+dx;
    const ny=player.y+dy;

    if (!walkable(nx,ny)) return;

    player.x=nx; player.y=ny;

    turnCount++;

    processFalling(player.x, player.y);
    processTraps();
    processRotWalls();
    processSlideFloors();
    processMonsters();
    processTowers();
    render();

    if (grid[ny][nx].type==="exit"){
        alert("Escaped! Rolling new curse...");
        rollCurse();
        newRoom();
    }
}

function walkable(x,y){
    if (x<0||y<0||x>=SIZE||y>=SIZE) return false;
    const t=grid[y][x].type;
    return !["wall","door","monster"].includes(t);
}

// -------------------------------------------
// BOARD MECHANICS
// -------------------------------------------
function processFalling(x,y){
    let t=grid[y][x];
    if (t.type==="falling"){
        grid[y][x].type="wall";
    }
}

function processRotWalls(){
    for (let y=0;y<SIZE;y++){
        for (let x=0;x<SIZE;x++){
            if (grid[y][x].type==="rotWall"){
                // purely cosmetic for now
            }
        }
    }
}

function processSlideFloors(){
    if (turnCount%2!==0) return;
    for (let y=0;y<SIZE;y++){
        for (let x=0;x<SIZE;x++){
            if (grid[y][x].type==="slide"){
                // shift that entire row left
                grid[y].push(grid[y].shift());
                break;
            }
        }
    }
}

function processTraps(){
    for (let y=0;y<SIZE;y++){
        for (let x=0;x<SIZE;x++){
            let t=grid[y][x].type;

            if (t==="spike" && turnCount%2===0){
                if (player.x===x && player.y===y) lose("Impaled by spikes.");
            }

            if (t==="arrowTrap" && turnCount%3===0){
                if (player.x===x) lose("Shot by an arrow.");
            }
        }
    }
}

function processTowers(){
    if (!activeTowers) return;

    for (let y=0;y<SIZE;y++){
        for (let x=0;x<SIZE;x++){
            let t=grid[y][x].type;
            if (t==="tower"){
                if (player.x===x||player.y===y) lose("Tower beam hit you.");
            }
            if (t==="sentinel"){
                // rotates every turn, treat the same here
                if (player.x===x||player.y===y) lose("Sentinel shot you.");
            }
        }
    }
}

// -------------------------------------------
// MONSTERS (slow movement)
// -------------------------------------------
function processMonsters(){
    if (turnCount%TURNS_PER_MONSTER_MOVE!==0) return;

    for (let y=0;y<SIZE;y++){
        for (let x=0;x<SIZE;x++){
            if (grid[y][x].type==="monster"){
                let dx = Math.sign(player.x - x);
                let dy = Math.sign(player.y - y);
                let nx = x+dx;
                let ny = y+dy;

                if (walkable(nx,ny)){
                    grid[ny][nx].type="monster";
                    grid[y][x].type="floor";
                }

                if (player.x===nx&&player.y===ny) lose("A monster got you!");
            }
        }
    }
}

// -------------------------------------------
// CURSES
// -------------------------------------------
function rollCurse(){
    const c=Math.floor(Math.random()*8)+1;
    switch(c){
        case 1: curseWallShift(); break;
        case 2: curseCollapse(); break;
        case 3: curseMirror(); break;
        case 4: cursePulse(); break;
        case 5: curseRotateBoard(); break;
        case 6: curseTowerAwaken(); break;
        case 7: curseRuneScramble(); break;
        case 8: curseGhostOverlay(); break;
    }
}

function showCurse(msg){
    cursePopup.innerText=msg;
    cursePopup.style.display="block";
    setTimeout(()=>cursePopup.style.display="none",1000);
}

// 1. slide rows / cols
function curseWallShift(){
    showCurse("CURSE: WALL SHIFT!");
    for (let y=0;y<SIZE;y++){
        if (Math.random()<0.5) grid[y].push(grid[y].shift());
        else grid[y].unshift(grid[y].pop());
    }
    render();
}

// 2. collapse random safe tiles
function curseCollapse(){
    showCurse("CURSE: COLLAPSE!");
    for (let y=0;y<SIZE;y++){
        for (let x=0;x<SIZE;x++){
            if (Math.random()<0.05 && grid[y][x].type==="floor")
                grid[y][x].type="wall";
        }
    }
    render();
}

// 3. mirror flip
function curseMirror(){
    showCurse("CURSE: MIRROR!");
    grid.reverse();
    render();
}

// 4. corruption pulse
function cursePulse(){
    showCurse("CURSE: PULSE!");
    for (let i=0;i<10;i++){
        let x=Math.floor(Math.random()*SIZE);
        let y=Math.floor(Math.random()*SIZE);
        if (grid[y][x].type==="floor") grid[y][x].type="wall";
    }
    render();
}

// 5. rotate 90Â°
function curseRotateBoard(){
    showCurse("CURSE: ROTATION!");
    let newGrid=[];
    for (let y=0;y<SIZE;y++){
        newGrid[y]=[];
        for (let x=0;x<SIZE;x++){
            newGrid[y][x]=grid[SIZE-1-x][y];
        }
    }
    grid=newGrid;
    let px=player.x, py=player.y;
    player.x=SIZE-1-py;
    player.y=px;
    render();
}

// 6. activate watchtowers
function curseTowerAwaken(){
    showCurse("CURSE: TOWER AWAKEN!");
    activeTowers=true;
}

// 7. randomize rune/door mapping (simple version)
function curseRuneScramble(){
    showCurse("CURSE: RUNE SCRAMBLE!");
    // doors become walls, runes remain
    for (let y=0;y<SIZE;y++){
        for (let x=0;x<SIZE;x++){
            if (grid[y][x].type==="door") grid[y][x].type="wall";
        }
    }
    render();
}

// 8. fake walls
function curseGhostOverlay(){
    showCurse("CURSE: GHOST OVERLAY!");
    for (let i=0;i<15;i++){
        let x=Math.floor(Math.random()*SIZE);
        let y=Math.floor(Math.random()*SIZE);
        if (grid[y][x].type==="floor") grid[y][x].type="ghost";
    }
    render();
}

// -------------------------------------------
// LOSE CONDITION
// -------------------------------------------
function lose(msg){
    alert("You died: "+msg);
    rollCurse();
    player={x:1,y:1};
    newRoom();
}

// -------------------------------------------
// START GAME
// -------------------------------------------
rollCurse();
newRoom();
render();
</script>

</body>
</html>
