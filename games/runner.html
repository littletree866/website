<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Geometric Dash</title>
<link rel="icon" href="check.png">
<style>
    body { 
        margin: 0; 
        background: #111;
        overflow: hidden; 
        font-family: 'Ink Free', cursive;
        color: #fff;
    }
    canvas { 
        display: block;
        background: linear-gradient(#1a1a1a, #333); 
        margin: 0 auto; 
    }
    #score { 
        position: absolute;
        top: 10px;
        left: 10px; 
        font-size: 24px; 
        text-shadow: 2px 2px #000;
    }
    .button { 
        padding: 15px 30px; 
        font-size: 20px; cursor: pointer; 
        background: #e74c3c; 
        border: none; 
        color: white; 
        border-radius: 5px; 
        transition: all 0.3s; 
        font-family: "Ink Free", cursive;
    }
    .button:hover { 
        transform: scale(1.1); 
    }
    #homeScreen { 
        position: absolute;
        top: 0; left: 0;
        width: 100%; height: 100%;
        background: rgba(0,0,0,0.9);
        display: flex; 
        flex-direction: column;
        justify-content: center;
        align-items: center; 
        gap: 20px;
    }
    #gameTitle { 
        font-size: 48px; 
        color: #e74c3c; 
        text-shadow: 0 0 10px rgba(231,76,60,0.5);
    }
    #instructions { 
        max-width: 600px; 
        text-align: center;
        line-height: 1.6;
    }
    .hidden {
         display: none !important; 
    }
    </style>
</head>
<body>
<div id="score">Score: 0</div>
<div id="bestScore" style="position:absolute;top:10px;right:10px;font-size:16px;opacity:0.85">Best: 0s</div>
<button id="restart" class="button hidden">Restart</button>
<div id="homeScreen">
  <h1 id="gameTitle">Geometric Dash</h1>
  <div id="instructions">
    Use SPACE to jump<br>
    Match your shape with obstacles to pass through them<br>
    Collect yellow orbs for power-ups
  </div>
  <button id="startGame" class="button">Start Game</button>
</div>
<canvas id="gameCanvas" width="800" height="400"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    const shapes = {
        square: {color:'#e74c3c', gradient:['#e74c3c','#c0392b'], width:40, height:40, jump:11},
        triangle: {color:'#3498db', gradient:['#3498db','#2980b9'], width:30, height:30, jump:9},
        circle: {color:'#2ecc71', gradient:['#2ecc71','#27ae60'], width:35, height:35, jump:13}
    };

    let player = {
        x: 100,
        y: canvas.height - 60,
        vy: 0,
        width: shapes.square.width,
        height: shapes.square.height,
        shape: 'square',
        onGround: true
    };

    let gravity = 0.65;
    let scrollSpeed = 4;
    let obstacles = [];
    let powerUps = [];
    let score = 0;
    let gameOver = false;
    let timeElapsed = 0;
    let multiplier = 1;

    let shapeOrder = ['square','triangle','circle'];
    let currentShapeIndex = 0;
    let keys = {};

    document.addEventListener('keydown', e=>{
        keys[e.code] = true;
        if(e.key==='1') changeShape('square');
        if(e.key==='2') changeShape('triangle');
        if(e.key==='3') changeShape('circle');
    });

    document.addEventListener('keyup', e=>{ keys[e.code]=false; });

    document.getElementById('restart').addEventListener('click', resetGame);

    // Sound effects
    const sounds = {
        jump: new Audio('../sounds/jump.mp3'),
        collect: new Audio('../sounds/collect.mp3'),
        die: new Audio('../sounds/die.mp3'),
        shape: new Audio('../sounds/shape.mp3')
    };

    function changeShape(shape) {
        sounds.shape.play();
        createShapeChangeEffect();
        player.shape = shape;
        player.width = shapes[shape].width;
        player.height = shapes[shape].height;
        // Simple particle effect
        for(let i=0;i<10;i++){
            particles.push({
                x: player.x+player.width/2,
                y: player.y+player.height/2,
                vx: (Math.random()-0.5)*4,
                vy: (Math.random()-0.5)*4,
                life: 20
            });
        }
    }

    function createShapeChangeEffect() {
        const centerX = player.x + player.width/2;
        const centerY = player.y + player.height/2;
        for(let i = 0; i < 20; i++) {
            const angle = (Math.PI * 2 * i) / 20;
            particles.push({
                x: centerX,
                y: centerY,
                vx: Math.cos(angle) * 5,
                vy: Math.sin(angle) * 5,
                color: shapes[player.shape].color,
                life: 30,
                size: 3
            });
        }
    }

    function autoChangeShape(){
        currentShapeIndex = (currentShapeIndex + 1) % shapeOrder.length;
        changeShape(shapeOrder[currentShapeIndex]);
    }

    // Automatically change shape every 5 seconds
    setInterval(autoChangeShape, 5000);

    function resetGame(){
        player.x = 100;
        player.y = canvas.height - 60;
        player.vy = 0;
        player.onGround = true;
        obstacles = [];
        powerUps = [];
        scrollSpeed = 4;
        score = 0;
        timeElapsed = 0;
        multiplier = 1;
        gameOver = false;
        document.getElementById('restart').style.display='none';
        requestAnimationFrame(gameLoop);
    }

    // Particles for effects
    let particles = [];

    // track last obstacle spawn x to keep spacing consistent
    let lastObstacleX = 0;

    function spawnObstacle(){
        let types = ['square','triangle','circle'];
        let type = types[Math.floor(Math.random()*types.length)];
        let height = shapes[type].height;
        // smarter spacing: spawn at right plus variable gap (200-400)
        const gap = 200 + Math.random()*200;
        const spawnX = Math.max(canvas.width + gap, lastObstacleX + 120);
        obstacles.push({
            x: spawnX,
            y: canvas.height - height - 20,
            width: shapes[type].width,
            height: height,
            type: type
        });
        lastObstacleX = spawnX;
        // limit obstacles array to avoid runaway memory
        if(obstacles.length > 12) obstacles.shift();
    }

    function spawnPowerUp(){
        powerUps.push({
            x: canvas.width + 50 + Math.random()*100,
            y: canvas.height - 60 - Math.random()*150,
            type: 'shield',
            width: 25,
            height: 25
        });
    }

    // Add pause on visibility change to avoid runaway timeElapsed
    document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
            // stop timers by setting gameOver true but keep state; resume will requestAnimationFrame again
            // safer alternative: pause updates but keep drawing - simpler: set a paused flag
            paused = true;
        } else {
            paused = false;
        }
    });

    let paused = false;

    function update(){
        if(gameOver || paused) return;

        // Player jump
        if(keys['Space'] && player.onGround){
            player.vy = -shapes[player.shape].jump;
            player.onGround = false;
            sounds.jump.play();
        }

        player.vy += gravity;
        player.y += player.vy;
        if(player.y + player.height >= canvas.height - 20){
            player.y = canvas.height - player.height - 20;
            player.vy = 0;
            player.onGround = true;
        }

        // Obstacles movement
        for(let obs of obstacles){
            obs.x -= scrollSpeed;
            if(player.x < obs.x + obs.width &&
            player.x + player.width > obs.x &&
            player.y < obs.y + obs.height &&
            player.y + player.height > obs.y){
                if(player.shape !== obs.type){
                    gameOver = true;
                    document.getElementById('restart').style.display='block';
                    sounds.die.play();
                    // persist best (timeElapsed is in seconds-ish)
                    const final = Math.floor(timeElapsed);
                    if (!bestRun || final > bestRun) { bestRun = final; localStorage.setItem(BEST_RUN_KEY, String(bestRun)); bestEl.textContent = 'Best: ' + bestRun + 's'; }
                }
            }
        }

        obstacles = obstacles.filter(o=>o.x+o.width>0);

        // PowerUps
        for(let pu of powerUps){
            pu.x -= scrollSpeed;
            if(player.x < pu.x+pu.width && player.x+player.width > pu.x &&
            player.y < pu.y+pu.height && player.y+player.height > pu.y){
                multiplier = 2;
                setTimeout(()=>{multiplier=1},5000);
                pu.collected = true;
                sounds.collect.play();
            }
        }
        powerUps = powerUps.filter(p=>!p.collected && p.x+p.width>0);

        // Random spawns
        if(Math.random()<0.02) spawnObstacle();
        if(Math.random()<0.005) spawnPowerUp();

        // Increase difficulty
        timeElapsed += 1/60;
        if(Math.floor(timeElapsed)%30===0 && Math.floor(timeElapsed)!==0){
            scrollSpeed = 4 + Math.floor(timeElapsed/30);
        }

        score = Math.floor(timeElapsed*multiplier);

        document.getElementById('score').innerText = "Time: "+score+"s";

        // Update particles
        for(let p of particles){
            p.x += p.vx;
            p.y += p.vy;
            p.life--;
        }
        particles = particles.filter(p=>p.life>0);
    }

    const backgrounds = [
        {img: createStarField(), speed: 0.5},
        {img: createMountains(), speed: 1},
        {img: createClouds(), speed: 2}
    ];

    function drawBackground() {
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        for(let bg of backgrounds) {
            const offset = -(timeElapsed * bg.speed) % canvas.width;
            ctx.drawImage(bg.img, offset, 0);
            ctx.drawImage(bg.img, offset + canvas.width, 0);
        }
    }

    // Background generation: draw starfield, mountains and clouds
    function createStarField() {
        const c = document.createElement('canvas');
        c.width = 800; c.height = 400;
        const g = c.getContext('2d');
        g.fillStyle = '#000';
        g.fillRect(0,0,c.width,c.height);
        for(let i=0;i<150;i++){
            const x = Math.random()*c.width;
            const y = Math.random()*c.height*0.6;
            const r = Math.random()*1.6;
            g.fillStyle = `rgba(255,255,255,${0.6+Math.random()*0.4})`;
            g.beginPath(); g.arc(x,y,r,0,Math.PI*2); g.fill();
        }
        return c;
    }

    function createMountains() {
        const c = document.createElement('canvas');
        c.width = 800; c.height = 400;
        const g = c.getContext('2d');
        // layered mountains
        for(let layer=0;layer<3;layer++){
            const baseY = 260 + layer*30;
            g.fillStyle = `rgba(${30+layer*20},${30+layer*20},${30+layer*20},${0.9 - layer*0.25})`;
            g.beginPath();
            g.moveTo(0,400);
            for(let x=0;x<=800;x+=20){
                const y = baseY - Math.abs(Math.sin((x+layer*120)/120))*80 - Math.random()*10*layer;
                g.lineTo(x,y);
            }
            g.lineTo(800,400);
            g.closePath();
            g.fill();
        }
        return c;
    }

    function createClouds() {
        const c = document.createElement('canvas');
        c.width = 800; c.height = 400;
        const g = c.getContext('2d');
        for(let i=0;i<8;i++){
            const x = Math.random()*800, y = 40 + Math.random()*80, w = 120+Math.random()*160, h = 30+Math.random()*30;
            const grad = g.createLinearGradient(x,y,x+w,y+h);
            grad.addColorStop(0,'rgba(255,255,255,0.06)');
            grad.addColorStop(1,'rgba(255,255,255,0.0)');
            g.fillStyle = grad;
            g.beginPath();
            g.ellipse(x,y,w,h,0,0,Math.PI*2);
            g.fill();
        }
        return c;
    }

    // Modify the draw function
    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawBackground();
        
        // Create gradient for ground
        const groundGradient = ctx.createLinearGradient(0, canvas.height-20, 0, canvas.height);
        groundGradient.addColorStop(0, '#666');
        groundGradient.addColorStop(1, '#444');
        ctx.fillStyle = groundGradient;
        ctx.fillRect(0, canvas.height-20, canvas.width, 20);

        // Draw player with gradient
        drawPlayerWithGradient();
        
        // Obstacles
        for(let obs of obstacles){
            ctx.fillStyle = shapes[obs.type].color;
            if(obs.type==='triangle'){
                ctx.beginPath();
                ctx.moveTo(obs.x,obs.y+obs.height);
                ctx.lineTo(obs.x+obs.width/2,obs.y);
                ctx.lineTo(obs.x+obs.width,obs.y+obs.height);
                ctx.closePath();
                ctx.fill();
            } else if(obs.type==='circle'){
                ctx.beginPath();
                ctx.arc(obs.x+obs.width/2,obs.y+obs.height/2,obs.width/2,0,Math.PI*2);
                ctx.fill();
            } else {
                ctx.fillRect(obs.x,obs.y,obs.width,obs.height);
            }
        }

        // PowerUps
        for(let pu of powerUps){
            ctx.fillStyle = '#f1c40f';
            ctx.beginPath();
            ctx.arc(pu.x+pu.width/2, pu.y+pu.height/2, pu.width/2, 0, Math.PI*2);
            ctx.fill();
        }

        // Particles
        for(let p of particles){
            ctx.fillStyle = '#fff';
            ctx.fillRect(p.x,p.y,2,2);
        }
    }

    function drawPlayerWithGradient() {
        const gradient = ctx.createLinearGradient(
            player.x, player.y,
            player.x, player.y + player.height
        );
        gradient.addColorStop(0, shapes[player.shape].gradient[0]);
        gradient.addColorStop(1, shapes[player.shape].gradient[1]);
        ctx.fillStyle = gradient;

        if(player.shape==='triangle'){
            ctx.beginPath();
            ctx.moveTo(player.x,player.y+player.height);
            ctx.lineTo(player.x+player.width/2,player.y);
            ctx.lineTo(player.x+player.width,player.y+player.height);
            ctx.closePath();
            ctx.fill();
        } else if(player.shape==='circle'){
            ctx.beginPath();
            ctx.arc(player.x+player.width/2,player.y+player.height/2,player.width/2,0,Math.PI*2);
            ctx.fill();
        } else {
            ctx.fillRect(player.x,player.y,player.width,player.height);
        }
    }

    // Add event listeners for home screen
    document.getElementById('startGame').addEventListener('click', () => {
        document.getElementById('homeScreen').classList.add('hidden');
        resetGame();
    });

    // Move BEST_RUN_KEY/bestEl/bestRun early so collision code can use them reliably
    const BEST_RUN_KEY = 'runner_best';
    const bestEl = document.getElementById('bestScore');
    let bestRun = Number(localStorage.getItem(BEST_RUN_KEY) || 0);
    if (bestRun > 0) bestEl.textContent = 'Best: ' + bestRun + 's';

    function gameLoop(){
        update();
        draw();
        if(!gameOver) requestAnimationFrame(gameLoop);
    }

    requestAnimationFrame(gameLoop);
</script>
</body>
</html>
