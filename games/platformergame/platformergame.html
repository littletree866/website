<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Impossible Game</title>
    <link rel="icon" href="../../icon.jpg" type="image/x-icon">
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@300;400;500;600;700&display=swap"
        rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }

        body {
            font-family: 'DM Sans', sans-serif;
            margin: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #0c0c1d 0%, #1a1a2e 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            color: #fff;
            letter-spacing: 0.5px;
        }

        button {
            font-family: inherit;
            font-weight: 600;
        }

        #gameContainer {
            position: relative;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.7);
            border-radius: 16px;
            overflow: hidden;
            border: 3px solid #2d2d5a;
            background: #1a1a2e;
        }

        canvas {
            background: linear-gradient(to bottom, #1e3c72 0%, #2a5298 100%);
            display: block;
            border-radius: 14px;
        }

        /* Enhanced UI */
        #ui {
            position: absolute;
            top: 25px;
            left: 25px;
            color: white;
            font-size: 20px;
            text-shadow: 3px 3px 10px rgba(0, 0, 0, 0.9);
            font-family: "DM Sans", sans-serif;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.7), rgba(30, 30, 70, 0.8));
            padding: 20px 25px;
            border-radius: 16px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(100, 100, 255, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        #levelText {
            font-size: 20px;
            font-weight: 700;
            color: #00ffea;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        #scoreContainer {
            font-size: 15px;
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 12px;
            color: #ffdd00;
        }

        #healthContainer {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }



        /* New Heart-based Health Display */
        #heartsDisplay {
            display: flex;
            gap: 12px;
            font-size: 20px;
            margin-top: 8px;
        }

        .heart {
            transition: all 0.3s ease;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.5));
        }

        .heart-full {
            color: #ff416c;
        }

        .heart-empty {
            color: #666;
            opacity: 0.7;
        }

        /* Controls Display */
        #controls {
            position: absolute;
            bottom: 25px;
            left: 25px;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.7), rgba(30, 30, 70, 0.8));
            padding: 15px 20px;
            border-radius: 16px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(100, 100, 255, 0.2);
            font-size: 18px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .control-row {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .key {
            background: linear-gradient(135deg, rgba(100, 100, 255, 0.3), rgba(70, 70, 200, 0.4));
            padding: 6px 14px;
            border-radius: 8px;
            min-width: 36px;
            text-align: center;
            font-weight: 700;
            border: 2px solid rgba(150, 150, 255, 0.4);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        }

        /* Pause Button */
        #pauseBtn {
            position: absolute;
            top: 25px;
            right: 25px;
            background: linear-gradient(135deg, #4a4a8a, #2d2d5a);
            color: white;
            padding: 14px 28px;
            font-size: 22px;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-family: "DM Sans", sans-serif;
            font-weight: 600;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.5);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border: 2px solid #5a5aaa;
            display: flex;
            align-items: center;
            gap: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        #pauseBtn:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 12px 24px rgba(0, 0, 0, 0.6);
            background: linear-gradient(135deg, #5a5aaa, #3d3d7a);
        }

        #pauseBtn:active {
            transform: translateY(0) scale(1);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
        }

        /* Enhanced Screens */
        .screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.95), rgba(20, 20, 50, 0.98));
            color: white;
            padding: 60px 100px;
            font-size: 48px;
            border-radius: 28px;
            text-align: center;
            display: none;
            font-family: "DM Sans", sans-serif;
            font-weight: 700;
            box-shadow: 0 30px 80px rgba(0, 0, 0, 0.9);
            border: 4px solid #4a4a8a;
            min-width: 600px;
            backdrop-filter: blur(20px);
            z-index: 1000;
            animation: screenEntrance 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        }

        @keyframes screenEntrance {
            from {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.8);
            }

            to {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }

        .screen h2 {
            margin-bottom: 30px;
            background: linear-gradient(45deg, #00ffea, #ff6b8b, #ffdd00);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-size: 64px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .screen p {
            font-size: 28px;
            margin: 25px 0;
            color: #ddd;
            font-weight: 500;
        }

        .screen button {
            margin-top: 40px;
            padding: 18px 50px;
            font-size: 28px;
            border: none;
            border-radius: 16px;
            cursor: pointer;
            font-family: "DM Sans", sans-serif;
            font-weight: 700;
            background: linear-gradient(135deg, #00c6ff, #0072ff);
            color: white;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.4);
            text-transform: uppercase;
            letter-spacing: 1.5px;
        }

        .screen button:hover {
            transform: translateY(-4px) scale(1.05);
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.6);
            background: linear-gradient(135deg, #00d2ff, #3a7bd5);
        }

        .screen button:active {
            transform: translateY(0) scale(1);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.4);
        }

        /* Double Jump Indicator */
        #doubleJumpIndicator {
            position: absolute;
            top: 25px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(0, 200, 255, 0.3), rgba(0, 150, 255, 0.4));
            color: #00ffea;
            padding: 12px 24px;
            border-radius: 25px;
            font-size: 20px;
            display: none;
            align-items: center;
            gap: 12px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(0, 200, 255, 0.5);
            animation: pulseGlow 2s infinite;
            box-shadow: 0 8px 32px rgba(0, 200, 255, 0.3);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        @keyframes pulseGlow {

            0%,
            100% {
                box-shadow: 0 8px 32px rgba(0, 200, 255, 0.3);
            }

            50% {
                box-shadow: 0 8px 32px rgba(0, 200, 255, 0.6);
            }
        }

        /* Mobile Controls */
        #mobileControls {
            position: absolute;
            bottom: 25px;
            right: 25px;
            display: none;
            gap: 25px;
        }

        .mobile-btn {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: linear-gradient(135deg, rgba(100, 100, 255, 0.4), rgba(70, 70, 200, 0.5));
            border: 3px solid rgba(150, 150, 255, 0.6);
            color: white;
            font-size: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            user-select: none;
            backdrop-filter: blur(10px);
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
        }

        .mobile-btn:active {
            background: linear-gradient(135deg, rgba(150, 150, 255, 0.6), rgba(100, 100, 255, 0.7));
            transform: scale(0.9);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }

        /* Responsive */
        @media (max-width: 950px) {
            canvas {
                width: 100vw;
                height: auto;
                max-height: 100vh;
            }

            #gameContainer {
                width: 100vw;
                height: 100vh;
                border-radius: 0;
            }

            .screen {
                min-width: 90vw;
                padding: 40px;
                font-size: 32px;
            }

            .screen h2 {
                font-size: 48px;
            }

            #ui,
            #controls,
            #pauseBtn {
                transform: scale(0.95);
            }
        }

        @media (max-width: 768px) {
            #mobileControls {
                display: flex;
            }

            #controls {
                display: none;
            }

            #ui {
                padding: 15px;
                font-size: 18px;
            }

            #levelText {
                font-size: 22px;
            }

            #heartsDisplay {
                font-size: 24px;
                gap: 8px;
            }
        }
    </style>
</head>

<body>
    <div id="gameContainer">
        <canvas id="game" width="900" height="900"></canvas>

        <div id="ui">
            <div id="levelText">üéØ Level: 1</div>
            <div id="scoreContainer">‚≠ê Score: <span id="scoreText">0</span></div>
            <div id="healthContainer">
                <div id="heartsDisplay">
                    <!-- Hearts will be dynamically added here -->
                </div>
            </div>
        </div>

        <div id="doubleJumpIndicator">‚ú® Double Jump Active</div>

        <div id="mobileControls">
            <div class="mobile-btn" id="leftBtn">‚Üê</div>
            <div class="mobile-btn" id="rightBtn">‚Üí</div>
            <div class="mobile-btn" id="jumpBtn">‚Üë</div>
        </div>

        <button id="pauseBtn">‚è∏Ô∏è Pause</button>

        <div id="gameOverScreen" class="screen">
            <h2>Game Over</h2>
            <p>Score: <span id="finalScore">0</span></p>
            <p>Level: <span id="finalLevel">1</span></p>
            <button onclick="resetGame()">Try Again</button>
        </div>

        <div id="winScreen" class="screen">
            <h2>Victory! üéâ</h2>
            <p>Final Score: <span id="winScore">0</span></p>
            <button onclick="resetGame()">Play Again</button>
        </div>

        <div id="instructionsScreen" class="screen">
            <h2>The Impossible Game</h2>
            <p>Reach the goal while avoiding enemies and traps!</p>
            <p>Collect coins for points and power-ups for abilities.</p>
            <p>Squish enemies for health drops when injured!</p>
            <button onclick="startGame()">Start Game</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById("game");
        const ctx = canvas.getContext("2d");

        // Performance improvements
        let lastFrameTime = 0;
        const FPS = 60;
        const frameDuration = 1000 / FPS;

        const keys = { left: false, right: false, up: false };
        let paused = false;
        let score = 0;
        let health = 3; // Changed from 100 to 3 hearts
        let maxHealth = 3;
        let level = 1;
        let gameStarted = false;
        let particles = [];
        let screenShake = 0;
        let gameTime = 0;
        let heartDrops = []; // Array to store heart drops from enemies
        let checkpoints = []; // Array to store checkpoints
        let lastCheckpoint = null; // Last activated checkpoint

        const scoreText = document.getElementById("scoreText");
        const heartsDisplay = document.getElementById("heartsDisplay");
        const gameOverScreen = document.getElementById("gameOverScreen");
        const winScreen = document.getElementById("winScreen");
        const instructionsScreen = document.getElementById("instructionsScreen");
        const finalScore = document.getElementById("finalScore");
        const finalLevel = document.getElementById("finalLevel");
        const winScore = document.getElementById("winScore");
        const doubleJumpIndicator = document.getElementById("doubleJumpIndicator");

        const world = { width: 2400, height: canvas.height };
        let camera = { x: 0, y: 0, width: canvas.width, smooth: 0.05 };

        let player = {
            x: 50, y: 50, w: 36, h: 44,
            vx: 0, vy: 0,
            speed: 5.2,
            jumping: false,
            onGround: false,
            coyote: 0,
            canDoubleJump: false,
            facing: 1,
            dashCooldown: 0,
            invincible: 0,
            jumpBuffer: 0
        };

        const gravity = 0.8;
        const jumpForce = -14;
        const COYOTE_TIME = 0.2;
        const JUMP_BUFFER = 0.1;

        let platforms = [];
        let enemies = [];
        let coins = [];
        let powerUps = [];
        let goal = null;
        let decorations = [];
        let backgrounds = [];
        let lastTime = performance.now();

        // Update hearts display
        function updateHeartsDisplay() {
            heartsDisplay.innerHTML = '';
            for (let i = 0; i < maxHealth; i++) {
                const heart = document.createElement('span');
                heart.className = 'heart';
                if (i < health) {
                    heart.textContent = '‚ù§Ô∏è';
                    heart.classList.add('heart-full');
                } else {
                    heart.textContent = 'ü©∂';
                    heart.classList.add('heart-empty');
                }
                heartsDisplay.appendChild(heart);
            }
        }

        // Entity factory functions
        function makeEnemy(x, y, minX, maxX, speed = 1.5) {
            return { x, y, w: 36, h: 36, vx: speed, minX, maxX, anim: 0, type: 'ground' };
        }

        function makeCoin(x, y) {
            return { x, y, w: 20, h: 20, collected: false, anim: 0 };
        }

        function makePowerUp(x, y, type = 'doubleJump') {
            return { x, y, w: 28, h: 28, type: type, collected: false, anim: 0 };
        }

        // Heart drop factory function
        function makeHeartDrop(x, y) {
            return {
                x, y, w: 24, h: 24,
                collected: false,
                anim: 0,
                vy: -3, // Initial upward velocity
                bounce: 0
            };
        }

        // Checkpoint factory function
        function makeCheckpoint(x, y, isStart = false) {
            return {
                x, y, w: 40, h: 60,
                active: isStart,
                anim: 0,
                type: 'checkpoint'
            };
        }

        // Initialize platforms properly
        function initPlatforms() {
            platforms = [];
            enemies = [];
            coins = [];
            powerUps = [];
            goal = null;
            decorations = [];
            backgrounds = [];
            heartDrops = [];
            checkpoints = [];
            lastCheckpoint = null;
        }

        function createCheckpointsForLevel() {
            checkpoints = [];
            if (level === 1) {
                checkpoints.push(makeCheckpoint(50, 800, true)); // Starting checkpoint
                checkpoints.push(makeCheckpoint(900, 546, false));
            } else if (level === 2) {
                checkpoints.push(makeCheckpoint(50, 800, true)); // Starting checkpoint

            } else if (level === 3) {
                checkpoints.push(makeCheckpoint(50, 750, true)); // Starting checkpoint
                checkpoints.push(makeCheckpoint(850, 600, false));
                checkpoints.push(makeCheckpoint(1650, 350, false));
            } else if (level === 4) {
                checkpoints.push(makeCheckpoint(50, 750, true)); // Starting checkpoint
                checkpoints.push(makeCheckpoint(450, 700, false));
                checkpoints.push(makeCheckpoint(1250, 400, false));
                checkpoints.push(makeCheckpoint(2600, 200, false));
            }
            lastCheckpoint = checkpoints[0]; // Set starting checkpoint as last
        }

        function loadLevel(n) {
            level = n;
            document.getElementById("levelText").textContent = `üéØ Level: ${level}`;

            initPlatforms();

            // Platform factory functions
            function staticPlat(x, y, w, h) {
                return { x, y, w, h, type: 'static', color: '#4ECC88' };
            }

            function movingPlat(x, y, w, h, minX, maxX, speed) {
                return { x, y, w, h, type: 'moving', vx: speed, minX, maxX, color: '#7FB069' };
            }

            function fallPlat(x, y, w, h, delay) {
                return { x, y, w, h, type: 'fall', fallDelay: delay, falling: false, vy: 0, color: '#9DC183' };
            }

            function spike(x, y, w, h) {
                return { x, y, w, h, type: 'spike', color: '#ff5555' };
            }

            function lava(x, y, w, h) {
                return { x, y, w, h, type: 'lava', color: '#ff2222', anim: 0 };
            }

            function bouncyPlat(x, y, w, h) {
                return { x, y, w, h, type: 'bouncy', bounce: 20, color: '#FFD700' };
            }

            function conveyor(x, y, w, h, dir) {
                return { x, y, w, h, type: 'conveyor', dir: dir, speed: 2.5, anim: 0, color: '#8888ff' };
            }

            // Entity factory functions
            function makeEnemy(x, y, minX, maxX, speed = 1.5) {
                return { x, y, w: 36, h: 36, vx: speed, minX, maxX, anim: 0, type: 'ground' };
            }

            function makeCoin(x, y) {
                return { x, y, w: 20, h: 20, collected: false, anim: 0 };
            }

            function makePowerUp(x, y, type = 'doubleJump') {
                return { x, y, w: 28, h: 28, type: type, collected: false, anim: 0 };
            }

            // Heart drop factory function
            function makeHeartDrop(x, y) {
                return {
                    x, y, w: 24, h: 24,
                    collected: false,
                    anim: 0,
                    vy: -3, // Initial upward velocity
                    bounce: 0
                };
            }

            // Checkpoint factory function
            function makeCheckpoint(x, y, isStart = false) {
                return {
                    x, y, w: 40, h: 60,
                    active: isStart,
                    anim: 0,
                    type: 'checkpoint'
                };
            }

            // Level designs
            if (level === 1) {
                world.width = 1800;
                platforms = [
                    staticPlat(0, 860, 1800, 40),



                    staticPlat(200, 750, 120, 20),
                    staticPlat(400, 700, 120, 20),
                    movingPlat(620, 650, 140, 20, 600, 850, 1.8),

                    staticPlat(900, 600, 120, 20),
                    staticPlat(1100, 550, 120, 20),

                    staticPlat(1340, 500, 80, 20),
                    staticPlat(1500, 400, 80, 20),

                    movingPlat(1480, 350, 80, 20, 1260, 1480, -2.0),

                    staticPlat(1150, 360, 80, 20),
                    staticPlat(970, 370, 80, 20),


                    spike(450, 856, 100, 12),
                    spike(750, 856, 100, 12),

                ];

                enemies.push(makeEnemy(320, 840, 300, 800, 1.5));

                goal = { x: 800, y: 360, w: 50, h: 70, anim: 0 };

                coins.push(
                    makeCoin(250, 710),
                    makeCoin(670, 610),
                    makeCoin(1050, 560),
                    makeCoin(1350, 450),
                    makeCoin(1550, 350)
                );

            }

            if (level === 2) {
                world.width = 2300;
                platforms = [
                    staticPlat(0, 860, 2300, 40),

                    staticPlat(200, 750, 120, 20),
                    staticPlat(400, 700, 120, 20),
                    staticPlat(600, 650, 120, 20),

                    staticPlat(900, 600, 120, 20),
                    staticPlat(1100, 550, 120, 20),
                    staticPlat(1300, 500, 120, 20),

                    staticPlat(1500, 450, 120, 20),

                    bouncyPlat(1800, 500, 160, 20),

                    spike(750, 850, 100, 12),
                    spike(1950, 850, 100, 12),

                    // bonus
                    staticPlat(1900, 300, 50, 20),
                    staticPlat(1800, 250, 50, 20),

                    staticPlat(1700, 200, 50, 20),
                    staticPlat(1600, 150, 50, 20),

                    staticPlat(1500, 100, 50, 20),
                    staticPlat(1400, 100, 50, 20),

                    movingPlat(1300, 300, 80, 20, 150, 1350, 2.5),

                    spike(450, 400, 100, 12),


                ];

                enemies.push(makeEnemy(320, 840, 300, 800, 1.5));
                // unreachable goal for now
                goal = { x: 100, y: 300, w: 50, h: 70, anim: 0 };

                coins.push(
                    makeCoin(280, 700),
                    makeCoin(700, 610),
                    makeCoin(1150, 510),
                    makeCoin(1600, 310),
                    makeCoin(1850, 260)
                );

            }

            if (level === 3) {
                world.width = 2600;
                platforms = [
                    staticPlat(0, 860, 2600, 40),
                    lava(150, 876, 100, 24),


                    movingPlat(300, 750, 120, 20, 280, 500, 2.0),
                    movingPlat(600, 700, 120, 20, 550, 750, 2.2),

                    fallPlat(850, 650, 100, 20, 400),
                    fallPlat(1000, 600, 100, 20, 400),

                    conveyor(1300, 500, 200, 20, 1),
                    conveyor(1520, 450, 200, 20, -1),

                    staticPlat(1350, 400, 60, 20),
                    spike(1350, 396, 60, 12),

                    bouncyPlat(1650, 400, 140, 20),
                    staticPlat(1800, 350, 120, 20),

                    lava(900, 876, 400, 24),
                    lava(1400, 876, 300, 24)
                ];

                enemies.push(makeEnemy(320, 730, 300, 500, 1.8));
                enemies.push(makeEnemy(620, 680, 600, 750, 2.0));
                enemies.push(makeEnemy(1020, 530, 1000, 1150, 1.5));

                goal = { x: 2500, y: 250, w: 50, h: 70, anim: 0 };

                coins.push(
                    makeCoin(350, 710),
                    makeCoin(650, 660),
                    makeCoin(900, 610),
                    makeCoin(1050, 560),
                    makeCoin(1400, 460),
                    makeCoin(1480, 310),
                    makeCoin(2000, 260)
                );

            }

            if (level === 4) {
                world.width = 3000;
                platforms = [
                    staticPlat(0, 860, 3000, 40),

                    movingPlat(250, 800, 100, 20, 240, 400, 2.8),
                    movingPlat(450, 750, 100, 20, 430, 600, 2.5),

                    bouncyPlat(1100, 500, 100, 20),
                    bouncyPlat(1250, 450, 100, 20),
                    bouncyPlat(1400, 400, 100, 20),

                    conveyor(1500, 600, 200, 20, 1),
                    conveyor(1720, 550, 200, 20, -1),

                    fallPlat(1950, 500, 80, 20, 300),
                    fallPlat(2050, 450, 80, 20, 300),

                    movingPlat(2400, 300, 120, 20, 2380, 2550, 3.2),
                    movingPlat(2600, 250, 120, 20, 2580, 2750, 3.0),

                    lava(200, 876, 600, 24),
                    lava(850, 876, 300, 24),
                    lava(1900, 876, 400, 24)
                ];

                enemies.push(makeEnemy(270, 780, 250, 400, 2.2));
                enemies.push(makeEnemy(470, 730, 450, 600, 2.0));
                enemies.push(makeEnemy(820, 630, 800, 960, 1.8));
                enemies.push(makeEnemy(1520, 580, 1500, 1700, 2.3));

                goal = { x: 2900, y: 150, w: 50, h: 70, anim: 0 };

                coins.push(
                    makeCoin(300, 760),
                    makeCoin(500, 710),
                    makeCoin(700, 660),
                    makeCoin(850, 610),
                    makeCoin(1150, 460),
                    makeCoin(1350, 410),
                    makeCoin(1550, 560),
                    makeCoin(2450, 260),
                    makeCoin(2650, 210)
                );

            }

            createCheckpointsForLevel();
            resetPlayer();
            updateHeartsDisplay();
        }

        // Input handling
        document.addEventListener("keydown", e => {
            if (!gameStarted) return;

            switch (e.key.toLowerCase()) {
                case "arrowleft":
                case "a":
                    keys.left = true;
                    break;
                case "arrowright":
                case "d":
                    keys.right = true;
                    break;
                case "shift":
                    // secret beta key to auto-complete levels for testing
                    if (e.shiftKey) {
                        if (level < 4) {
                            loadLevel(level + 1);
                        } else {
                            winScore.textContent = score;
                            winScreen.style.display = "block";
                            paused = true;
                        }
                    }
                    break;
                case "arrowup":
                case "w":
                case " ":
                    e.preventDefault();
                    keys.up = true;
                    player.jumpBuffer = JUMP_BUFFER;
                    break;
                case "escape":
                    paused = !paused;
                    document.getElementById("pauseBtn").textContent = paused ? "‚ñ∂Ô∏è Resume" : "‚è∏Ô∏è Pause";
                    break;
            }
        });

        document.addEventListener("keyup", e => {
            switch (e.key.toLowerCase()) {
                case "arrowleft":
                case "a":
                    keys.left = false;
                    break;
                case "arrowright":
                case "d":
                    keys.right = false;
                    break;
                case "arrowup":
                case "w":
                case " ":
                    keys.up = false;
                    break;
            }
        });

        // Mobile controls
        const leftBtn = document.getElementById("leftBtn");
        const rightBtn = document.getElementById("rightBtn");
        const jumpBtn = document.getElementById("jumpBtn");

        const setupMobileButton = (btn, key) => {
            const startEvent = (e) => {
                e.preventDefault();
                keys[key] = true;
                if (key === 'up') player.jumpBuffer = JUMP_BUFFER;
            };

            const endEvent = (e) => {
                e.preventDefault();
                keys[key] = false;
            };

            btn.addEventListener("touchstart", startEvent);
            btn.addEventListener("touchend", endEvent);
            btn.addEventListener("mousedown", startEvent);
            btn.addEventListener("mouseup", endEvent);
            btn.addEventListener("mouseleave", endEvent);
        };

        setupMobileButton(leftBtn, 'left');
        setupMobileButton(rightBtn, 'right');
        setupMobileButton(jumpBtn, 'up');

        // Pause button
        document.getElementById("pauseBtn").onclick = () => {
            if (!gameStarted) return;
            paused = !paused;
            document.getElementById("pauseBtn").textContent = paused ? "‚ñ∂Ô∏è Resume" : "‚è∏Ô∏è Pause";
        };

        // Collision detection
        function rectCollision(a, b) {
            return a.x < b.x + b.w &&
                a.x + a.w > b.x &&
                a.y < b.y + b.h &&
                a.y + a.h > b.y;
        }

        function damage(amount) {
            if (player.invincible > 0) return;

            health -= amount;
            if (health < 0) health = 0;
            updateHeartsDisplay();

            screenShake = 15;

            // Visual feedback
            canvas.style.filter = "brightness(2) saturate(3)";
            setTimeout(() => canvas.style.filter = "", 150);

            player.invincible = 90; // Increased invincibility frames

            // go to nearest checkpoint if available
            if (lastCheckpoint) {
                player.x = lastCheckpoint.x + lastCheckpoint.w / 2 - player.w / 2;
                player.y = lastCheckpoint.y - player.h;
                player.vx = 0;
                player.vy = 0;
            } else {
                // If no checkpoint, reset to start
                resetPlayer();
            }

            if (health <= 0) {
                finalScore.textContent = score;
                finalLevel.textContent = level;
                gameOverScreen.style.display = "block";
                paused = true;
            }
        }

        function heal(amount) {
            health = Math.min(maxHealth, health + amount);
            updateHeartsDisplay();

            // Healing effect
            createParticles(player.x + player.w / 2, player.y + player.h / 2, 20, "#00FF00", 3);
        }

        function resetPlayer() {
            if (lastCheckpoint) {
                player.x = lastCheckpoint.x + lastCheckpoint.w / 2 - player.w / 2;
                player.y = lastCheckpoint.y - player.h;
            } else {
                player.x = 50;
                player.y = 50;
            }
            player.vx = 0;
            player.vy = 0;
            player.jumping = false;
            player.onGround = false;
            player.coyote = 0;
            player.canDoubleJump = false;
            player.invincible = 0;
            player.jumpBuffer = 0;
            camera.x = 0;
            camera.y = 0;
            doubleJumpIndicator.style.display = "none";
            heartDrops = []; // Clear any existing heart drops
        }

        function resetGame() {
            paused = false;
            gameStarted = true;
            gameOverScreen.style.display = "none";
            winScreen.style.display = "none";
            score = 0;
            health = maxHealth;
            updateHeartsDisplay();
            loadLevel(1);
            document.getElementById("pauseBtn").textContent = "‚è∏Ô∏è Pause";
            gameTime = 0;
        }

        function startGame() {
            instructionsScreen.style.display = "none";
            resetGame();
        }

        function createParticles(x, y, count, color, speed = 3) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x, y,
                    vx: (Math.random() - 0.5) * speed,
                    vy: (Math.random() - 0.5) * speed - 2,
                    life: 1,
                    color,
                    size: Math.random() * 5 + 3
                });
            }
        }

        function update(deltaTime) {
            if (paused || !gameStarted) return;

            gameTime += deltaTime;

            // Update particles
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].x += particles[i].vx;
                particles[i].y += particles[i].vy;
                particles[i].life -= 0.03;
                particles[i].vy += 0.1; // Gravity

                if (particles[i].life <= 0) {
                    particles.splice(i, 1);
                }
            }

            // Update heart drops
            for (let i = heartDrops.length - 1; i >= 0; i--) {
                const heart = heartDrops[i];

                if (!heart.collected) {
                    // Bouncing animation
                    heart.anim += 0.1;
                    heart.vy += 0.3; // Gravity
                    heart.y += heart.vy;

                    // Bounce on platforms
                    for (let p of platforms) {
                        if (p.type === 'fall' && p.falling) continue;
                        if (p.type === 'spike' || p.type === 'lava') continue;

                        if (rectCollision(heart, p) && heart.vy > 0) {
                            heart.y = p.y - heart.h;
                            heart.vy = -heart.vy * 0.6; // Bounce with energy loss
                            heart.bounce++;

                            // Stop bouncing after 3 bounces
                            if (heart.bounce >= 3) {
                                heart.vy = 0;
                            }
                        }
                    }
                    // Collect heart drop
                    if (rectCollision(player, heart) && health < maxHealth) {
                        heart.collected = true;
                        heart.driftPhase = 0;
                        heart.driftTime = 0;
                        heart.startX = heart.x - camera.x + heart.w / 2;
                        heart.startY = heart.y - camera.y + heart.h / 2;

                        // Find which empty heart to target (the first grey one)
                        const heartElements = heartsDisplay.querySelectorAll('.heart');
                        let targetHeartIndex = -1;

                        for (let i = 0; i < heartElements.length; i++) {
                            if (heartElements[i].classList.contains('heart-empty')) {
                                targetHeartIndex = i;
                                break;
                            }
                        }

                        if (targetHeartIndex !== -1) {
                            const targetHeart = heartElements[targetHeartIndex];
                            const targetRect = targetHeart.getBoundingClientRect();
                            const gameContainerRect = document.getElementById('gameContainer').getBoundingClientRect();

                            heart.targetIndex = targetHeartIndex;
                            heart.targetX = targetRect.left + targetRect.width / 2 - gameContainerRect.left;
                            heart.targetY = targetRect.top + targetRect.height / 2 - gameContainerRect.top;

                            heal(1);
                            createParticles(heart.x + heart.w / 2, heart.y + heart.h / 2, 15, "#00FF00", 4);
                        } else {
                            // If no empty hearts (shouldn't happen), just remove it
                            heartDrops.splice(i, 1);
                        }
                    }

                } else {
                    // Smooth drift animation toward specific empty heart
                    if (heart.driftPhase !== undefined && heart.driftPhase < 1 && heart.targetIndex !== undefined) {
                        heart.driftTime += deltaTime;

                        // Use easing function for smooth animation (easeOutCubic)
                        heart.driftPhase = heart.driftTime / 1.5; // 1.5 seconds total duration
                        if (heart.driftPhase > 1) heart.driftPhase = 1;

                        // Easing function for smoother motion
                        const t = heart.driftPhase;
                        const easedT = 1 - Math.pow(1 - t, 3); // easeOutCubic

                        // Current position with easing
                        const currentX = heart.startX + (heart.targetX - heart.startX) * easedT;
                        const currentY = heart.startY + (heart.targetY - heart.startY) * easedT;

                        // Also move the heart object position for drawing
                        heart.x = currentX + camera.x - heart.w / 2;
                        heart.y = currentY + camera.y - heart.h / 2;

                        // Scale down as it approaches target
                        heart.scale = 1 - (t * 0.5);

                        // Update heart color phases
                        if (t < 0.5) {
                            // Phase 1: Green heart drifting to position
                            heart.colorPhase = 'green';
                        } else if (t < 0.9) {
                            // Phase 2: At empty heart, turning yellow
                            heart.colorPhase = 'green';
                        } else {
                            // Phase 3: Turning red (filling the heart)
                            heart.colorPhase = 'red';
                        }

                        // When animation completes, update the UI heart
                        if (heart.driftPhase >= 1 && !heart.uiUpdated) {
                            heart.uiUpdated = true;

                            // Update the specific heart in the UI
                            const heartElements = heartsDisplay.querySelectorAll('.heart');
                            if (heartElements[heart.targetIndex]) {
                                const targetHeart = heartElements[heart.targetIndex];
                                targetHeart.textContent = '‚ù§Ô∏è';
                                targetHeart.classList.remove('heart-empty');
                                targetHeart.classList.add('heart-full');

                                // Add a little bounce animation to the filled heart
                                targetHeart.style.transform = 'scale(1.3)';
                                setTimeout(() => {
                                    targetHeart.style.transform = 'scale(1)';
                                    targetHeart.style.transition = 'transform 0.3s ease';
                                }, 50);
                            }

                            // Remove after a short delay to show the final state
                            setTimeout(() => {
                                const index = heartDrops.findIndex(h => h === heart);
                                if (index !== -1) {
                                    heartDrops.splice(index, 1);
                                }
                            }, 300);
                        }
                    } else if (heart.uiUpdated) {
                        // Remove if animation completed and UI was updated
                        const index = heartDrops.findIndex(h => h === heart);
                        if (index !== -1) {
                            heartDrops.splice(index, 1);
                        }
                    }
                }
            }


            // Checkpoint collision
            for (let cp of checkpoints) {
                if (!cp.active && rectCollision(player, cp)) {
                    cp.active = true;
                    lastCheckpoint = cp;
                    createParticles(cp.x + cp.w / 2, cp.y + cp.h / 2, 30, "#00FF00", 4);
                }
            }

            // Screen shake
            if (screenShake > 0) screenShake -= 1;

            // Invincibility frames
            if (player.invincible > 0) {
                player.invincible--;
            }

            // Jump buffer
            if (player.jumpBuffer > 0) {
                player.jumpBuffer -= deltaTime;
            }

            // Movement
            player.vx = 0;
            if (keys.left) {
                player.vx = -player.speed;
                player.facing = -1;
            }
            if (keys.right) {
                player.vx = player.speed;
                player.facing = 1;
            }

            // Coyote time
            if (player.onGround) {
                player.coyote = COYOTE_TIME;
                player.canDoubleJump = false; // Reset double jump when on ground
            } else {
                player.coyote -= deltaTime;
            }

            // Jumping with buffer
            if ((keys.up || player.jumpBuffer > 0) &&
                (player.onGround || player.coyote > 0 || (player.canDoubleJump && !player.jumping))) {

                player.vy = jumpForce;

                if (!player.onGround && player.coyote <= 0) {
                    player.canDoubleJump = false;
                    doubleJumpIndicator.style.display = "none";
                    createParticles(player.x + player.w / 2, player.y + player.h / 2, 20, "#00ffff", 4);
                }

                player.jumping = true;
                player.onGround = false;
                player.coyote = 0;
                player.jumpBuffer = 0;
                createParticles(player.x + player.w / 2, player.y + player.h, 15, "#ffffff", 3);
            }

            // Apply gravity and movement
            player.vy += gravity;
            player.x += player.vx;
            player.y += player.vy;

            // World boundaries
            if (player.x < 0) player.x = 0;
            if (player.x + player.w > world.width) player.x = world.width - player.w;

            // Platform collision
            let onGround = false;
            for (let p of platforms) {
                if (p.type === 'fall' && p.falling) continue;
                if (p.type === 'spike' || p.type === 'lava') continue;

                if (rectCollision(player, p)) {
                    // Landing on top of platform
                    if (player.vy > 0 && (player.y + player.h) - player.vy <= p.y + 10) {
                        player.y = p.y - player.h;
                        player.vy = 0;
                        player.jumping = false;
                        onGround = true;

                        // Bouncy platform
                        if (p.type === 'bouncy') {
                            player.vy = -p.bounce;
                            createParticles(p.x + p.w / 2, p.y, 25, "#FFD700", 4);
                        }

                        // Fall platform activation
                        if (p.type === 'fall' && !p.falling) {
                            setTimeout(() => {
                                p.falling = true;
                                createParticles(p.x + p.w / 2, p.y + p.h / 2, 30, "#A0522D", 2);
                            }, p.fallDelay || 500);
                        }
                    }
                    // Side collision
                    else if (player.vx !== 0) {
                        if (player.x + player.w > p.x && player.x < p.x) {
                            player.x = p.x - player.w;
                        } else if (player.x < p.x + p.w && player.x + player.w > p.x + p.w) {
                            player.x = p.x + p.w;
                        }
                    }
                }
            }
            player.onGround = onGround;

            // Enemy collision
            for (let i = enemies.length - 1; i >= 0; i--) {
                const e = enemies[i];
                e.x += e.vx;
                e.anim += 0.15;

                // Turn around at boundaries
                if (e.x < e.minX) {
                    e.vx = Math.abs(e.vx);
                    e.x = e.minX;
                }
                if (e.x > e.maxX) {
                    e.vx = -Math.abs(e.vx);
                    e.x = e.maxX;
                }

                if (rectCollision(player, e) && player.invincible <= 0) {
                    // Stomp enemy
                    if (player.vy > 0 && player.y + player.h < e.y + 20) {
                        enemies.splice(i, 1);
                        score += 250;
                        player.vy = -12;
                        createParticles(e.x + e.w / 2, e.y + e.h / 2, 30, "#ff0000", 4);

                        // 90% chance to drop a heart if player is not at full health
                        if (Math.random() < 0.9 && health < maxHealth) {
                            heartDrops.push(makeHeartDrop(e.x + e.w / 2, e.y));
                        }
                        continue;
                    }
                    // Take damage
                    damage(1);

                    // go to nearest checkpoint if available
                    if (lastCheckpoint) {
                        player.x = lastCheckpoint.x + lastCheckpoint.w / 2 - player.w / 2;
                        player.y = lastCheckpoint.y - player.h;
                        player.vx = 0;
                        player.vy = 0;
                    } else {
                        // If no checkpoint, reset to start
                        resetPlayer();
                    }
                }
            }

            // Hazard collision
            for (let h of platforms) {
                if (h.type === 'spike' || h.type === 'lava') {
                    if (rectCollision(player, h) && player.invincible <= 0) {
                        if (h.type === 'spike') damage(1);
                        if (h.type === 'lava') damage(maxHealth); // Insta-kill
                    }
                }

                // Update moving platforms
                if (h.type === 'moving') {
                    h.x += h.vx;
                    if (h.x < h.minX) h.vx = Math.abs(h.vx);
                    if (h.x + h.w > h.maxX) h.vx = -Math.abs(h.vx);
                }

                // Update falling platforms
                if (h.type === 'fall' && h.falling) {
                    h.vy += gravity * 0.6;
                    h.y += h.vy;
                }
            }

            // Coin collection
            for (let c of coins) {
                if (!c.collected) {
                    c.anim += 0.2;
                    if (rectCollision(player, c)) {
                        c.collected = true;
                        score += 75;
                        createParticles(c.x + 10, c.y + 10, 15, "#ffdd00", 3);
                    }
                }
            }

            // Power-up collection
            for (let p of powerUps) {
                if (!p.collected) {
                    p.anim += 0.15;
                    if (rectCollision(player, p)) {
                        p.collected = true;

                        if (p.type === 'doubleJump') {
                            player.canDoubleJump = true;
                            doubleJumpIndicator.style.display = "flex";
                            createParticles(p.x + 14, p.y + 14, 25, "#00ffff", 4);
                        }
                        // Add more power-up types here
                    }
                }
            }

            // Goal collision
            if (goal && rectCollision(player, goal)) {
                goal.anim += 0.1;
                if (level < 4) {
                    loadLevel(level + 1);
                    score += 750;
                    createParticles(goal.x + 25, goal.y + 35, 40, "#FFD700", 5);
                } else {
                    winScore.textContent = score;
                    winScreen.style.display = "block";
                    paused = true;
                }
            }

            // Fall damage
            if (player.y > canvas.height + 500) {
                damage(1);
                player.x = Math.max(0, player.x - 100);
                player.y = 100;
                player.vy = 0;
            }

            // Camera follow with smoothing
            let targetX = player.x + player.w / 2 - canvas.width / 2;
            camera.x += (targetX - camera.x) * camera.smooth;
            camera.x = Math.max(0, Math.min(camera.x, world.width - canvas.width));

            let targetY = player.y + player.h / 2 - canvas.height / 2;
            camera.y += (targetY - camera.y) * camera.smooth;
            camera.y = Math.max(0, Math.min(camera.y, world.height - canvas.height));

            // Update UI
            scoreText.textContent = score;
        }

        function drawParallax() {
            // Sky gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, "#1e3c72");
            gradient.addColorStop(1, "#2a5298");
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Distant mountains
            ctx.fillStyle = "rgba(30, 30, 60, 0.6)";
            for (let i = 0; i < 5; i++) {
                let x = (i * 400 - camera.x * 0.1) % (canvas.width + 800) - 400;
                let y = canvas.height - 100 - Math.sin(i + gameTime * 0.5) * 20;
                let height = 200 + Math.sin(i) * 50;
                ctx.beginPath();
                ctx.moveTo(x, canvas.height);
                ctx.lineTo(x + 200, canvas.height - height);
                ctx.lineTo(x + 400, canvas.height);
                ctx.fill();
            }

            // Clouds
            ctx.fillStyle = "rgba(255, 255, 255, 0.15)";
            for (let i = 0; i < 8; i++) {
                let x = (i * 250 + camera.x * 0.05) % (canvas.width + 500) - 250;
                let y = 80 + Math.sin(i + gameTime) * 40;
                drawCloud(x, y, 120 + Math.sin(i) * 40);
            }
        }

        function drawCloud(x, y, size) {
            ctx.beginPath();
            ctx.arc(x, y, size * 0.25, 0, Math.PI * 2);
            ctx.arc(x + size * 0.25, y - size * 0.1, size * 0.35, 0, Math.PI * 2);
            ctx.arc(x + size * 0.5, y, size * 0.3, 0, Math.PI * 2);
            ctx.arc(x + size * 0.25, y + size * 0.1, size * 0.25, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawPlatform(p) {
            let sx = p.x - camera.x;
            let sy = p.y - camera.y;

            // Skip if off screen (performance optimization)
            if (sx + p.w < 0 || sx > canvas.width || sy + p.h < 0 || sy > canvas.height) return;

            ctx.save();

            // Platform-specific drawing
            switch (p.type) {
                case 'spike':
                    // Enhanced spike platform base with grass
                    ctx.fillStyle = "#2C2C2C";
                    ctx.fillRect(sx, sy, p.w, p.h);

                    // Metallic edge
                    ctx.strokeStyle = "#444";
                    ctx.lineWidth = 3;
                    ctx.strokeRect(sx, sy, p.w, p.h);

                    // Spikes with gradient effect
                    for (let s = 0; s < p.w; s += 20) {
                        const spikeX = sx + s;

                        // Spike shadow
                        ctx.fillStyle = "#222";
                        ctx.beginPath();
                        ctx.moveTo(spikeX + 1, sy + p.h + 1);
                        ctx.lineTo(spikeX + 11, sy + 1);
                        ctx.lineTo(spikeX + 21, sy + p.h + 1);
                        ctx.fill();

                        // Main spike
                        const gradient = ctx.createLinearGradient(
                            spikeX, sy,
                            spikeX + 10, sy + p.h
                        );
                        gradient.addColorStop(0, "#666");
                        gradient.addColorStop(0.5, "#444");
                        gradient.addColorStop(1, "#222");

                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.moveTo(spikeX, sy + p.h);
                        ctx.lineTo(spikeX + 10, sy);
                        ctx.lineTo(spikeX + 20, sy + p.h);
                        ctx.fill();

                        // Spike highlight
                        ctx.strokeStyle = "#888";
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(spikeX + 3, sy + p.h - 5);
                        ctx.lineTo(spikeX + 10, sy + 10);
                        ctx.stroke();
                    }

                    // Grass on top like default platform
                    ctx.fillStyle = "#4CAF50";
                    for (let i = 0; i < p.w / 12; i++) {
                        const grassX = sx + i * 12 + Math.sin(i) * 4;
                        const grassHeight = 10 + Math.sin(i * 2 + gameTime) * 6;
                        ctx.fillRect(grassX, sy - 5, 3, grassHeight);

                        // Grass highlight
                        ctx.fillStyle = "#5CDB95";
                        ctx.fillRect(grassX, sy - 5, 1, grassHeight);
                        ctx.fillStyle = "#4CAF50";
                    }
                    break;

                case 'lava':
                    p.anim += 0.15;
                    const lavaY = sy + Math.sin(p.anim) * 4;

                    // Lava base with gradient
                    const lavaGradient = ctx.createLinearGradient(
                        sx, lavaY,
                        sx, lavaY + p.h
                    );
                    lavaGradient.addColorStop(0, "#FF4500");
                    lavaGradient.addColorStop(0.5, "#FF2200");
                    lavaGradient.addColorStop(1, "#CC0000");

                    ctx.fillStyle = lavaGradient;
                    ctx.fillRect(sx, lavaY, p.w, p.h);

                    // Lava surface effect
                    ctx.fillStyle = "rgba(255, 200, 0, 0.3)";
                    for (let wave = 0; wave < p.w / 30; wave++) {
                        const waveX = sx + wave * 30 + Math.sin(gameTime + wave) * 10;
                        const waveHeight = 5 + Math.sin(gameTime * 2 + wave) * 3;
                        ctx.beginPath();
                        ctx.ellipse(waveX, lavaY, 15, waveHeight, 0, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // Lava bubbles
                    for (let i = 0; i < 5; i++) {
                        const bubblePhase = p.anim + i * 1.5;
                        let bubbleX = sx + (Math.sin(bubblePhase) * 25 + i * 35) % p.w;
                        let bubbleY = lavaY + Math.cos(bubblePhase) * 3;
                        const bubbleSize = 4 + Math.sin(bubblePhase * 2) * 3;

                        // Bubble glow
                        const bubbleGlow = ctx.createRadialGradient(
                            bubbleX, bubbleY, 0,
                            bubbleX, bubbleY, bubbleSize * 2
                        );
                        bubbleGlow.addColorStop(0, "rgba(255, 255, 200, 0.8)");
                        bubbleGlow.addColorStop(0.7, "rgba(255, 200, 0, 0.3)");
                        bubbleGlow.addColorStop(1, "rgba(255, 100, 0, 0)");

                        ctx.fillStyle = bubbleGlow;
                        ctx.beginPath();
                        ctx.arc(bubbleX, bubbleY, bubbleSize * 2, 0, Math.PI * 2);
                        ctx.fill();

                        // Bubble itself
                        ctx.fillStyle = "rgba(255, 230, 100, 0.9)";
                        ctx.beginPath();
                        ctx.arc(bubbleX, bubbleY, bubbleSize, 0, Math.PI * 2);
                        ctx.fill();

                        // Bubble highlight
                        ctx.fillStyle = "rgba(255, 255, 255, 0.6)";
                        ctx.beginPath();
                        ctx.arc(bubbleX - bubbleSize / 3, bubbleY - bubbleSize / 3, bubbleSize / 3, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // Dark edges for contrast
                    ctx.strokeStyle = "rgba(139, 0, 0, 0.5)";
                    ctx.lineWidth = 2;
                    ctx.strokeRect(sx, lavaY, p.w, p.h);

                    // Grass on top (charred/dead grass for lava)
                    ctx.fillStyle = "#8B4513";
                    for (let i = 0; i < p.w / 15; i++) {
                        const grassX = sx + i * 15 + Math.sin(i) * 5;
                        const grassHeight = 6 + Math.sin(i * 1.5 + gameTime) * 3;
                        ctx.fillRect(grassX, sy - 4, 2, grassHeight);

                        // Charred effect
                        ctx.fillStyle = "#654321";
                        ctx.fillRect(grassX, sy - 4, 1, grassHeight);
                        ctx.fillStyle = "#8B4513";
                    }
                    break;

                case 'moving':
                    // Keep existing moving platform but add better grass
                    ctx.fillStyle = p.color;
                    ctx.fillRect(sx, sy, p.w, p.h);
                    ctx.strokeStyle = "#3DAF70";
                    ctx.lineWidth = 3;
                    ctx.strokeRect(sx, sy, p.w, p.h);

                    // Enhanced grass
                    ctx.fillStyle = "#5CDB95";
                    for (let i = 0; i < p.w / 10; i++) {
                        let grassX = sx + i * 10 + Math.sin(i) * 3;
                        let grassHeight = 8 + Math.sin(i + gameTime) * 4;
                        ctx.fillRect(grassX, sy - 3, 2, grassHeight);

                        // Grass highlight
                        ctx.fillStyle = "#7CFC00";
                        ctx.fillRect(grassX, sy - 3, 1, grassHeight);
                        ctx.fillStyle = "#5CDB95";
                    }
                    break;

                case 'fall':
                    // Platform base
                    ctx.fillStyle = p.falling ? "#8B4513" : p.color;
                    ctx.fillRect(sx, sy, p.w, p.h);

                    // Edge highlight/damage effect
                    ctx.strokeStyle = p.falling ? "#654321" : "#7CA56C";
                    ctx.lineWidth = 3;
                    ctx.strokeRect(sx, sy, p.w, p.h);

                    // Grass for falling platforms
                    if (p.falling) {
                        ctx.fillStyle = "#8B4513";
                        for (let i = 0; i < p.w / 15; i++) {
                            const grassX = sx + i * 15 + Math.sin(i) * 5;
                            const grassHeight = 5 + Math.sin(i * 1.5 + gameTime) * 2;
                            ctx.fillRect(grassX, sy - 4, 2, grassHeight);
                        }
                    } else {
                        ctx.fillStyle = "#5CDB95";
                        for (let i = 0; i < p.w / 12; i++) {
                            const grassX = sx + i * 12 + Math.sin(i) * 4;
                            const grassHeight = 7 + Math.sin(i * 1.5 + gameTime) * 3;
                            ctx.fillRect(grassX, sy - 4, 2, grassHeight);
                        }
                    }

                    // Crack patterns
                    ctx.strokeStyle = p.falling ? "#333" : "#555";
                    ctx.lineWidth = 1.5;

                    // Main central crack
                    ctx.beginPath();
                    const crackAnim = p.falling ? Math.sin(gameTime * 3) * 2 : 0;
                    ctx.moveTo(sx + p.w / 2 + crackAnim, sy + 3);
                    ctx.lineTo(sx + p.w / 2 - 10 + crackAnim * 0.5, sy + p.h / 3);
                    ctx.lineTo(sx + p.w / 2 + 5 + crackAnim * 1.2, sy + p.h / 2);
                    ctx.lineTo(sx + p.w / 2 - 15 + crackAnim, sy + p.h - 3);
                    ctx.stroke();
                    break;


                case 'bouncy':
                    ctx.fillStyle = p.color;
                    ctx.fillRect(sx, sy, p.w, p.h);
                    ctx.strokeStyle = "#FFA500";
                    ctx.lineWidth = 3;
                    ctx.strokeRect(sx, sy, p.w, p.h);

                    // Spring pattern
                    ctx.strokeStyle = "#FF8C00";
                    ctx.lineWidth = 2;
                    for (let i = 0; i < 3; i++) {
                        ctx.beginPath();
                        ctx.moveTo(sx + 10 + i * 30, sy + 5);
                        ctx.lineTo(sx + 25 + i * 30, sy + p.h - 5);
                        ctx.stroke();
                    }

                    // Grass for bouncy platforms
                    ctx.fillStyle = "#90EE90";
                    for (let i = 0; i < p.w / 11; i++) {
                        const grassX = sx + i * 11 + Math.sin(i) * 4;
                        const grassHeight = 9 + Math.sin(i * 2 + gameTime) * 5;
                        ctx.fillRect(grassX, sy - 4, 2, grassHeight);
                    }
                    break;

                case 'conveyor':
                    p.anim += 0.2;
                    ctx.fillStyle = p.color;
                    ctx.fillRect(sx, sy, p.w, p.h);

                    // Arrow pattern
                    ctx.fillStyle = "#6666ff";
                    for (let i = 0; i < p.w / 20; i++) {
                        let arrowX = sx + (i * 20 - p.anim * p.dir * 20) % p.w;
                        ctx.beginPath();
                        if (p.dir > 0) {
                            ctx.moveTo(arrowX, sy + p.h / 2);
                            ctx.lineTo(arrowX + 15, sy + 5);
                            ctx.lineTo(arrowX + 15, sy + p.h - 5);
                        } else {
                            ctx.moveTo(arrowX + 15, sy + p.h / 2);
                            ctx.lineTo(arrowX, sy + 5);
                            ctx.lineTo(arrowX, sy + p.h - 5);
                        }
                        ctx.closePath();
                        ctx.fill();
                    }

                    // Grass for conveyor platforms
                    ctx.fillStyle = "#98FB98";
                    for (let i = 0; i < p.w / 13; i++) {
                        const grassX = sx + i * 13 + Math.sin(i) * 5;
                        const grassHeight = 8 + Math.sin(i * 1.8 + gameTime) * 4;
                        ctx.fillRect(grassX, sy - 4, 2, grassHeight);
                    }
                    break;

                default: // static
                    ctx.fillStyle = p.color;
                    ctx.fillRect(sx, sy, p.w, p.h);
                    ctx.strokeStyle = "#3DAF70";
                    ctx.lineWidth = 3;
                    ctx.strokeRect(sx, sy, p.w, p.h);

                    // Enhanced grass on top
                    ctx.fillStyle = "#5CDB95";
                    for (let i = 0; i < p.w / 10; i++) {
                        let grassX = sx + i * 10 + Math.sin(i) * 3;
                        let grassHeight = 8 + Math.sin(i + gameTime) * 4;
                        ctx.fillRect(grassX, sy - 3, 2, grassHeight);

                        // Grass highlight for more depth
                        ctx.fillStyle = "#7CFC00";
                        ctx.fillRect(grassX, sy - 3, 1, grassHeight);
                        ctx.fillStyle = "#5CDB95";
                    }
            }

            ctx.restore();
        }

        function draw() {
            // Apply screen shake
            let shakeX = screenShake > 0 ? (Math.random() - 0.5) * screenShake : 0;
            let shakeY = screenShake > 0 ? (Math.random() - 0.5) * screenShake : 0;
            ctx.setTransform(1, 0, 0, 1, shakeX, shakeY);

            // Clear with sky
            drawParallax();

            // Draw all platforms
            for (let p of platforms) {
                drawPlatform(p);
            }

            // Draw enemies
            for (let e of enemies) {
                let ex = e.x - camera.x;
                let ey = e.y - camera.y;

                // Body
                ctx.fillStyle = "#FFA500";
                ctx.fillRect(ex, ey, e.w, e.h);

                // Eyes
                ctx.fillStyle = "#fff";
                let eyeOffset = Math.sin(e.anim) * 3;
                ctx.fillRect(ex + 8, ey + 10 + eyeOffset, 8, 8);
                ctx.fillRect(ex + 20, ey + 10 + eyeOffset, 8, 8);

                // Outline
                ctx.strokeStyle = "#ff0000";
                ctx.lineWidth = 3;
                ctx.strokeRect(ex, ey, e.w, e.h);
            }

            // Draw checkpoints
            for (let cp of checkpoints) {
                let cpx = cp.x - camera.x;
                let cpy = cp.y - camera.y;

                // Checkpoint flag color based on active state
                const flagColor = cp.active ? "#00FF00" : "#FF0000";
                const baseColor = cp.active ? "#228B22" : "#8B0000";

                // Pole
                ctx.fillStyle = baseColor;
                ctx.fillRect(cpx + 15, cpy, 10, cp.h - 10);

                // Flag with animation
                cp.anim += 0.08;
                let flagSway = Math.sin(cp.anim) * 8;

                // Flag shape
                ctx.fillStyle = flagColor;
                ctx.beginPath();
                ctx.moveTo(cpx + 25, cpy + 10);
                ctx.quadraticCurveTo(cpx + 50 + flagSway, cpy + 20, cpx + 25, cpy + 35);
                ctx.closePath();
                ctx.fill();

                // Flag outline
                ctx.strokeStyle = cp.active ? "#00AA00" : "#AA0000";
                ctx.lineWidth = 2;
                ctx.stroke();

                // Base
                ctx.fillStyle = baseColor;
                ctx.fillRect(cpx, cpy + cp.h - 10, 50, 10);
            }

            // Draw heart drops with drift animation
            for (let h of heartDrops) {
                if (!h.collected) {
                    let hx = h.x - camera.x;
                    let hy = h.y - camera.y + Math.sin(h.anim) * 3;

                    // Set font for heart emoji
                    ctx.font = "bold 50px 'Segoe UI Emoji', 'Apple Color Emoji', 'Noto Color Emoji', sans-serif";
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";

                    // Add glow effect
                    ctx.shadowColor = "#00FF00";
                    ctx.shadowBlur = 10;
                    ctx.shadowOffsetX = 0;
                    ctx.shadowOffsetY = 0;

                    // Draw the heart emoji
                    ctx.fillStyle = "#00FF00";
                    ctx.fillText("üíö", hx + h.w / 2, hy + h.h / 2);

                    // Reset shadow
                    ctx.shadowColor = "transparent";
                    ctx.shadowBlur = 0;
                } else if (h.driftPhase !== undefined && h.driftPhase < 1) {
                    // Smooth drift animation toward specific empty heart
                    const t = h.driftPhase;
                    const easedT = 1 - Math.pow(1 - t, 3); // easeOutCubic

                    // Current position with easing
                    const currentX = h.startX + (h.targetX - h.startX) * easedT;
                    const currentY = h.startY + (h.targetY - h.startY) * easedT;
                    const scale = h.scale || 1;

                    ctx.save();
                    ctx.translate(currentX, currentY);
                    ctx.scale(scale, scale);

                    ctx.font = "bold 24px 'Segoe UI Emoji', 'Apple Color Emoji', 'Noto Color Emoji', sans-serif";
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";

                    // Set heart emoji and color based on phase
                    let heartEmoji = "üíö";
                    let glowColor = "#00FF00";

                    if (h.colorPhase === 'yellow') {
                        heartEmoji = "üíõ";
                        glowColor = "#FFFF00";
                    } else if (h.colorPhase === 'red') {
                        heartEmoji = "‚ù§Ô∏è";
                        glowColor = "#FF0000";
                    }

                    // Glow effect
                    const glowIntensity = 15 * (1 - t);
                    ctx.shadowColor = glowColor;
                    ctx.shadowBlur = glowIntensity;

                    ctx.fillStyle = glowColor;
                    ctx.fillText(heartEmoji, 0, 0);

                    ctx.restore();
                }
            }

            // Draw coins
            for (let c of coins) {
                if (!c.collected) {
                    let cx = c.x - camera.x;
                    let cy = c.y - camera.y + Math.sin(c.anim) * 4;

                    // Set font for coin emoji
                    ctx.font = "bold 30px 'Segoe UI Emoji', 'Apple Color Emoji', 'Noto Color Emoji', sans-serif";
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";

                    // Add glow effect
                    ctx.shadowColor = "#FFD700";
                    ctx.shadowBlur = 8;
                    ctx.shadowOffsetX = 0;
                    ctx.shadowOffsetY = 0;


                    // Draw the coin emoji
                    ctx.fillStyle = "#FFD700";
                    ctx.fillText("ü™ô", cx + 10, cy + 10);

                    // Reset shadow
                    ctx.shadowColor = "transparent";
                    ctx.shadowBlur = 0;
                }
            }

            // Draw power-ups
            for (let p of powerUps) {
                if (!p.collected) {
                    let px = p.x - camera.x;
                    let py = p.y - camera.y + Math.sin(p.anim) * 5;

                    if (p.type === 'doubleJump') {
                        // Main body
                        ctx.fillStyle = "#00ffff";
                        ctx.fillRect(px, py, p.w, p.h);

                        // Wings
                        ctx.fillStyle = "#00aaff";
                        ctx.beginPath();
                        ctx.ellipse(px - 6, py + p.h / 2, 8, 12, 0, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.ellipse(px + p.w + 6, py + p.h / 2, 8, 12, 0, 0, Math.PI * 2);
                        ctx.fill();

                        // Outline
                        ctx.strokeStyle = "#0088cc";
                        ctx.lineWidth = 3;
                        ctx.strokeRect(px, py, p.w, p.h);

                        // Sparkle
                        ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
                        ctx.beginPath();
                        ctx.arc(px + 6, py + 6, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }

            // Draw goal
            if (goal) {
                let gx = goal.x - camera.x;
                let gy = goal.y - camera.y;

                // Flag pole
                ctx.fillStyle = "#8B4513";
                ctx.fillRect(gx + 15, gy, 8, goal.h);

                // Flag animation
                goal.anim += 0.1;
                let sway = Math.sin(goal.anim) * 10;

                // Flag
                ctx.fillStyle = "#FFD700";
                ctx.beginPath();
                ctx.moveTo(gx + 23, gy + 10);
                ctx.quadraticCurveTo(gx + 50 + sway, gy + 20, gx + 23, gy + 40);
                ctx.closePath();
                ctx.fill();

                // Flag outline
                ctx.strokeStyle = "#DAA520";
                ctx.lineWidth = 3;
                ctx.stroke();

                // Base
                ctx.fillStyle = "#333";
                ctx.fillRect(gx, gy + goal.h, 60, 10);
            }

            // Draw player
            let px = player.x - camera.x;
            let py = player.y - camera.y;

            // Squash and stretch
            let vy = player.vy;
            let scaleY = player.onGround ? 1.1 : Math.max(0.9, 1 - vy * 0.02);
            let drawW = player.w;
            let drawH = player.h * scaleY;
            let drawX = px;
            let drawY = py + (player.h - drawH);

            // Invincibility flash
            let alpha = player.invincible > 0 && Math.floor(player.invincible / 5) % 2 === 0 ? 0.5 : 1;

            // Body
            ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
            ctx.fillRect(drawX, drawY, drawW, drawH);

            // Outline
            ctx.strokeStyle = `rgba(0, 0, 0, ${alpha})`;
            ctx.lineWidth = 3;
            ctx.strokeRect(drawX, drawY, drawW, drawH);

            // Eyes
            ctx.fillStyle = `rgba(0, 0, 0, ${alpha})`;
            let eyeY = drawY + drawH * 0.3;
            let eyeOffset = Math.sin(gameTime * 0.01) * 2;
            let eyeSpacing = 10 * player.facing;
            ctx.fillRect(drawX + drawW / 2 - 6 + eyeSpacing, eyeY + eyeOffset, 6, 6);
            ctx.fillRect(drawX + drawW / 2 + 6 + eyeSpacing, eyeY + eyeOffset, 6, 6);

            // Trail effect when moving fast
            if (Math.abs(player.vx) > 3 && player.onGround) {
                ctx.fillStyle = `rgba(100, 100, 255, 0.3)`;
                for (let i = 0; i < 3; i++) {
                    ctx.fillRect(drawX - i * 8 * player.facing, drawY + drawH - 5, 6, 3);
                }
            }

            // Draw particles
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            for (let p of particles) {
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x - camera.x, p.y, p.size * p.life, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;

            // Reset transform
            ctx.setTransform(1, 0, 0, 1, 0, 0);
        }

        // Game loop with frame rate limiting
        function loop(currentTime) {
            const deltaTime = Math.min((currentTime - lastTime) / 1000, 0.1);
            lastTime = currentTime;

            update(deltaTime);
            draw();

            requestAnimationFrame(loop);
        }

        // Start the game
        instructionsScreen.style.display = "block";
        lastTime = performance.now();
        loop(lastTime);
    </script>
</body>

</html>