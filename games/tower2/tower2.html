<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tower Defense 2</title>
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;700&display=swap" rel="stylesheet">
    <link rel="icon" href="../../icon.jpg" type="image/x-icon">
    <style>
        body {
            font-family: 'DM Sans', sans-serif;
            margin: 0;
            background: linear-gradient(180deg, #1a2a4a 0%, #2d3a5a 60%);
            display: flex;
            user-select: none;
            color: #2f2314;
            overflow: hidden;
        }

        #gameContainer {
            position: relative;
            display: inline-block;
        }

        #gameCanvas {
            background: linear-gradient(135deg, #2d5a3f 0%, #1f4a3a 100%);
            display: block;
            border: 6px solid #2c2415;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            margin: 10px;
            height: 95vh;
        }

        #ui {
            width: 380px;
            background: #efe6cc;
            padding: 18px;
            overflow-y: auto;
            box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.25);
            border-left: 6px solid #4a3a23;
            margin: 10px;
            height: 90vh;
        }

        h2 {
            font-size: 20px;
            color: #39260f;
            text-shadow: 1px 1px 0 #fff;
            text-align: center;
            margin: 0 0 8px;
        }

        .panel {
            background: #f9f4df;
            border: 3px solid #4a3a23;
            border-radius: 10px;
            padding: 10px;
            margin-bottom: 12px;
        }

        .label {
            font-size: 13px;
            font-weight: bold;
            color: #3d2c15;
            margin-bottom: 4px;
        }

        .value {
            background: #fff;
            padding: 6px 10px;
            border: 2px solid #4a3a23;
            border-radius: 6px;
            margin-bottom: 8px;
            font-weight: bold;
        }

        .towerButton {
            width: 100%;
            padding: 10px;
            background: #d8caa0;
            border: 3px solid #4a3a23;
            border-radius: 10px;
            font-size: 14px;
            margin: 6px 0;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s;
        }

        .towerButton:hover:not([disabled]) {
            background: #e5d9b8;
            transform: translateY(-2px);
        }

        .towerButton[disabled] {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .actionButton {
            width: 100%;
            padding: 10px;
            border-radius: 10px;
            cursor: pointer;
            border: 3px solid #4a3a23;
            background: #a3c76d;
            margin-top: 8px;
            font-weight: bold;
            transition: all 0.2s;
        }

        .actionButton:hover:not([disabled]) {
            transform: translateY(-2px);
            filter: brightness(1.1);
        }

        .actionButton[disabled] {
            opacity: 0.5;
            cursor: not-allowed;
        }

        #sellBtn {
            background: #cc6d55;
        }

        .small {
            font-size: 12px;
            padding: 6px;
        }

        .row {
            display: flex;
            gap: 8px;
        }

        .muted {
            color: #6b5a44;
            font-size: 13px;
        }

        .tooltip {
            font-size: 11px;
            color: #555;
            margin-top: 4px;
            font-style: italic;
        }

        .synergy {
            background: #fffacd;
            border-left: 3px solid #ffaa00;
            padding: 8px;
            margin: 6px 0;
            border-radius: 4px;
            font-size: 12px;
        }

        button {
            font-family: inherit;
        }
    </style>
</head>

<body>

    <div id="gameContainer">
        <canvas id="gameCanvas" width="1100" height="650"></canvas>
    </div>

    <div id="ui">
        <h2>üõ°Ô∏è Tower Defense 2</h2>

        <div class="panel">
            <div class="label">Wave</div>
            <div class="value" id="waveDisp">1</div>
            <div class="row" style="margin-top:6px;">
                <label class="muted"><input id="autoNext" type="checkbox" /> Auto Next</label>
            </div>

            <div class="label">Buff Ratio</div>
            <div class="value" id="buffDisp">1.0</div>

            <div class="label">Enemies</div>
            <div class="value" id="enemyDisp">0</div>

            <div class="label">Health</div>
            <div class="value" id="healthDisp">100</div>

            <div class="label">Money</div>
            <div class="value" id="goldDisp">$200</div>

            <div class="label">Research</div>
            <div class="value" id="researchDisp">0/50</div>

            <div class="row" style="margin-top:6px;">
                <button id="startWaveBtn" class="actionButton small" onclick="startWave()">Start Wave</button>
                <button id="pauseBtn" class="actionButton small" onclick="togglePause()">Pause</button>
            </div>
        </div>

        <div class="panel">
            <h3 style="margin-top:0;">‚öîÔ∏è Build Towers</h3>
            <button class="towerButton" id="btn-archer" onclick="selectTower('archer')">Archer ‚Äî $80</button>
            <div class="tooltip">Fast attacks, good vs groups</div>

            <button class="towerButton" id="btn-cannon" onclick="selectTower('cannon')">Cannon ‚Äî $120</button>
            <div class="tooltip">Area damage, slow fire rate</div>

            <button class="towerButton" id="btn-wizard" onclick="selectTower('wizard')">Wizard ‚Äî $150</button>
            <div class="tooltip">Slows & stuns enemies</div>

            <button class="towerButton" id="btn-tesla" onclick="selectTower('tesla')">Tesla ‚Äî $200</button>
            <div class="tooltip">Chain lightning, high cost</div>

            <button class="towerButton" id="btn-farm" onclick="selectTower('farm')">Money Farm ‚Äî $100</button>
            <div class="tooltip">Generates passive money</div>
        </div>

        <div class="panel">
            <h3 style="margin-top:0;">üî¨ Research (Synergies)</h3>
            <div id="researchList"></div>
        </div>

        <div class="panel">
            <h3 style="margin-top:0;">Selected Tower</h3>
            <div class="value" id="towerInfo">None</div>
            <button id="sellBtn" class="actionButton" onclick="sellTower()" disabled>Sell (60%)</button>
        </div>
    </div>

    <script>

        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");


        const waveDisp = document.getElementById("waveDisp");
        const enemyDisp = document.getElementById("enemyDisp");
        const healthDisp = document.getElementById("healthDisp");
        const goldDisp = document.getElementById("goldDisp");
        const researchDisp = document.getElementById("researchDisp");
        const towerInfo = document.getElementById("towerInfo");
        const sellBtn = document.getElementById("sellBtn");
        const autoNextCheckbox = document.getElementById("autoNext");
        const researchList = document.getElementById("researchList");
        const pauseBtn = document.getElementById("pauseBtn");


        const TILE_SIZE = 40;
        const GRID_WIDTH = Math.floor(canvas.width / TILE_SIZE);
        const GRID_HEIGHT = Math.floor(canvas.height / TILE_SIZE);


        const tileMap = [];
        for (let y = 0; y < GRID_HEIGHT; y++) {
            tileMap[y] = [];
            for (let x = 0; x < GRID_WIDTH; x++) {
                tileMap[y][x] = { type: 'grass', walkable: true };
            }
        }


        const pathA = [
            { x: 0, y: 3 }, { x: 1, y: 3 }, { x: 2, y: 3 }, { x: 3, y: 3 }, { x: 4, y: 3 }, { x: 5, y: 3 }, { x: 6, y: 3 },
            { x: 6, y: 4 }, { x: 6, y: 5 }, { x: 6, y: 6 }, { x: 6, y: 7 }, { x: 6, y: 8 }, { x: 6, y: 9 }, { x: 6, y: 10 },
            { x: 6, y: 11 }, { x: 7, y: 11 }, { x: 8, y: 11 }, { x: 9, y: 11 }, { x: 10, y: 11 }, { x: 11, y: 11 }, { x: 12, y: 11 }, { x: 13, y: 11 }, { x: 14, y: 11 }, { x: 15, y: 11 }, { x: 16, y: 11 }, { x: 17, y: 11 }, { x: 18, y: 11 }, { x: 19, y: 11 }, { x: 20, y: 11 }, { x: 21, y: 11 }, { x: 22, y: 11 }, { x: 23, y: 11 }, { x: 24, y: 11 }, { x: 25, y: 11 }, { x: 26, y: 11 }, { x: 27, y: 11 }
        ];

        const pathB = [
            { x: 26, y: 0 }, { x: 26, y: 1 }, { x: 26, y: 2 }, { x: 26, y: 3 },
            { x: 26, y: 3 }, { x: 25, y: 3 }, { x: 24, y: 3 }, { x: 23, y: 3 }, { x: 22, y: 3 }, { x: 21, y: 3 }, { x: 20, y: 3 }, { x: 19, y: 3 }, { x: 18, y: 3 }, { x: 17, y: 3 }, { x: 16, y: 3 }, { x: 15, y: 3 }, { x: 14, y: 3 }, { x: 13, y: 3 }, { x: 12, y: 3 }, { x: 11, y: 3 }, { x: 10, y: 3 }, { x: 9, y: 3 }, { x: 8, y: 3 }, { x: 7, y: 3 }, { x: 6, y: 3 },
            { x: 6, y: 4 }, { x: 6, y: 5 }, { x: 6, y: 6 }, { x: 6, y: 7 }, { x: 6, y: 8 }, { x: 6, y: 9 }, { x: 6, y: 10 }, { x: 6, y: 11 }
        ];


        for (const tile of [...pathA, ...pathB]) {
            if (tileMap[tile.y] && tileMap[tile.y][tile.x]) {
                tileMap[tile.y][tile.x] = { type: 'path', walkable: false };
            }
        }

        const pathPixels = {
            A: pathA.map(tile => ({
                x: tile.x * TILE_SIZE + TILE_SIZE / 2,
                y: tile.y * TILE_SIZE + TILE_SIZE / 2
            })),
            B: pathB.map(tile => ({
                x: tile.x * TILE_SIZE + TILE_SIZE / 2,
                y: tile.y * TILE_SIZE + TILE_SIZE / 2
            }))
        };


        const game = {
            wave: 1,
            gold: 200,
            health: 100,
            buff: 1.0,
            research: 0,
            researchMax: 50,
            enemies: [],
            towers: [],
            projectiles: [],
            particles: [],
            placing: null,
            placingPos: { x: 0, y: 0 },
            selectedTower: null,
            toSpawn: 0,
            spawnTimer: 0,
            waveInProgress: false,
            paused: false,
            autoNext: false,
            spawnInterval: 0.6,
            techs: {
                piercing: false,
                overcharge: false,
                doubleshot: false,
                regeneration: false
            }
        };


        const TECHS = {
            piercing: { name: "Piercing Shot", desc: "Arrows pierce enemies", cost: 50, unlock: "archer" },
            overcharge: { name: "Overcharge", desc: "Cannons damage nearby towers", cost: 60, unlock: "cannon" },
            doubleshot: { name: "Double Shot", desc: "Archers fire 2x faster", cost: 50, unlock: "archer" },
            regeneration: { name: "Shield Regen", desc: "Regain 1 HP per wave", cost: 40, unlock: "any" }
        };


        const enemyTypes = {
            normal: { hp: 40 * game.buff, speed: 70, gold: 10 * game.buff },
            fast: { hp: 25 * game.buff, speed: 130, gold: 12 * game.buff },
            armored: { hp: 120 * game.buff, speed: 40, gold: 15 * game.buff },
            healer: { hp: 35 * game.buff, speed: 35, gold: 20 * game.buff, heal: 6, healRange: 60 },
            boss: { hp: 400 * game.buff, speed: 50, gold: 50 * game.buff, armor: 0.8 },
        };


        class Enemy {
            constructor(type, pathChoice) {
                const t = enemyTypes[type];
                this.type = type;
                this.pathChoice = pathChoice;
                const path = pathChoice === "A" ? pathPixels.A : pathPixels.B;
                this.x = path[0].x;
                this.y = path[0].y;
                this.hp = t.hp + (game.wave * 4);
                this.maxHp = this.hp;
                this.baseSpeed = t.speed;
                this.speed = this.baseSpeed;
                this.index = 0;
                this.dead = false;
                this.reachedEnd = false;
                this.gold = t.gold;
                this.armor = t.armor || 1;
                this.healAmount = t.heal || 0;
                this.healRange = t.healRange || 0;
                this.slowEffects = [];
                this.stunned = 0;
            }

            update(dt) {
                if (this.dead) return;
                if (this.stunned > 0) {
                    this.stunned -= dt;
                    return;
                }

                const path = this.pathChoice === "A" ? pathPixels.A : pathPixels.B;

                if (this.type === "healer") this.healNearby();

                let mult = 1;
                for (let i = this.slowEffects.length - 1; i >= 0; i--) {
                    const s = this.slowEffects[i];
                    s.time -= dt;
                    if (s.time <= 0) this.slowEffects.splice(i, 1);
                    else mult *= (1 - s.mult);
                }
                this.speed = this.baseSpeed * mult;

                const next = path[this.index + 1];
                if (!next) {
                    this.reachedEnd = true;
                    this.dead = true;
                    game.health = Math.max(0, game.health - 1);
                    spawnParticles(this.x, this.y, "#ff9e88");
                    return;
                }

                const dx = next.x - this.x;
                const dy = next.y - this.y;
                const dist = Math.hypot(dx, dy);

                if (dist < 3) {
                    this.index++;
                    return;
                }

                this.x += (dx / dist) * this.speed * dt;
                this.y += (dy / dist) * this.speed * dt;

                if (this.hp <= 0) {
                    this.dead = true;
                    spawnParticles(this.x, this.y, "#ffef9e");
                    game.gold += this.gold;
                    game.research = Math.min(game.researchMax, game.research + 1);
                }
            }

            healNearby() {
                for (const e of game.enemies) {
                    if (e === this || e.dead) continue;
                    const d = Math.hypot(e.x - this.x, e.y - this.y);
                    if (d < this.healRange) {
                        e.hp = Math.min(e.maxHp, e.hp + this.healAmount * 0.05);
                    }
                }
            }

            draw() {
                const size = (this.type === "boss") ? 18 : 10;
                if (this.type === "fast") {
                    ctx.save();
                    const path = this.pathChoice === "A" ? pathPixels.A : pathPixels.B;
                    const next = path[this.index + 1] || path[path.length - 1];
                    const angle = Math.atan2(next.y - this.y, next.x - this.x);
                    ctx.translate(this.x, this.y);
                    ctx.rotate(angle);
                    ctx.fillStyle = "#8a3f2e";
                    ctx.beginPath();
                    ctx.moveTo(10, 0);
                    ctx.lineTo(-6, -7);
                    ctx.lineTo(-6, 7);
                    ctx.closePath();
                    ctx.fill();
                    ctx.restore();
                } else if (this.type === "armored") {
                    ctx.fillStyle = "#3b2e1d";
                    ctx.fillRect(this.x - size, this.y - size, size * 2, size * 2);
                    ctx.fillStyle = "#27211a";
                    ctx.fillRect(this.x - size, this.y - size - 6, size * 1.5, 5);
                } else if (this.type === "healer") {
                    ctx.fillStyle = "#4ea86e";
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = "#fff";
                    ctx.fillRect(this.x - 2, this.y - 6, 4, 12);
                    ctx.fillRect(this.x - 6, this.y - 2, 12, 4);
                } else if (this.type === "boss") {
                    ctx.fillStyle = "#6e1a1a";
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, size + 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = "#ffaa00";
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, size + 2, 0, Math.PI * 2);
                    ctx.stroke();
                } else {
                    ctx.fillStyle = "#7c5341";
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, size, 0, Math.PI * 2);
                    ctx.fill();
                }


                ctx.fillStyle = "#000";
                ctx.fillRect(this.x - 15, this.y - size - 8, 30, 4);
                ctx.fillStyle = "#0f0";
                ctx.fillRect(this.x - 15, this.y - size - 8, (this.hp / this.maxHp) * 30, 4);
            }

            progressScore() {
                const path = this.pathChoice === "A" ? pathPixels.A : pathPixels.B;
                const next = path[this.index + 1] || path[path.length - 1];
                const remaining = Math.hypot(next.x - this.x, next.y - this.y);
                return this.index * 10000 - remaining;
            }
        }


        const TOWER_STATS = {
            archer: { range: 150, dmg: 8, firerate: 2.0, cost: 80, color: "#c4a747" },
            cannon: { range: 140, dmg: 35, firerate: 0.8, aoe: 60, cost: 120, color: "#8b7355" },
            wizard: { range: 160, dmg: 6, firerate: 1.2, slow: 0.5, stun: 0.3, cost: 150, color: "#6a5acd" },
            tesla: { range: 180, dmg: 15, firerate: 1.5, chain: 3, cost: 200, color: "#ffff00" },
            farm: { range: 0, dmg: 0, firerate: 0, cost: 100, color: "#90ee90", passive: 1 }
        };

        class Tower {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.totalSpent = TOWER_STATS[type].cost;
                this.applyStats();
                this.cooldown = 0;
                this.deleted = false;
                this.lastTargets = [];
            }

            applyStats() {
                const s = TOWER_STATS[this.type];
                this.range = s.range;
                this.dmg = s.dmg;
                this.firerate = s.firerate;
                this.slow = s.slow || 0;
                this.stun = s.stun || 0;
                this.aoe = s.aoe || 0;
                this.chain = s.chain || 0;
                this.color = s.color;
                this.passive = s.passive || 0;
                this.cost = s.cost;
            }

            update(dt) {
                if (this.type === "farm") return;

                if (this.cooldown > 0) this.cooldown -= dt;

                let best = null;
                let bestScore = -Infinity;
                for (const e of game.enemies) {
                    if (e.dead) continue;
                    const d = Math.hypot(e.x - this.x, e.y - this.y);
                    if (d <= this.range) {
                        const score = e.progressScore();
                        if (score > bestScore) {
                            bestScore = score;
                            best = e;
                        }
                    }
                }

                if (!best) return;

                if (this.cooldown <= 0) {
                    if (this.type === "archer") {
                        game.projectiles.push(new ArrowProjectile(this, best));
                    } else if (this.type === "cannon") {
                        game.projectiles.push(new CannonProjectile(this, best));
                    } else if (this.type === "wizard") {
                        game.projectiles.push(new WizardProjectile(this, best));
                    } else if (this.type === "tesla") {
                        game.projectiles.push(new TeslaProjectile(this, best));
                    }
                    this.cooldown = 1 / this.firerate;
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);

                ctx.fillStyle = "#3b2f20";
                ctx.beginPath();
                ctx.arc(0, 0, 14, 0, Math.PI * 2);
                ctx.fill();

                if (this.type === 'archer') {
                    ctx.fillStyle = this.color;
                    ctx.fillRect(-8, -16, 16, 12);
                    ctx.fillRect(-2, -20, 4, 8);
                } else if (this.type === 'cannon') {
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.ellipse(0, -12, 10, 8, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillRect(-4, -20, 8, 10);
                } else if (this.type === 'wizard') {
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.moveTo(0, -20);
                    ctx.lineTo(10, -10);
                    ctx.lineTo(0, 0);
                    ctx.lineTo(-10, -10);
                    ctx.closePath();
                    ctx.fill();
                } else if (this.type === 'tesla') {
                    ctx.fillStyle = this.color;
                    ctx.fillRect(-10, -10, 20, 20);
                    ctx.fillStyle = "#000";
                    ctx.beginPath();
                    ctx.arc(0, 0, 4, 0, Math.PI * 2);
                    ctx.fill();
                } else if (this.type === 'farm') {
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(0, 0, 12, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = "#228B22";
                    ctx.fillRect(-6, -8, 12, 8);
                }

                ctx.restore();

                if (game.selectedTower === this) {
                    ctx.beginPath();
                    ctx.strokeStyle = "rgba(80,140,230,0.2)";
                    ctx.lineWidth = 2;
                    ctx.arc(this.x, this.y, this.range, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
        }


        class ArrowProjectile {
            constructor(tower, target) {
                this.x = tower.x;
                this.y = tower.y;
                this.target = target;
                this.dmg = tower.dmg;
                this.slow = tower.slow;
                this.speed = 400;
                this.dead = false;
                this.piercing = game.techs.piercing;
                this.targetsHit = new Set();
            }

            update(dt) {
                if (this.target.dead && this.targetsHit.size === 0) {
                    this.dead = true;
                    return;
                }

                let target = this.target;
                if (target.dead) {

                    for (const e of game.enemies) {
                        if (e.dead || this.targetsHit.has(e)) continue;
                        const d = Math.hypot(e.x - this.x, e.y - this.y);
                        if (d < 150) {
                            target = e;
                            break;
                        }
                    }
                }

                const dx = target.x - this.x;
                const dy = target.y - this.y;
                const dist = Math.hypot(dx, dy);

                if (dist < 8) {
                    target.hp -= this.dmg;
                    if (this.slow > 0) target.slowEffects.push({ mult: this.slow, time: 1.2 });
                    this.targetsHit.add(target);
                    if (!this.piercing || this.targetsHit.size >= 3) this.dead = true;
                    return;
                }

                this.x += (dx / dist) * this.speed * dt;
                this.y += (dy / dist) * this.speed * dt;
            }

            draw() {
                ctx.fillStyle = "#ffdd55";
                ctx.beginPath();
                ctx.arc(this.x, this.y, 4, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        class CannonProjectile {
            constructor(tower, target) {
                this.x = tower.x;
                this.y = tower.y;
                this.targetX = target.x;
                this.targetY = target.y;
                this.dmg = tower.dmg;
                this.aoe = tower.aoe;
                this.speed = 300;
                this.dead = false;
            }

            update(dt) {
                const dx = this.targetX - this.x;
                const dy = this.targetY - this.y;
                const dist = Math.hypot(dx, dy);

                if (dist < 8) {
                    this.hit();
                    this.dead = true;
                    return;
                }

                this.x += (dx / dist) * this.speed * dt;
                this.y += (dy / dist) * this.speed * dt;
            }

            hit() {
                for (const e of game.enemies) {
                    if (Math.hypot(e.x - this.x, e.y - this.y) < this.aoe) {
                        e.hp -= this.dmg;
                    }
                }
                spawnParticles(this.x, this.y, "#ff8844", 12);
            }

            draw() {
                ctx.fillStyle = "#8b6914";
                ctx.beginPath();
                ctx.arc(this.x, this.y, 6, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        class WizardProjectile {
            constructor(tower, target) {
                this.x = tower.x;
                this.y = tower.y;
                this.target = target;
                this.dmg = tower.dmg;
                this.slow = tower.slow;
                this.stun = tower.stun;
                this.speed = 350;
                this.dead = false;
            }

            update(dt) {
                if (this.target.dead) {
                    this.dead = true;
                    return;
                }

                const dx = this.target.x - this.x;
                const dy = this.target.y - this.y;
                const dist = Math.hypot(dx, dy);

                if (dist < 8) {
                    this.target.hp -= this.dmg;
                    this.target.slowEffects.push({ mult: this.slow, time: 0.8 });
                    this.target.stunned = this.stun;
                    this.dead = true;
                    spawnParticles(this.x, this.y, "#6a5aff", 8);
                    return;
                }

                this.x += (dx / dist) * this.speed * dt;
                this.y += (dy / dist) * this.speed * dt;
            }

            draw() {
                ctx.fillStyle = "#6a5aff";
                ctx.beginPath();
                ctx.arc(this.x, this.y, 5, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        class TeslaProjectile {
            constructor(tower, target) {
                this.x = tower.x;
                this.y = tower.y;
                this.target = target;
                this.dmg = tower.dmg;
                this.chain = tower.chain;
                this.speed = 500;
                this.dead = false;
                this.targetsHit = new Set([target]);
            }

            update(dt) {
                if (this.target.dead) {
                    this.dead = true;
                    return;
                }

                const dx = this.target.x - this.x;
                const dy = this.target.y - this.y;
                const dist = Math.hypot(dx, dy);

                if (dist < 8) {
                    this.chainLightning();
                    this.dead = true;
                    return;
                }

                this.x += (dx / dist) * this.speed * dt;
                this.y += (dy / dist) * this.speed * dt;
            }

            chainLightning() {
                this.target.hp -= this.dmg;
                spawnParticles(this.target.x, this.target.y, "#ffff00", 6);

                if (this.chain > 1) {
                    for (let i = 0; i < this.chain - 1; i++) {
                        let best = null;
                        let bestDist = Infinity;
                        for (const e of game.enemies) {
                            if (e.dead || this.targetsHit.has(e)) continue;
                            const d = Math.hypot(e.x - this.target.x, e.y - this.target.y);
                            if (d < 150 && d < bestDist) {
                                bestDist = d;
                                best = e;
                            }
                        }
                        if (!best) break;
                        best.hp -= this.dmg * 0.7;
                        this.targetsHit.add(best);
                        spawnParticles(best.x, best.y, "#ffff00", 4);
                    }
                }
            }

            draw() {
                ctx.strokeStyle = "#ffff00";
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(this.x - 4, this.y);
                ctx.lineTo(this.x + 4, this.y);
                ctx.moveTo(this.x, this.y - 4);
                ctx.lineTo(this.x, this.y + 4);
                ctx.stroke();
            }
        }


        function spawnParticles(x, y, color, count = 2) {
            for (let i = 0; i < count; i++) {
                game.particles.push({
                    x, y,
                    dx: (Math.random() - 0.5) * 8,
                    dy: (Math.random() - 0.5) * 8,
                    life: 0.5 + Math.random() * 0.8,
                    color
                });
            }
        }

        function updateParticles(dt) {
            for (const p of game.particles) {
                p.x += p.dx;
                p.y += p.dy;
                p.life -= dt;
            }
            game.particles = game.particles.filter(p => p.life > 0);
        }

        function drawParticles() {
            for (const p of game.particles) {
                ctx.globalAlpha = Math.max(0, p.life * 1.8);
                ctx.fillStyle = p.color;
                ctx.fillRect(p.x, p.y, 4, 4);
            }
            ctx.globalAlpha = 1;
        }


        canvas.addEventListener("click", e => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (game.placing) {
                placeTower(x, y);
                return;
            }

            selectExistingTower(x, y);
        });

        canvas.addEventListener("mousemove", e => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            game.placingPos.x = x;
            game.placingPos.y = y;
        });

        function selectTower(type) {
            game.placing = type;
            game.selectedTower = null;
            updateTowerUI();
        }

        function placeTower(x, y) {
            const tileX = Math.floor(x / TILE_SIZE);
            const tileY = Math.floor(y / TILE_SIZE);

            if (tileY >= GRID_HEIGHT || tileX >= GRID_WIDTH || tileY < 0 || tileX < 0) {
                spawnParticles(x, y, "#ff6666", 8);
                return;
            }

            const tile = tileMap[tileY][tileX];
            if (!tile || tile.type !== 'grass' || tile.walkable === false) {
                spawnParticles(x, y, "#ff6666", 8);
                return;
            }

            const baseCost = TOWER_STATS[game.placing].cost;
            if (game.gold < baseCost) {
                game.placing = null;
                return;
            }

            const towerX = tileX * TILE_SIZE + TILE_SIZE / 2;
            const towerY = tileY * TILE_SIZE + TILE_SIZE / 2;

            const t = new Tower(towerX, towerY, game.placing);
            game.towers.push(t);
            game.gold -= baseCost;
            t.totalSpent = baseCost;
            game.placing = null;

            tile.walkable = false;
            tile.type = 'tower';
        }

        function selectExistingTower(x, y) {
            for (const t of game.towers) {
                if (Math.hypot(x - t.x, y - t.y) < 18) {
                    game.selectedTower = t;
                    updateTowerUI();
                    return;
                }
            }
            game.selectedTower = null;
            updateTowerUI();
        }

        function updateTowerUI() {
            if (!game.selectedTower) {
                towerInfo.textContent = "None";
                sellBtn.disabled = true;
                return;
            }

            const t = game.selectedTower;
            towerInfo.innerHTML = `
            Type: <strong>${t.type}</strong><br>
            Damage: ${t.dmg}<br>
            Range: ${t.range}<br>
            Cost: ${t.cost}
        `;
            sellBtn.disabled = false;
        }

        function sellTower() {
            const t = game.selectedTower;
            if (!t) return;
            const refund = Math.floor(t.totalSpent * 0.6);
            game.gold += refund;
            t.deleted = true;

            const tileX = Math.floor(t.x / TILE_SIZE);
            const tileY = Math.floor(t.y / TILE_SIZE);
            if (tileY >= 0 && tileY < GRID_HEIGHT && tileX >= 0 && tileX < GRID_WIDTH) {
                tileMap[tileY][tileX].walkable = true;
                tileMap[tileY][tileX].type = 'grass';
            }

            game.selectedTower = null;
            updateTowerUI();
        }


        function startWave() {
            if (game.waveInProgress) return;
            const count = 8 + Math.floor(game.wave * 2);
            game.toSpawn = count;
            game.spawnTimer = 0;
            game.waveInProgress = true;
            if (game.wave != 1) {
                game.buff *= 1.1;
                console.log("Buff increased to: " + game.buff.toFixed(2));
                buffDisp.textContent = game.buff.toFixed(2);
            }
        }

        function spawnEnemy() {
            let type = "normal";
            const rand = Math.random();
            if (game.wave >= 10 && rand < 0.05) type = "boss";
            else if (rand < 0.15) type = "healer";
            else if (rand < 0.25) type = "armored";
            else if (rand < 0.4) type = "fast";

            const pathChoice = Math.random() < 0.5 ? "A" : "B";
            game.enemies.push(new Enemy(type, pathChoice));
        }


        function updateResearchUI() {
            researchDisp.textContent = `${game.research}/${game.researchMax}`;
            researchList.innerHTML = "";

            for (const [key, tech] of Object.entries(TECHS)) {
                if (game.techs[key]) {
                    const div = document.createElement("div");
                    div.className = "synergy";
                    div.innerHTML = `‚úì <strong>${tech.name}</strong><br>${tech.desc}`;
                    researchList.appendChild(div);
                } else {
                    const btn = document.createElement("button");
                    btn.className = "towerButton small";
                    btn.innerHTML = `üî¨ ${tech.name}<br>Cost: ${tech.cost}`;
                    btn.disabled = game.research < tech.cost;
                    btn.onclick = () => {
                        if (game.research >= tech.cost) {
                            game.research -= tech.cost;
                            game.techs[key] = true;
                            updateResearchUI();
                        }
                    };
                    researchList.appendChild(btn);
                }
            }
        }


        let last = performance.now();
        function loop(now) {
            if (game.paused) {
                requestAnimationFrame(loop);
                return;
            }

            const dt = Math.min((now - last) / 1000, 0.033);
            last = now;

            ctx.clearRect(0, 0, canvas.width, canvas.height);


            for (let y = 0; y < GRID_HEIGHT; y++) {
                for (let x = 0; x < GRID_WIDTH; x++) {
                    const tile = tileMap[y][x];
                    const xPos = x * TILE_SIZE;
                    const yPos = y * TILE_SIZE;

                    if (tile.type === 'grass') {
                        ctx.fillStyle = '#90EE90';
                        ctx.fillRect(xPos, yPos, TILE_SIZE, TILE_SIZE);
                    } else if (tile.type === 'path') {
                        ctx.fillStyle = '#8f765d';
                        ctx.fillRect(xPos, yPos, TILE_SIZE, TILE_SIZE);
                        ctx.fillStyle = '#a0866d';
                        for (let sy = 0; sy < TILE_SIZE; sy += 8) {
                            for (let sx = 0; sx < TILE_SIZE; sx += 8) {
                                if (Math.random() > 0.3) {
                                    ctx.fillRect(xPos + sx + Math.random() * 2, yPos + sy + Math.random() * 2, 6, 6);
                                }
                            }
                        }
                    }

                    ctx.strokeStyle = 'rgba(0,0,0,0.1)';
                    ctx.strokeRect(xPos, yPos, TILE_SIZE, TILE_SIZE);
                }
            }


            if (game.toSpawn > 0) {
                game.spawnTimer -= dt;
                if (game.spawnTimer <= 0) {
                    game.spawnTimer = game.spawnInterval;
                    spawnEnemy();
                    game.toSpawn--;
                }
            }


            for (const e of game.enemies) e.update(dt);
            game.enemies = game.enemies.filter(e => !e.dead && !e.reachedEnd);

            for (const t of game.towers) t.update(dt);
            game.towers = game.towers.filter(t => !t.deleted);


            for (const t of game.towers) {
                if (t.type === "farm") {
                    game.gold += t.passive * dt;
                }
            }

            for (const p of game.projectiles) p.update(dt);
            game.projectiles = game.projectiles.filter(p => !p.dead);

            updateParticles(dt);


            for (const t of game.towers) t.draw();
            for (const p of game.projectiles) p.draw();
            for (const e of game.enemies) e.draw();
            drawParticles();


            if (game.placing) {
                const pos = game.placingPos;
                const s = TOWER_STATS[game.placing];

                const tileX = Math.floor(pos.x / TILE_SIZE);
                const tileY = Math.floor(pos.y / TILE_SIZE);
                const isValid = tileY < GRID_HEIGHT && tileX < GRID_WIDTH &&
                    tileMap[tileY][tileX].type === 'grass' &&
                    tileMap[tileY][tileX].walkable;

                ctx.globalAlpha = 0.85;
                ctx.fillStyle = isValid ? "rgba(200,220,200,0.6)" : "rgba(255,100,100,0.5)";
                ctx.beginPath();
                ctx.arc(tileX * TILE_SIZE + TILE_SIZE / 2, tileY * TILE_SIZE + TILE_SIZE / 2, 14, 0, Math.PI * 2);
                ctx.fill();

                if (s.range > 0) {
                    ctx.beginPath();
                    ctx.strokeStyle = isValid ? "rgba(60,140,80,0.2)" : "rgba(255,80,80,0.2)";
                    ctx.lineWidth = 2;
                    ctx.arc(tileX * TILE_SIZE + TILE_SIZE / 2, tileY * TILE_SIZE + TILE_SIZE / 2, s.range, 0, Math.PI * 2);
                    ctx.stroke();
                }
                ctx.globalAlpha = 1;
            }


            waveDisp.textContent = game.wave;
            enemyDisp.textContent = game.enemies.length + " +" + game.toSpawn;
            goldDisp.textContent = "$" + Math.floor(game.gold);
            healthDisp.textContent = game.health;
            updateResearchUI();

            if (game.health <= 0) {
                ctx.fillStyle = "rgba(0,0,0,0.7)";
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = "#fff";
                ctx.font = "40px Arial";
                ctx.textAlign = "center";
                ctx.fillText("GAME OVER", canvas.width / 2, canvas.height / 2);
                return;
            }


            if (game.waveInProgress && game.enemies.length === 0 && game.toSpawn === 0) {
                game.waveInProgress = false;
                game.gold += 50 + game.wave * 10;
                if (game.techs.regeneration) game.health = Math.min(100, game.health + 1);
                game.wave++;
            }

            requestAnimationFrame(loop);
        }

        loop(performance.now());


        document.addEventListener("keydown", e => {
            if (e.key === 'p' || e.key === 'P') togglePause();
        });

        function togglePause() {
            game.paused = !game.paused;
            pauseBtn.textContent = game.paused ? "Resume" : "Pause";
        }


        setInterval(() => {
            for (const [type, stats] of Object.entries(TOWER_STATS)) {
                const btn = document.getElementById(`btn-${type}`);
                if (btn) btn.disabled = game.gold < stats.cost;
            }
        }, 100);

        updateResearchUI();
    </script>

</body>

</html>